<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>ModelicaReference.Classes</title>
<meta name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="&quot;Classes (model, function, ...)&quot;">
<style type="text/css">
*       { font-size: 100%; font-family: Arial, sans-serif; }
.modelica, .modelica * { font-size: 90%; font-family: Courier, monospace; white-space: pre; } /* For the Modelica code (in exported html). */
h4      { font-size: 100%; font-weight: bold; color: green; } 
h3      { font-size: 110%; font-weight: bold; color: green; }
h2      { font-size: 130%; font-weight: bold; color: green; }
address { font-weight: normal; }
td      { padding: 2px; border: 1px solid #808080; vertical-align: top; }
th      { padding: 2px; border: 1px solid #808080; vertical-align: top; font-weight: bold; }
table   { border: 1px solid #808080; border-collapse: collapse; }
pre, code {font-family: "Courier New", monospace;}
pre {white-space: pre; overflow-x : hidden;}
.ModelicaDescription {font-weight: bold;} /* For the description string of the class. */
.ModelicaBaseClass {} /* For the list of base-classes at the of the description. */
.ModelicaKeyword { color: blue; font-weight: normal; font-style: normal; } /* Keywords in Modelica. */
.ModelicaComment { color: #006400;  font-weight: normal; font-style: normal;} /* All three variants of comments in Modelica.  */
.ModelicaString { color: #006400;  font-weight: normal; font-style: normal;} /* String constants. */
.ModelicaClass { color: red; font-weight: normal; font-style: normal;} /* Formatting the names of referenced classes (for base-class and components). */
.ModelicaFunction { color: red; font-weight: normal; font-style: normal;} /* Formatting for called functions. */
.ModelicaTablePackageContent { } /* The table of contents for each package. */
.ModelicaTableCrossReference { } /* The optional cross-reference table. */
.ModelicaTableInputs {} /* The table of inputs for a function. */
.ModelicaTableOutputs {} /* The table of outputs for a function. */
.ModelicaTableParameters {} /* The table of parameters for a model/block. */
.ModelicaTableConnectors {} /* The table of connectors for a model/block. */
.ModelicaTableContents {} /* The table of contents for a connector. */
.ModelicaStartAttribute { font-weight: bold; } /* The formatting used for start-attribute in the table of parameters, to separate them from parameter values. */
.ModelicaParameterTab { background-color: #c0c0c0; font-weight: bold; } /* The tab-heading in the table of parameters */
.ModelicaParameterGroup { background-color: #e0e0e0; } /* The group-heading in the table of parameters */
</style>
</head>
<body>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE Classes<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Classes" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Classes"></a><a href="ModelicaReference.html#ModelicaReference"
>ModelicaReference</a>.Classes</h2>
<p>
</p>

<p>
In this package specialized kinds of classes (earlier known as restricted classes) are
described. They have the properties of a general class, apart from restrictions.
Moreover, they have additional properties called enhancements.
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</span></p>
<h3>Package Content</h3>
<table summary="Package Content" class="ModelicaTablePackageContent">
<tr>
<th>Name</th>
<th>Description</th>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Classes.'block'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'block'"
>'block'</a>
</td>
<td>block</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Classes.'class'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'class'"
>'class'</a>
</td>
<td>class</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Classes.'connector'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'connector'"
>'connector'</a>
</td>
<td>connector</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Classes.ExternalObject" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.ExternalObject"
>ExternalObject</a>
</td>
<td>ExternalObject</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Classes.'function'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'function'"
>'function'</a>
</td>
<td>function</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Classes.'model'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'model'"
>'model'</a>
</td>
<td>model</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Classes.'package'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'package'"
>'package'</a>
</td>
<td>package</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Classes.'record'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'record'"
>'record'</a>
</td>
<td>record</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Classes.'type'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'type'"
>'type'</a>
</td>
<td>type</td>
</tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'block'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Classes.'block'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Classes.'block'"></a><a href="ModelicaReference_Classes.html#ModelicaReference.Classes"
>ModelicaReference.Classes</a>.'block'</h2>

<p>
Define specialized class <em>block</em>
</p>
<h4>Examples</h4>

<pre><strong>block</strong> Integrator
  <strong>input</strong> Real u;
  <strong>output</strong> Real y;
<strong>protected</strong>
  Real x;
<strong>equation
  der</strong>(x) = u;
  y = x;
<strong>end</strong> Integrator;</pre>

<h4>Syntax</h4>

<pre>   [ <strong>encapsulated</strong> ][ <strong>partial </strong>] <strong>block</strong>
   IDENT class_specifier

class_specifier :
   string_comment composition <strong>end</strong> IDENT
   | "=" base_prefix name [ array_subscripts ] [ class_modification ] comment
   | "=" <strong>enumeration</strong> "(" ( [enum_list] | ":" ) ")" comment</pre>

<p>See Modelica Language Specification for further details.</p>

<h4>Description</h4>
<p>
A block class is the same as a model class
with the restriction that each connector component of a block must
have prefixes input and/or output for all connector variables.
The purpose is to model input/output blocks of block diagrams.
Due to the restrictions on input and output prefixes,
connections between blocks are only possible according
to block diagram semantic.
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'class'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Classes.'class'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Classes.'class'"></a><a href="ModelicaReference_Classes.html#ModelicaReference.Classes"
>ModelicaReference.Classes</a>.'class'</h2>

<p>
Define class
</p>
<h4>Examples</h4>

<pre><strong>class</strong> MyTable
  <strong>extends</strong> ExternalObject;
  <strong>function</strong> constructor
     ...
  <strong>end</strong> constructor;

  <strong>function</strong> destructor
     ...
  <strong>end</strong> destructor;
<strong>end</strong> MyTable;</pre>

<h4>Syntax</h4>
<pre>   [ <strong>encapsulated</strong> ][ <strong>partial </strong>] <strong>class</strong>
   IDENT class_specifier

class_specifier :
   string_comment composition <strong>end</strong> IDENT
   | "=" base_prefix name [ array_subscripts ] [ class_modification ] comment
   | "=" <strong>enumeration</strong> "(" ( [enum_list] | ":" ) ")" comment</pre>

<p>See Modelica Language Specification for further details.</p>

<h4>Description</h4>

<p>
The keyword class is used to define general classes (without any restrictions).
It is identical to the keyword model.
In most cases, it is recommended to use specialized classes as
<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'connector'"
>connector</a>,
<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'model'"
>model</a>,
<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'block'"
>block</a>,
<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'package'"
>package</a>,
<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'record'"
>record</a>,
<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'function'"
>function</a>,
<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'type'"
>type</a>.
"class" should be used to define
<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.ExternalObject"
>ExternalObject</a>s,
and can be used for classes merely containing documentation and/or graphics.
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'connector'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Classes.'connector'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Classes.'connector'"></a><a href="ModelicaReference_Classes.html#ModelicaReference.Classes"
>ModelicaReference.Classes</a>.'connector'</h2>

<p>
Define specialized class <em>connector</em>
</p>
<h4>Examples</h4>

<pre><strong>connector</strong> flange
  Modelica.SIunits.Angle phi;
  <strong>flow</strong> Modelica.SIunits.Torque tau;
<strong>end</strong> flange;</pre>

<h4>Syntax</h4>
<pre>   [ <strong>encapsulated</strong> ][ <strong>partial </strong>] <strong>connector</strong>
   IDENT class_specifier

class_specifier :
   string_comment composition <strong>end</strong> IDENT
   | "=" base_prefix name [ array_subscripts ] [ class_modification ] comment
   | "=" <strong>enumeration</strong> "(" ( [enum_list] | ":" ) ")" comment</pre>

<p>See Modelica Language Specification for further details.</p>

<h4>Description</h4>
<p>The keyword connector is used to define connectors, which are used
in
<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'connect()'"
>connect()</a>
statements. In connectors, no equations are allowed in the
definition or in any of its components.
With respect to "class", it is enhanced to allow connect(..) to components
of connector classes.
</p>

<p>
Variable declarations in a connector can have the additional prefixes
<a href="ModelicaReference.html#ModelicaReference.'flow'"
>flow</a> or
<a href="ModelicaReference.html#ModelicaReference.'stream'"
>stream</a>, besides
the prefixes
<a href="ModelicaReference.html#ModelicaReference.'input'"
>input</a> and
<a href="ModelicaReference.html#ModelicaReference.'output'"
>output</a>, that are
also allowed outside of a connector. Based on the prefix, a
<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'connect()'"
>connect()</a>
statement leads to specific connection equations, that describe the
balance equations in the infinitesimal connection points.
</p>

<h4>Example</h4>

<p>
If three connectors c1, c2, c3 with the definition
</p>

<pre>
<strong>connector</strong> Demo
  Real        p;  // potential variable
  <strong>flow</strong>   Real f;  // flow variable
  <strong>stream</strong> Real s;  // stream variable
<strong>end</strong> Demo;
</pre>

<p>
are connected together with
</p>

<pre>
   <strong>connect</strong>(c1,c2);
   <strong>connect</strong>(c1,c3);
</pre>

<p>
then this leads to the following equations:
</p>

<pre>
  // Potential variables are identical
  c1.p = c2.p;
  c1.p = c3.p;

  // The sum of the flow variables is zero
  0 = c1.f + c2.f + c3.f;

  /* The sum of the product of flow variables and upstream stream variables is zero
     (this implicit set of equations is explicitly solved when generating code;
     the "&lt;undefined&gt;" parts are defined in such a way that
     inStream(..) is continuous).
  */
  0 = c1.f*(<strong>if</strong> c1.f > 0 <strong>then</strong> s_mix <strong>else</strong> c1.s) +
      c2.f*(<strong>if</strong> c2.f > 0 <strong>then</strong> s_mix <strong>else</strong> c2.s) +
      c3.f*(<strong>if</strong> c3.f > 0 <strong>then</strong> s_mix <strong>else</strong> c3.s);

  <strong>inStream</strong>(c1.s) = <strong>if</strong> c1.f > 0 <strong>then</strong> s_mix <strong>else</strong> &lt;undefined&gt;;
  <strong>inStream</strong>(c2.s) = <strong>if</strong> c2.f > 0 <strong>then</strong> s_mix <strong>else</strong> &lt;undefined&gt;;
  <strong>inStream</strong>(c3.s) = <strong>if</strong> c3.f > 0 <strong>then</strong> s_mix <strong>else</strong> &lt;undefined&gt;;
</pre>

<p><span class="ModelicaBaseClass">Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE ExternalObject<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Classes.ExternalObject" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Classes.ExternalObject"></a><a href="ModelicaReference_Classes.html#ModelicaReference.Classes"
>ModelicaReference.Classes</a>.ExternalObject</h2>

<p>
Define external functions with internal memory.
</p>

<h4>Description</h4>

<p>
External functions may have internal memory reported between function calls. Within Modelica this memory is defined as instance of the predefined class <strong>ExternalObject</strong> according to the following rules:
</p>

<ul>
<li> There is a predefined partial class <strong>ExternalObject</strong>
     [<em>since the class is partial, it is not possible to define an
     instance of this class</em>].</li>

<li> An external object class shall be directly extended from
     ExternalObject, shall have exactly two function definitions,
     called "<strong>constructor</strong>" and "<strong>destructor</strong>", and
     shall not contain other elements.</li>

<li> The constructor function is called exactly once before the first use of
     the object. For each completely constructed object, the destructor
     is called exactly once, after the last use of the object, even
     if an error occurs. The constructor shall have exactly one output
     argument in which the constructed ExternalObject is returned.
     The destructor shall have no output arguments and the only input
     argument of the destructor shall be the ExternalObject.
     It is not legal to call explicitly the constructor and destructor
     functions.</li>

<li> Classes derived from ExternalObject can neither be used in an
     extends-clause nor in a short class definition.</li>

<li> External functions may be defined which operate on the internal memory
     of an ExternalObject. An ExternalObject used as input argument or
     return value of an external C-function is mapped to the C-type "void*".</li>
</ul>

<h4>Examples</h4>

<p>
A user-defined table may be defined in the following way as an ExternalObject
(the table is read in a user-defined format from file and has memory for the last used table interval):
</p>

<pre>
<strong>class</strong> MyTable
  <strong>extends</strong> ExternalObject;
  <strong>function</strong> constructor
    <strong>input</strong>  String  fileName = "";
    <strong>input</strong>  String  tableName = "";
    <strong>output</strong> MyTable table;
    <strong>external</strong> "C" table = initMyTable(fileName, tableName);
  <strong>end</strong> constructor;

  <strong>function</strong> destructor "Release storage of table"
    <strong>input</strong>  MyTable table;
    <strong>external</strong> "C" closeMyTable(table);
  <strong>end</strong> destructor;
<strong>end</strong> MyTable;
</pre>

<p>
and used in the following way:
</p>

<pre>
<strong>model</strong> test "Define a new table and interpolate in it"
  MyTable table=MyTable(fileName ="testTables.txt",
                        tableName="table1");  // call initMyTable
  Real y;
<strong>equation</strong>
  y = interpolateMyTable(table, time);
<strong>end</strong> test;
</pre>

<p>
This requires to provide the following Modelica function:
</p>

<pre>
<strong>function</strong> interpolateMyTable "Interpolate in table"
  <strong>input</strong>  MyTable table;
  <strong>input</strong>  Real  u;
  <strong>output</strong> Real  y;
  <strong>external</strong> "C" y = interpolateMyTable(table, u);
<strong>end</strong> interpolateTable;
</pre>

<p>
The external C-functions may be defined in the following way:
</p>

<pre>
<strong>typedef struct</strong> {  /* User-defined data structure of the table */
  <strong>double</strong>* array;      /* nrow*ncolumn vector       */
  <strong>int</strong>     nrow;       /* number of rows            */
  <strong>int</strong>     ncol;       /* number of columns         */
  <strong>int</strong>     type;       /* interpolation type        */
  <strong>int</strong>     lastIndex;  /* last row index for search */
} MyTable;

<strong>void</strong>* initMyTable(const char* fileName, const char* tableName) {
  MyTable* table = malloc(sizeof(MyTable));
  <strong>if</strong> ( table == NULL ) ModelicaError("Not enough memory");
        // read table from file and store all data in *table
  <strong>return</strong> (void*) table;
}

<strong>void </strong>closeMyTable(void* object) { /* Release table storage */
  MyTable* table = (MyTable*) object;
  <strong>if</strong> ( object == NULL ) return;
  free(table->array);
  free(table);
}

<strong>double</strong> interpolateMyTable(void* object, double u) {
  MyTable* table = (MyTable*) object;
  <strong>double</strong> y;
  // Interpolate using "table" data (compute y)
  <strong>return</strong> y;
}
</pre>

<p><span class="ModelicaBaseClass">Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'function'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Classes.'function'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Classes.'function'"></a><a href="ModelicaReference_Classes.html#ModelicaReference.Classes"
>ModelicaReference.Classes</a>.'function'</h2>

<p>
Define specialized class <em>function</em>
</p>
<h4>Examples</h4>

<pre><strong>function</strong> si
  <strong>input</strong> Real x;
  <strong>output</strong> Real y;
<strong>algorithm</strong>
  y = <strong>if abs</strong>(x) &lt; Modelica.Constants.eps <strong>then</strong> 1 <strong>else</strong> Modelica.Math.sin(x)/x;
<strong>end</strong> si;</pre>

<img src="../Images/function.png" width="400" height="280" alt="Simulation result">

<h4>Syntax</h4>

<pre>   [ <strong>encapsulated</strong> ][ <strong>partial </strong>] <strong>function</strong>
   IDENT class_specifier

class_specifier :
   string_comment composition <strong>end</strong> IDENT
   | "=" base_prefix name [ array_subscripts ] [ class_modification ] comment
   | "=" <strong>enumeration</strong> "(" ( [enum_list] | ":" ) ")" comment</pre>

<p>See Modelica Language Specification for further details.</p>

<h4>Description</h4>

<p>The keyword function is used to define functions as known from programming
languages. Each part of a function interface must
either have causality equal to input or output. A function may not be used in connections.
In functions, no equations or initial algorithm and at most
one algorithm clause are allowed. Calling a function requires
either an algorithm clause or an external function interface.</p>

<p>
The syntax and semantics of a function have many similarities to those of the block
specialized class. A function has many of the properties of a general class,
e.g., being able to inherit other functions, or to redeclare or modify
elements of a function declaration.
</p>

<p>
Modelica functions have the following restrictions compared to a
general Modelica class:
</p>

<ul>
<li> Each input formal parameter of the function must be
     prefixed by the keyword input, and each result formal parameter
     by the keyword output. All public variables are formal parameters.</li>

<li> Input formal parameters are read-only after being bound to the
     actual arguments or default values, i.e., they may not be assigned
     values in the body of the function.</li>

<li> A function may not be used in connections, may have no equations,
     may have no initial algorithm, and can have at most one algorithm
     section, which, if present, is the body of the function.</li>

<li> A function may have zero or one external function interface, which,
     if present, is the external definition of the function.</li>

<li> For a function to be called in a simulation model, it must have
     either an algorithm section or an external function interface as
     its body, and it may not be partial.</li>

<li> A function cannot contain calls to the Modelica built-in operators
     der, initial, terminal, sample, pre, edge, change, reinit, delay,
     cardinality, to the operators of the built-in package Connections,
     and is not allowed to contain when-statements.</li>

<li> The dimension sizes not declared with (:) of each array result or
     array local variable [i.e., a non-input components] of a function must
     be either given by the input formal parameters, or given by constant
     or parameter expressions, or by expressions containing combinations
     of those. If an output or a local array dimension is declared with (:),
     the size of the dimension can be changed in the function. A size change
     takes place by assigning a full array with the respective sizes to the
     dynamically sized array on the left hand side of an equal sign.</li>

<li> The local variables of a function are not automatically initialized to
     the implicit default values of the data type [(e.g., 0.0 for Real)
     for performance reasons. It is the responsibility of the user to
     provide explicit defaults or to define the values of such variables
     before they are referenced.]</li>

<li> Components of a function will inside the function behave as though
     they had discrete-time variability.</li>
</ul>

<p>
Modelica functions have the following enhancements compared to a general Modelica class:
</p>

<ul>
<li> A function may be called using the conventional positional calling syntax
     for passing arguments.</li>

<li> A function can be recursive.</li>

<li> A formal parameter or local variable may be initialized
     through an assignment (:=) of a default value in its declaration.
     Initialization through an equation is not possible.</li>

<li> A function is dynamically instantiated when it is called rather than
     being statically instantiated by an instance declaration,
     which is the case for other kinds of classes.</li>

<li> A function may have an external function interface specifier as its body.</li>

<li> A function may have a return statement in its algorithm section body.</li>

<li> A function allows dimension sizes declared with (:) to be resized
     for non-input array variables (so the actual dimension need not to be known when
     the function is translated).</li>
</ul>

<p>
A function may have a function as an input argument.
The declared type of such an input formal parameter in a function can be
the class-name of a partial function that has no replaceable elements.
It cannot be the class-name of a record [i.e., <em>record constructor functions are not
allowed in this context.</em>] Such an input formal parameter of function type
can also have an optional functional default value. Example:
</p>

<blockquote><pre>
<strong>function</strong> quadrature "Integrate function y=integrand(x) from x1 to x2"
  <strong>input</strong>  Real x1;
  <strong>input</strong>  Real x2;
  <strong>input</strong>  Integrand integrand;   // Integrand is a partial function, see below
  // With default: input Integrand integrand := Modelica.Math.sin;
  <strong>output</strong> Real integral;
<strong>algorithm</strong>
  integral :=(x2-x1)*(integrand(x1) + integrand(x2))/2;
<strong>end</strong> quadrature;

<strong>partial function</strong> Integrand
  <strong>input</strong>  Real x;
  <strong>output</strong> Real y;
<strong>end</strong> Integrand;
</pre></blockquote>

<p>
A functional argument can be provided in one of the following forms
to be passed to a formal parameter of function type in a function call
(see examples below):
</p>
<ol>
<li> as a function name,</li>
<li> as a function partial application,</li>
<li> as a function that is a component,</li>
<li> as a function partial application of a function that is a component.</li>
</ol>

<p>
In all cases the provided function must be "function type compatible"
to the corresponding formal parameter of function type. Example:
</p>

<blockquote><pre>
// A function as a positional input argument according to case (a)
<strong>function</strong> Parabola
   <strong>extends</strong> Integrand;
<strong>algorithm</strong>
   y = x*x;
<strong>end</strong> Parabola;

area = quadrature(0, 1, Parabola);

// The quadrature2 example below uses a function integrand that
// is a component as input argument according to case (c):
<strong>function</strong> quadrature2 "Integrate function y=integrand(x) from x1 to x2"
  <strong>input</strong>  Real x1;
  <strong>input</strong>  Real x2;
  <strong>input</strong>  Integrand integrand;   // Integrand is a partial function type
  <strong>output</strong> Real integral;
<strong>algorithm</strong>
   integral := quadrature(x1,       (x1+x2)/2, integrand)+
               quadrature((x1+x2)/2, x2,       integrand);
<strong>end</strong> quadrature2;
</pre></blockquote>

<p>
A function partial application is a function call with certain
formal parameters bound to expressions. A function partial application
returns a partially evaluated function that is also a function,
with the remaining not bound formal parameters still present in the
same order as in the original function declaration. A function partial
application is specified by the function keyword followed by a function
call to func_name giving named formal parameter associations for the
formal parameters to be bound, e.g.:
</p>

<blockquote><pre>
<strong>function</strong> func_name(..., formal_parameter_name = expr, ...)
</pre></blockquote>

<p>
[<em>Note that the keyword function in a function partial application
differentiates the syntax from a normal function call where some
parameters have been left out, and instead supplied via default values.</em>]
The function created by the function partial application acts as the
original function but with the bound formal input parameters(s) removed,
i.e., they cannot be supplied arguments at function call. The binding
occurs when the partially evaluated function is created. A partially
evaluated function is "function compatible" to the same function where
all bound arguments are removed [<em>thus, for checking function type
compatibility, bound formal parameters are ignored</em>].
</p>

<p>
Example of function partial application as argument, positional argument passing, according to case (b) above:
</p>

<blockquote><pre>
<strong>model</strong> Test
   <strong>parameter</strong> Integer N;
   Real area;
<strong>algorithm</strong>
   area := 0;
   <strong>for</strong> i <strong>in</strong> 1:N <strong>loop</strong>
     area  := area + quadrature(0, 1, <strong>function</strong> Sine(A=2, w=i*time));
   <strong>end for</strong>;
<strong>end</strong> Test;

<strong>function</strong> Sine  "y = Sine(x,A,w)"
  <strong>extends</strong> Integrand;
  <strong>input</strong> Real A;
  <strong>input</strong> Real w;
<strong>algorithm</strong>
  y:=A*Modelica.Math.sin(w*x);
<strong>end</strong> Sine;

//Call with function partial application as named input argument:
area  := area + quadrature(0, 1, integrand = <strong>function</strong> Sine(A=2, w=i*time));
</pre></blockquote>

<p>
Example showing that function types are matching after
removing the bound arguments A and w in a function partial
application:
</p>

<blockquote><pre>
<strong>function</strong> Sine2  "y = Sine2(A,w,x)"
  <strong>input</strong> Real A;
  <strong>input</strong> Real w;
  <strong>input</strong> Real x; // Note: x is now last in argument list.
  <strong>output</strong> Real y;
<strong>algorithm</strong>
  y:=A*Modelica.Math.sin(w*x);
<strong>end</strong> Sine2;

// The partially evaluated Sine2 has only one argument:
// x - and is thus type compatible with Integrand.
area = quadrature(0, 1, integrand = <strong>function</strong> Sine2(A=2, w=3));
</pre></blockquote>

<p>
Example of a function partial application of a function that is
a component, according to case (d) above:
</p>

<blockquote><pre>
<strong>partial function</strong> SurfaceIntegrand
   <strong>input</strong> Real x;
   <strong>input</strong> Real y;
   <strong>output</strong> Real z;
<strong>end</strong> SurfaceIntegrand;

<strong>function</strong> quadratureOnce
  <strong>input</strong> Real x;
  <strong>input</strong> Real y1;
  <strong>input</strong> Real y2;
  <strong>input</strong> SurfaceIntegrand integrand;
  <strong>output</strong> Real z;
<strong>algorithm</strong>
  // This is according to case (d) and needs to bind the 2nd argument
  z := quadrature(y1, y2, <strong>function</strong> integrand(y=x));
<strong>end</strong> quadratureOnce;

<strong>function</strong> surfaceQuadrature
  <strong>input</strong> Real x1;
  <strong>input</strong> Real x2;
  <strong>input</strong> Real y1;
  <strong>input</strong> Real y2;
  <strong>input</strong> SurfaceIntegrand integrand;
  <strong>output</strong> Real integral;
<strong>algorithm</strong>
   // Case (b) and (c)
   integral := quadrature(x1, x2,
     <strong>function</strong> quadratureOnce(y1=y1, y2=y2, integrand=integrand);
<strong>end</strong> surfaceQuadrature;
</pre></blockquote>

<p><span class="ModelicaBaseClass">Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'model'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Classes.'model'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Classes.'model'"></a><a href="ModelicaReference_Classes.html#ModelicaReference.Classes"
>ModelicaReference.Classes</a>.'model'</h2>

<p>
Define specialized class <em>model</em>
</p>
<h4>Examples</h4>

<pre><strong>model</strong> SlidingMass
  <strong>parameter</strong> Modelica.SIunits.Mass m=1;
  <strong>parameter</strong> Modelica.SIunits.Force f=1;
  Modelica.SIunits.Position s;
  Modelica.SIunits.Velocity v;
  Modelica.SIunits.Acceleration a;
<strong>equation</strong>
  <strong>der</strong>(s) = v;
  <strong>der</strong>(v) = a;
  m*a = f;
<strong>end</strong> SlidingMass;</pre>

<h4>Syntax</h4>
<pre>   [ <strong>encapsulated</strong> ][ <strong>partial </strong>] <strong>model</strong>
   IDENT class_specifier

class_specifier :
   string_comment composition <strong>end</strong> IDENT
   | "=" base_prefix name [ array_subscripts ] [ class_modification ] comment
   | "=" <strong>enumeration</strong> "(" ( [enum_list] | ":" ) ")" comment</pre>

<p>See Modelica Language Specification for further details.</p>

<h4>Description</h4>
<p>
The keyword model is identical to the keyword class, i.e.,
no restrictions and no enhancements.
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'package'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Classes.'package'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Classes.'package'"></a><a href="ModelicaReference_Classes.html#ModelicaReference.Classes"
>ModelicaReference.Classes</a>.'package'</h2>

<p>
Define specialized class <em>package</em>
</p>
<h4>Examples</h4>

<pre><strong>package</strong> Library
  <strong>constant</strong> Real k = 0.1;

  <strong>type</strong> X = Real(min=0);

  <strong>model</strong> A
    ...
  <strong>end</strong> A;

  <strong>model</strong> B
    ...
  <strong>end</strong> B;
<strong>end</strong> Library;</pre>

<h4>Syntax</h4>
<pre>   [ <strong>encapsulated</strong> ][ <strong>partial </strong>] <strong>package</strong>
   IDENT class_specifier

class_specifier :
   string_comment composition <strong>end</strong> IDENT
   | "=" base_prefix name [ array_subscripts ] [ class_modification ] comment
   | "=" <strong>enumeration</strong> "(" ( [enum_list] | ":" ) ")" comment</pre>

<p>See Modelica Language Specification for further details.</p>

<h4>Description</h4>
<p>May only contain declarations of classes and constants.
   Enhanced to allow import of elements of packages.</p>


<p><span class="ModelicaBaseClass">Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'record'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Classes.'record'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Classes.'record'"></a><a href="ModelicaReference_Classes.html#ModelicaReference.Classes"
>ModelicaReference.Classes</a>.'record'</h2>

<p>
Define specialized class <em>record</em>
</p>
<h4>Examples</h4>

<pre>  <strong>record</strong> States
    Modelica.SIunits.Position s;
    Modelica.SIunits.Velocity v;
  <strong>end</strong> States;

  <strong>record</strong> System
    <strong>parameter</strong> Modelica.SIunits.Mass m=1;
    <strong>parameter</strong> Modelica.SIunits.Force f=1;
    Modelica.SIunits.Acceleration a;
    States states;
  <strong>end</strong> System;

  <strong>model</strong> SlidingMass
    System sys;
  <strong>equation</strong>
    <strong>der</strong>(sys.states.s) = sys.states.v;
    <strong>der</strong>(sys.states.v) = sys.a;
    sys.m*sys.a = sys.f;
  <strong>end</strong> SlidingMass;</pre>

<h4>Syntax</h4>
<pre>   [ <strong>encapsulated</strong> ][ <strong>partial </strong>] <strong>record</strong>
   IDENT class_specifier

class_specifier :
   string_comment composition <strong>end</strong> IDENT
   | "=" base_prefix name [ array_subscripts ] [ class_modification ] comment
   | "=" <strong>enumeration</strong> "(" ( [enum_list] | ":" ) ")" comment</pre>

<p>See Modelica Language Specification for further details.</p>

<h4>Description</h4>

<p>
The keyword record is used to define records which are generally used in
order to group variables. Only public sections are allowed in the definition
or in any of its components (i.e., equation, algorithm, initial equation,
initial algorithm and protected sections are not allowed). May not be used in
connections. The elements of a record may not have prefixes input, output, inner, outer,
or flow.  Enhanced with implicitly available record constructor function.
Additionally, record components can be used as component references in
expressions and in the left hand side of assignments, subject to
normal type compatibility rules.
</p>


<p><span class="ModelicaBaseClass">Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'type'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Classes.'type'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Classes.'type'"></a><a href="ModelicaReference_Classes.html#ModelicaReference.Classes"
>ModelicaReference.Classes</a>.'type'</h2>

<p>
Define specialized class <em>type</em>
</p>
<h4>Examples</h4>

<pre><strong>type</strong> R0Plus = Real(min=0);</pre>

<h4>Syntax</h4>
<pre>   [ <strong>encapsulated</strong> ][ <strong>partial </strong>] <strong>type</strong>
   IDENT class_specifier

class_specifier :
   string_comment composition <strong>end</strong> IDENT
   | "=" base_prefix name [ array_subscripts ] [ class_modification ] comment
   | "=" <strong>enumeration</strong> "(" ( [enum_list] | ":" ) ")" comment</pre>

<p>See Modelica Language Specification for further details.</p>

<h4>Description</h4>
<p>The keyword type is used to define types, which may only be extensions to the predefined types, enumerations, array of type, or classes extending from type.
Enhanced to extend from predefined types [No other specialized class has this property].
</p>


<p><span class="ModelicaBaseClass">Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</span></p>
<address>
<a href="http://www.3ds.com/">Automatically generated</a> Thu Dec 19 17:19:45 2019.
</address>
</body>
</html>
