<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Modelica.Math.Vectors</title>
<meta name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="&quot;Library of functions operating on vectors&quot;">
<style type="text/css">
*       { font-size: 100%; font-family: Arial, sans-serif; }
.modelica, .modelica * { font-size: 90%; font-family: Courier, monospace; white-space: pre; } /* For the Modelica code (in exported html). */
h4      { font-size: 100%; font-weight: bold; color: green; } 
h3      { font-size: 110%; font-weight: bold; color: green; }
h2      { font-size: 130%; font-weight: bold; color: green; }
address { font-weight: normal; }
td      { padding: 2px; vertical-align: top; }
th      { padding: 2px; vertical-align: top; font-weight: bold; }
table   { border-collapse: collapse; }
table[class^="ModelicaTable"] td { border: 1px solid #808080; }
table[class^="ModelicaTable"] th { border: 1px solid #808080; }
pre, code {font-family: "Courier New", monospace;}
pre {white-space: pre; overflow-x : hidden;}
li.unchecked::marker { content: "\2610  "; font-size: 1.5em; }
li.checked::marker { content: "\2611  "; font-size: 1.5em; }
.ModelicaDescription {font-weight: bold;} /* For the description string of the class. */
.ModelicaBaseClass {} /* For the list of base-classes at the of the description. */
.ModelicaKeyword { color: blue; font-weight: normal; font-style: normal; } /* Keywords in Modelica. */
.ModelicaComment { color: #006400;  font-weight: normal; font-style: normal;} /* All three variants of comments in Modelica.  */
.ModelicaString { color: #006400;  font-weight: normal; font-style: normal;} /* String constants. */
.ModelicaClass { color: red; font-weight: normal; font-style: normal;} /* Formatting the names of referenced classes (for base-class and components). */
.ModelicaFunction { color: red; font-weight: normal; font-style: normal;} /* Formatting for called functions. */
.ModelicaTablePackageContent { } /* The table of contents for each package. */
.ModelicaTableCrossReference { } /* The optional cross-reference table. */
.ModelicaTableInputs {} /* The table of inputs for a function. */
.ModelicaTableOutputs {} /* The table of outputs for a function. */
.ModelicaTableParameters {} /* The table of parameters for a model/block. */
.ModelicaTableConnectors {} /* The table of connectors for a model/block. */
.ModelicaTableContents {} /* The table of contents for a connector. */
.ModelicaStartAttribute { font-weight: bold; } /* The formatting used for start-attribute in the table of parameters, to separate them from parameter values. */
.ModelicaParameterTab { background-color: #c0c0c0; font-weight: bold; } /* The tab-heading in the table of parameters */
.ModelicaParameterGroup { background-color: #e0e0e0; } /* The group-heading in the table of parameters */
</style>
</head>
<body>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE Vectors<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica.Math.Vectors"></a><a href="Modelica_Math.html#Modelica.Math"
>Modelica.Math</a>.Vectors</h2>
<p>
<span class="ModelicaDescription">Library of functions operating on vectors</span>
</p>
<h3>Information</h3>

<h4>Library content</h4>
<p>
This library provides functions operating on vectors:
</p>

<ul>
<li> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.toString"
>toString</a>(v)
     - returns the string representation of vector v.</li>

<li> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.isEqual"
>isEqual</a>(v1, v2)
     - returns true if vectors v1 and v2 have the same size and the same elements.</li>

<li> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.norm"
>norm</a>(v,p)
     - returns the p-norm of vector v.</li>

<li> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.length"
>length</a>(v)
     - returns the length of vector v (= norm(v,2), but inlined and therefore usable in
       symbolic manipulations)</li>

<li> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.normalize"
>normalize</a>(v)
     - returns vector in direction of v with length = 1 and prevents
       zero-division for zero vector.</li>

<li> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.reverse"
>reverse</a>(v)
     - reverses the vector elements of v.</li>

<li> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.sort"
>sort</a>(v)
     - sorts the elements of vector v in ascending or descending order.</li>

<li> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.find"
>find</a>(e, v)
     - returns the index of the first occurrence of scalar e in vector v.</li>

<li> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.interpolate"
>interpolate</a>(x, y, xi)
     - returns the interpolated value in (x,y) that corresponds to xi.</li>

<li> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.relNodePositions"
>relNodePositions</a>(nNodes)
     - returns a vector of relative node positions (0..1).</li>
</ul>

<h4>See also</h4>
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Matrices</a>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package"
>Modelica.Icons.Package</a> (Icon for standard packages).</span></p>
<h3>Package Content</h3>
<table summary="Package Content" class="ModelicaTablePackageContent">
<tr>
<th>Name</th>
<th>Description</th>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.toString" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.toString"
>toString</a>
</td>
<td>Convert a real vector in to a string representation</td>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.isEqual" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.isEqual"
>isEqual</a>
</td>
<td>Determine if two Real vectors are numerically identical</td>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.norm" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.norm"
>norm</a>
</td>
<td>Return the p-norm of a vector</td>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.length" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.length"
>length</a>
</td>
<td>Return length of a vector (better as norm(), if further symbolic processing is performed)</td>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.normalize" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.normalize"
>normalize</a>
</td>
<td>Return normalized vector such that length = 1 and prevent zero-division for zero vector</td>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.normalizeWithAssert" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.normalizeWithAssert"
>normalizeWithAssert</a>
</td>
<td>Return normalized vector such that length = 1 (trigger an assert for zero vector)</td>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.reverse" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.reverse"
>reverse</a>
</td>
<td>Reverse vector elements (e.g., v[1] becomes last element)</td>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.sort" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.sort"
>sort</a>
</td>
<td>Sort elements of vector in ascending or descending order</td>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.find" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.find"
>find</a>
</td>
<td>Find element in a vector</td>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.interpolate" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.interpolate"
>interpolate</a>
</td>
<td>Interpolate linearly in a vector</td>
</tr>
<tr>
<td><img src="Modelica.Math.isEqualS.png" alt="Modelica.Math.Vectors.relNodePositions" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.relNodePositions"
>relNodePositions</a>
</td>
<td>Return vector of relative node positions (0..1)</td>
</tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE toString<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.toString" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.toString"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.toString</h2>
<p>
<span class="ModelicaDescription">Convert a real vector in to a string representation</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>toString</strong>(v);
Vectors.<strong>toString</strong>(v,name="",significantDigits=6);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Vectors.<strong>toString</strong>(v)</code>" returns the string representation of vector <strong>v</strong>.
With the optional arguments "name" and "significantDigits" a name and the number of the digits are defined.
The default values of "name" and "significantDigits" are "" and 6 respectively. If name=="" (empty string) then the prefix "&lt;name&gt; =" is left out at the output-string.
</p>
<h4>Example</h4>
<blockquote><pre>
v = {2.12, -4.34, -2.56, -1.67};
<strong>toString</strong>(v);
                       // = "
                       //           2.12
                       //          -4.34
                       //          -2.56
                       //          -1.67"
<strong>toString</strong>(v,"vv",1);
                       // = "vv =
                       //           2
                       //          -4
                       //          -3
                       //          -2"
</pre></blockquote>

<h4>See also</h4>
<p>
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.toString"
>Matrices.toString</a>,
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>v[:]</td><td>Real vector</td></tr>
<tr><td>name</td><td>Independent variable name used for printing</td></tr>
<tr><td>significantDigits</td><td>Number of significant digits that are shown</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>s</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE isEqual<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.isEqual" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.isEqual"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.isEqual</h2>
<p>
<span class="ModelicaDescription">Determine if two Real vectors are numerically identical</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>isEqual</strong>(v1, v2);
Vectors.<strong>isEqual</strong>(v1, v2, eps=0);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Vectors.isEqual(v1, v2)</code>" returns <strong>true</strong>,
if the two Real vectors v1 and v2 have the same dimensions and
the same elements. Otherwise the function
returns <strong>false</strong>. Two elements e1 and e2 of the two vectors
are checked on equality by the test "abs(e1-e2) &le; eps", where "eps"
can be provided as third argument of the function. Default is "eps = 0".
</p>
<h4>Example</h4>
<blockquote><pre>
  Real v1[3] = {1, 2, 3};
  Real v2[4] = {1, 2, 3, 4};
  Real v3[3] = {1, 2, 3.0001};
  Boolean result;
<strong>algorithm</strong>
  result := Vectors.isEqual(v1,v2);     // = <strong>false</strong>
  result := Vectors.isEqual(v1,v3);     // = <strong>false</strong>
  result := Vectors.isEqual(v1,v1);     // = <strong>true</strong>
  result := Vectors.isEqual(v1,v3,0.1); // = <strong>true</strong>
</pre></blockquote>
<h4>See also</h4>
<p>
<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.find"
>Vectors.find</a>,
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.isEqual"
>Matrices.isEqual</a>,
<a href="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.isEqual"
>Strings.isEqual</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>v1[:]</td><td>First vector</td></tr>
<tr><td>v2[:]</td><td>Second vector (may have different length as v1)</td></tr>
<tr><td>eps</td><td>Two elements e1 and e2 of the two vectors are identical if abs(e1-e2) &lt;= eps</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>result</td><td>= true, if vectors have the same length and the same elements</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE norm<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.norm" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.norm"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.norm</h2>
<p>
<span class="ModelicaDescription">Return the p-norm of a vector</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>norm</strong>(v);
Vectors.<strong>norm</strong>(v,p=2);   // 1 &le; p &le; &#8734;
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Vectors.<strong>norm</strong>(v)</code>" returns the
<strong>Euclidean norm</strong> "<code>sqrt(v*v)</code>" of vector v.
With the optional
second argument "p", any other p-norm can be computed:
</p>
<center>
<img src="Resources/Images/Math/Vectors/vectorNorm.png" alt="function Vectors.norm">
</center>
<p>
Besides the Euclidean norm (p=2), also the 1-norm and the
infinity-norm are sometimes used:
</p>
<table border="1" cellspacing="0" cellpadding="2">
  <tr><td><strong>1-norm</strong></td>
      <td>= sum(abs(v))</td>
      <td><strong>norm</strong>(v,1)</td>
  </tr>
  <tr><td><strong>2-norm</strong></td>
      <td>= sqrt(v*v)</td>
      <td><strong>norm</strong>(v) or <strong>norm</strong>(v,2)</td>
  </tr>
  <tr><td><strong>infinity-norm</strong></td>
      <td>= max(abs(v))</td>
      <td><strong>norm</strong>(v,Modelica.Constants.<strong>inf</strong>)</td>
  </tr>
</table>
<p>
Note, for any vector norm the following inequality holds:
</p>
<blockquote><pre>
<strong>norm</strong>(v1+v2,p) &le; <strong>norm</strong>(v1,p) + <strong>norm</strong>(v2,p)
</pre></blockquote>
<h4>Example</h4>
<blockquote><pre>
v = {2, -4, -2, -1};
<strong>norm</strong>(v,1);    // = 9
<strong>norm</strong>(v,2);    // = 5
<strong>norm</strong>(v);      // = 5
<strong>norm</strong>(v,10.5); // = 4.00052597412635
<strong>norm</strong>(v,Modelica.Constants.inf);  // = 4
</pre></blockquote>
<h4>See also</h4>
<p>
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.norm"
>Matrices.norm</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>v[:]</td><td>Real vector</td></tr>
<tr><td>p</td><td>Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>result</td><td>p-norm of vector v</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE length<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.length" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.length"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.length</h2>
<p>
<span class="ModelicaDescription">Return length of a vector (better as norm(), if further symbolic processing is performed)</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>length</strong>(v);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Vectors.<strong>length</strong>(v)</code>" returns the
<strong>Euclidean length</strong> "<code>sqrt(v*v)</code>" of vector v.
The function call is equivalent to Vectors.norm(v). The advantage of
length(v) over norm(v) is that function length(..) is implemented
in one statement and therefore the function is usually automatically
inlined. Further symbolic processing is therefore possible, which is
not the case with function norm(..).
</p>
<h4>Example</h4>
<blockquote><pre>
v = {2, -4, -2, -1};
<strong>length</strong>(v);  // = 5
</pre></blockquote>
<h4>See also</h4>
<p>
<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.norm"
>Vectors.norm</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>v[:]</td><td>Real vector</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>result</td><td>Length of vector v</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE normalize<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.normalize" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.normalize"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.normalize</h2>
<p>
<span class="ModelicaDescription">Return normalized vector such that length = 1 and prevent zero-division for zero vector</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>normalize</strong>(v);
Vectors.<strong>normalize</strong>(v,eps=100*Modelica.Constants.eps);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Vectors.<strong>normalize</strong>(v)</code>" returns the
<strong>unit vector</strong> "<code>v/length(v)</code>" of vector v.
If length(v) is close to zero (more precisely, if length(v) &lt; eps),
v/eps is returned in order to avoid
a division by zero. For many applications this is useful, because
often the unit vector <strong>e</strong> = <strong>v</strong>/length(<strong>v</strong>) is used to compute
a vector x*<strong>e</strong>, where the scalar x is in the order of length(<strong>v</strong>),
i.e., x*<strong>e</strong> is small, when length(<strong>v</strong>) is small and then
it is fine to replace <strong>e</strong> by <strong>v</strong> to avoid a division by zero.
</p>
<p>
Since the function has the "Inline" annotation, it
is usually inlined and symbolic processing is applied.
</p>
<h4>Example</h4>
<blockquote><pre>
<strong>normalize</strong>({1,2,3});  // = {0.267, 0.534, 0.802}
<strong>normalize</strong>({0,0,0});  // = {0,0,0}
</pre></blockquote>
<h4>See also</h4>
<p>
<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.length"
>Vectors.length</a>,
<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.normalize"
>Vectors.normalizeWithAssert</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>v[:]</td><td>Real vector</td></tr>
<tr><td>eps</td><td>if |v| &lt; eps then result = v/eps</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>result[size(v, 1)]</td><td>Input vector v normalized to length=1 [1]</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE normalizeWithAssert<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.normalizeWithAssert" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.normalizeWithAssert"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.normalizeWithAssert</h2>
<p>
<span class="ModelicaDescription">Return normalized vector such that length = 1 (trigger an assert for zero vector)</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>normalizeWithAssert</strong>(v);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Vectors.<strong>normalizeWithAssert</strong>(v)</code>" returns the
<strong>unit vector</strong> "<code>v/sqrt(v*v)</code>" of vector v.
If vector v is a zero vector, an assert is triggered.
</p>
<p>
Since the function has the "Inline" annotation, it
is usually inlined and symbolic processing is applied.
</p>
<h4>Example</h4>
<blockquote><pre>
<strong>normalizeWithAssert</strong>({1,2,3});  // = {0.267, 0.534, 0.802}
<strong>normalizeWithAssert</strong>({0,0,0});  // error (an assert is triggered)
</pre></blockquote>
<h4>See also</h4>
<p>
<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.length"
>Vectors.length</a>,
<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.normalize"
>Vectors.normalize</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>v[:]</td><td>Real vector</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>result[size(v, 1)]</td><td>Input vector v normalized to length=1</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE reverse<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.reverse" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.reverse"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.reverse</h2>
<p>
<span class="ModelicaDescription">Reverse vector elements (e.g., v[1] becomes last element)</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>reverse</strong>(v);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Vectors.<strong>reverse</strong>(v)</code>" returns the
vector elements in reverse order.
</p>
<h4>Example</h4>
<blockquote><pre>
<strong>reverse</strong>({1,2,3,4});  // = {4,3,2,1}
</pre></blockquote>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>v[:]</td><td>Real vector</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>result[size(v, 1)]</td><td>Elements of vector v in reversed order</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE sort<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.sort" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.sort"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.sort</h2>
<p>
<span class="ModelicaDescription">Sort elements of vector in ascending or descending order</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
           sorted_v = Vectors.<strong>sort</strong>(v);
(sorted_v, indices) = Vectors.<strong>sort</strong>(v, ascending=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>sort</strong>(..) sorts a Real vector v
in ascending order and returns the result in sorted_v.
If the optional argument "ascending" is <strong>false</strong>, the vector
is sorted in descending order. In the optional second
output argument the indices of the sorted vector with respect
to the original vector are given, such that sorted_v = v[indices].
</p>
<h4>Example</h4>
<blockquote><pre>
(v2, i2) := Vectors.sort({-1, 8, 3, 6, 2});
     -> v2 = {-1, 2, 3, 6, 8}
        i2 = {1, 5, 3, 4, 2}
</pre></blockquote>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>v[:]</td><td>Real vector to be sorted</td></tr>
<tr><td>ascending</td><td>= true, if ascending order, otherwise descending order</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>sorted_v[size(v, 1)]</td><td>Sorted vector</td></tr>
<tr><td>indices[size(v, 1)]</td><td>sorted_v = v[indices]</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE find<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.find" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.find"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.find</h2>
<p>
<span class="ModelicaDescription">Find element in a vector</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>find</strong>(e, v);
Vectors.<strong>find</strong>(e, v, eps=0);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Vectors.find(e, v)</code>" returns the index of the first occurrence of input e in vector <strong>v</strong>.
The test of equality is performed by "abs(e-v[i]) &le; eps", where "eps"
can be provided as third argument of the function. Default is "eps = 0".
</p>
<h4>Example</h4>
<blockquote><pre>
  Real v[3] = {1, 2, 3};
  Real e1 = 2;
  Real e2 = 3.01;
  Boolean result;
<strong>algorithm</strong>
  result := Vectors.find(e1,v);          // = <strong>2</strong>
  result := Vectors.find(e2,v);          // = <strong>0</strong>
  result := Vectors.find(e2,v,eps=0.1);  // = <strong>3</strong>
</pre></blockquote>
<h4>See also</h4>
<p>
<a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.isEqual"
>Vectors.isEqual</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>e</td><td>Search for e</td></tr>
<tr><td>v[:]</td><td>Real vector</td></tr>
<tr><td>eps</td><td>Element e is equal to a element v[i] of vector v if abs(e-v[i]) &lt;= eps</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>result</td><td>v[result] = e (first occurrence of e); result=0, if not found</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE interpolate<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.interpolate" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.interpolate"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.interpolate</h2>
<p>
<span class="ModelicaDescription">Interpolate linearly in a vector</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
// Real    x[:], y[:], xi, yi;
// Integer iLast, iNew;
        yi = Vectors.<strong>interpolate</strong>(x,y,xi);
(yi, iNew) = Vectors.<strong>interpolate</strong>(x,y,xi,iLast=1);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Vectors.interpolate(x,y,xi)</code>" interpolates
<strong>linearly</strong> in vectors
(x,y) and returns the value yi that corresponds to xi. Vector x[:] must consist
of monotonically increasing values. If xi &lt; x[1] or &gt; x[end], then
extrapolation takes places through the first or last two x[:] values, respectively.
If the x and y vectors have length 1, then always y[1] is returned.
The search for the interval x[iNew] &le; xi &lt; x[iNew+1] starts at the optional
input argument "iLast". The index "iNew" is returned as output argument.
The usage of "iLast" and "iNew" is useful to increase the efficiency of the call,
if many interpolations take place.
If x has two or more identical values then interpolation utilizes the x-value
with the largest index.
</p>

<h4>Example</h4>

<blockquote><pre>
  Real x1[:] = { 0,  2,  4,  6,  8, 10};
  Real x2[:] = { 1,  2,  3,  3,  4,  5};
  Real y[:]  = {10, 20, 30, 40, 50, 60};
<strong>algorithm</strong>
  (yi, iNew) := Vectors.interpolate(x1,y,5);  // yi = 35, iNew=3
  (yi, iNew) := Vectors.interpolate(x2,y,4);  // yi = 50, iNew=5
  (yi, iNew) := Vectors.interpolate(x2,y,3);  // yi = 40, iNew=4
</pre></blockquote>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[:]</td><td>Abscissa table vector (strict monotonically increasing values required)</td></tr>
<tr><td>y[size(x, 1)]</td><td>Ordinate table vector</td></tr>
<tr><td>xi</td><td>Desired abscissa value</td></tr>
<tr><td>iLast</td><td>Index used in last search</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>yi</td><td>Ordinate value corresponding to xi</td></tr>
<tr><td>iNew</td><td>xi is in the interval x[iNew] &lt;= xi &lt; x[iNew+1]</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE relNodePositions<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.isEqualI.png" alt="Modelica.Math.Vectors.relNodePositions" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Vectors.relNodePositions"></a><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</a>.relNodePositions</h2>
<p>
<span class="ModelicaDescription">Return vector of relative node positions (0..1)</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>relNodePositions</strong>(nNodes);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>relNodePositions(nNodes)</code>" returns a vector
with the relative positions of the nodes of a discretized pipe with nNodes nodes (including the node
at the left and at the right side of the pipe), see next figure:
</p>

<div>
<img src="Resources/Images/Math/Vectors/relNodePositions.png">
</div>

<h4>Example</h4>

<blockquote><pre>
  Real xsi[7];
<strong>algorithm</strong>
  xsi = relNodePositions(7);  // xsi = {0, 0.1, 0.3, 0.5, 0.7, 0.9, 1}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href="Modelica_Mechanics_MultiBody_Visualizers.html#Modelica.Mechanics.MultiBody.Visualizers.PipeWithScalarField"
>MultiBody.Visualizers.PipeWithScalarField</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>nNodes</td><td>Number of nodes (including node at left and right position)</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>xsi[nNodes]</td><td>Relative node positions</td></tr>
</table>
<address>
<a href="http://www.3ds.com/">Automatically generated</a> Mon Feb 23 14:10:51 2026.
</address>
</body>
</html>
