<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Modelica.Math.Matrices.LAPACK</title>
<meta name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="&quot;Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)&quot;">
<style type="text/css">
*       { font-size: 100%; font-family: Arial, sans-serif; }
.modelica, .modelica * { font-size: 90%; font-family: Courier, monospace; white-space: pre; } /* For the Modelica code (in exported html). */
h4      { font-size: 100%; font-weight: bold; color: green; } 
h3      { font-size: 110%; font-weight: bold; color: green; }
h2      { font-size: 130%; font-weight: bold; color: green; }
address { font-weight: normal; }
td      { padding: 2px; border: 1px solid #808080; vertical-align: top; }
th      { padding: 2px; border: 1px solid #808080; vertical-align: top; font-weight: bold; }
table   { border: 1px solid #808080; border-collapse: collapse; }
.ModelicaDescription {font-weight: bold;} /* For the description string of the class. */
.ModelicaBaseClass {} /* For the list of base-classes at the of the description. */
.ModelicaKeyword { color: blue; font-weight: normal; font-style: normal; } /* Keywords in Modelica. */
.ModelicaComment { color: #006400;  font-weight: normal; font-style: normal;} /* All three variants of comments in Modelica.  */
.ModelicaString { color: #006400;  font-weight: normal; font-style: normal;} /* String constants. */
.ModelicaClass { color: red; font-weight: normal; font-style: normal;} /* Formatting the names of referenced classes (for base-class and components). */
.ModelicaFunction { color: red; font-weight: normal; font-style: normal;} /* Formatting for called functions. */
.ModelicaTablePackageContent { } /* The table of contents for each package. */
.ModelicaTableCrossReference { } /* The optional cross-reference table. */
.ModelicaTableInputs {} /* The table of inputs for a function. */
.ModelicaTableOutputs {} /* The table of outputs for a function. */
.ModelicaTableParameters {} /* The table of parameters for a model/block. */
.ModelicaTableConnectors {} /* The table of connectors for a model/block. */
.ModelicaTableContents {} /* The table of contents for a connector. */
.ModelicaStartAttribute { font-weight: bold; } /* The formatting used for start-attribute in the table of parameters, to separate them from parameter values. */
.ModelicaParameterTab { background-color: #c0c0c0; font-weight: bold; } /* The tab-heading in the table of parameters */
.ModelicaParameterGroup { background-color: #e0e0e0; } /* The group-heading in the table of parameters */
</style>
</head>
<body>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE LAPACK<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica.Math.Matrices.LAPACK"></a><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</a>.LAPACK</h2>
<p>
<span class="ModelicaDescription">Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)</span><br>
</p>
<h3>Information</h3>

<p>
This package contains external Modelica functions as interface to the
LAPACK library
(<a href="http://www.netlib.org/lapack">http://www.netlib.org/lapack</a>)
that provides FORTRAN subroutines to solve linear algebra
tasks. Usually, these functions are not directly called, but only via
the much more convenient interface of
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</a>.
The documentation of the LAPACK functions is a copy of the original
FORTRAN code. The details of LAPACK are described in:
</p>

<dl>
<dt>Anderson E., Bai Z., Bischof C., Blackford S., Demmel J., Dongarra J.,
    Du Croz J., Greenbaum A., Hammarling S., McKenney A., and Sorensen D.:</dt>
<dd> <a href="http://www.netlib.org/lapack/lug/lapack_lug.html">Lapack Users' Guide</a>.
     Third Edition, SIAM, 1999.</dd>
</dl>

<p>
See also <a href="http://en.wikipedia.org/wiki/Lapack">http://en.wikipedia.org/wiki/Lapack</a>.
</p>

<p>
This package contains a direct interface to the LAPACK subroutines
</p>


<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package"
>Modelica.Icons.Package</a> (Icon for standard packages).</span></p>
<h3>Package Content</h3>
<table summary="Package Content" class="ModelicaTablePackageContent">
<tr>
<th>Name</th>
<th>Description</th>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgeev" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgeev"
>dgeev</a>
</td>
<td>Compute eigenvalues and (right) eigenvectors for real nonsymmetric matrix A</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgeev_eigenValues" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgeev_eigenValues"
>dgeev_eigenValues</a>
</td>
<td>Compute eigenvalues for real nonsymmetric matrix A</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgegv" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgegv"
>dgegv</a>
</td>
<td>Compute generalized eigenvalues for a (A,B) system</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgelsx" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgelsx"
>dgelsx</a>
</td>
<td>Computes the minimum-norm solution to a real linear least squares problem with rank deficient A</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgelsx_vec" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgelsx_vec"
>dgelsx_vec</a>
</td>
<td>Computes the minimum-norm solution to a real linear least squares problem with rank deficient A</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgels_vec" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgels_vec"
>dgels_vec</a>
</td>
<td>Solves overdetermined or underdetermined real linear equations A*x=b with a b vector</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgesv" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgesv"
>dgesv</a>
</td>
<td>Solve real system of linear equations A*X=B with a B matrix</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgesv_vec" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgesv_vec"
>dgesv_vec</a>
</td>
<td>Solve real system of linear equations A*x=b with a b vector</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgglse_vec" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgglse_vec"
>dgglse_vec</a>
</td>
<td>Solve a linear equality constrained least squares problem</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgtsv" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgtsv"
>dgtsv</a>
</td>
<td>Solve real system of linear equations A*X=B with B matrix and tridiagonal A</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgtsv_vec" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgtsv_vec"
>dgtsv_vec</a>
</td>
<td>Solve real system of linear equations A*x=b with b vector and tridiagonal A</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgbsv" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgbsv"
>dgbsv</a>
</td>
<td>Solve real system of linear equations A*X=B with a B matrix</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgbsv_vec" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgbsv_vec"
>dgbsv_vec</a>
</td>
<td>Solve real system of linear equations A*x=b with a b vector</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgesvd" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgesvd"
>dgesvd</a>
</td>
<td>Determine singular value decomposition</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgesvd_sigma" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgesvd_sigma"
>dgesvd_sigma</a>
</td>
<td>Determine singular values</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgetrf" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgetrf"
>dgetrf</a>
</td>
<td>Compute LU factorization of square or rectangular matrix A (A = P*L*U)</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgetrs" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgetrs"
>dgetrs</a>
</td>
<td>Solves a system of linear equations with the LU decomposition from dgetrf(..)</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgetrs_vec" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgetrs_vec"
>dgetrs_vec</a>
</td>
<td>Solves a system of linear equations with the LU decomposition from dgetrf(..)</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgetri" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgetri"
>dgetri</a>
</td>
<td>Computes the inverse of a matrix using the LU factorization from dgetrf(..)</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgeqpf" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgeqpf"
>dgeqpf</a>
</td>
<td>Compute QR factorization of square or rectangular matrix A with column pivoting (A(:,p) = Q*R)</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dorgqr" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dorgqr"
>dorgqr</a>
</td>
<td>Generates a Real orthogonal matrix Q which is defined as the product of elementary reflectors as returned from dgeqpf</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgees" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgees"
>dgees</a>
</td>
<td>Computes real Schur form T of real nonsymmetric matrix A, and, optionally, the matrix of Schur vectors Z as well as the eigenvalues</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dtrsen" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dtrsen"
>dtrsen</a>
</td>
<td>Reorder the real Schur factorization of a real matrix</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgesvx" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgesvx"
>dgesvx</a>
</td>
<td>Solve real system of linear equations op(A)*X=B, op(A) is A or A&#39; according to the Boolean input transposed</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dtrsyl" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dtrsyl"
>dtrsyl</a>
</td>
<td>Solve the real Sylvester matrix equation op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dhseqr" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dhseqr"
>dhseqr</a>
</td>
<td>Compute eigenvalues of a matrix H using lapack routine DHSEQR for Hessenberg form matrix</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dlange" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dlange"
>dlange</a>
</td>
<td>Norm of a matrix</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgecon" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgecon"
>dgecon</a>
</td>
<td>Estimates the reciprocal of the condition number of a general real matrix A</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgehrd" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgehrd"
>dgehrd</a>
</td>
<td>reduces a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgeqrf" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgeqrf"
>dgeqrf</a>
</td>
<td>computes a QR factorization without pivoting</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgeevx" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgeevx"
>dgeevx</a>
</td>
<td>Compute the eigenvalues and the (real) left and right eigenvectors of matrix A, using lapack routine dgeevx</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dgesdd" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgesdd"
>dgesdd</a>
</td>
<td>Determine singular value decomposition</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dggev" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dggev"
>dggev</a>
</td>
<td>Compute generalized eigenvalues, as well as the left and right eigenvectors for a (A,B) system</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dggevx" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dggevx"
>dggevx</a>
</td>
<td>Compute generalized eigenvalues for a (A,B) system, using lapack routine dggevx</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dhgeqz" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dhgeqz"
>dhgeqz</a>
</td>
<td>Compute generalized eigenvalues for a (A,B) system</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dormhr" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dormhr"
>dormhr</a>
</td>
<td>overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix as returned by dgehrd</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dormqr" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dormqr"
>dormqr</a>
</td>
<td>overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix of a QR factorization as returned by dgeqrf</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dtrevc" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dtrevc"
>dtrevc</a>
</td>
<td>Compute the right and/or left eigenvectors of a real upper quasi-triangular matrix T</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dpotrf" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dpotrf"
>dpotrf</a>
</td>
<td>Computes the Cholesky factorization of a real symmetric positive definite matrix A</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dtrsm" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dtrsm"
>dtrsm</a>
</td>
<td>Solve one of the matrix equations op( A )*X = alpha*B, or X*op( A ) = alpha*B, where A is triangular matrix. BLAS routine</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.LAPACK.dorghr" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dorghr"
>dorghr</a>
</td>
<td>Generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD</td>
</tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgeev<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgeev" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgeev"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgeev</h2>
<p>
<span class="ModelicaDescription">Compute eigenvalues and (right) eigenvectors for real nonsymmetric matrix A</span>
</p>
<h3>Information</h3>
<pre>This function is not a full interface to the LAPACK function DGEEV,
but calls it in such a way that only eigenvalues and right eigenvectors
are computed.

Lapack documentation
    Purpose
    =======

    DGEEV computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues and, optionally, the left and/or right eigenvectors.

    The right eigenvector v(j) of A satisfies
                     A * v(j) = lambda(j) * v(j)
    where lambda(j) is its eigenvalue.
    The left eigenvector u(j) of A satisfies
                  u(j)**H * A = lambda(j) * u(j)**H
    where u(j)**H denotes the conjugate transpose of u(j).

    The computed eigenvectors are normalized to have Euclidean norm
    equal to 1 and largest component real.

    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = &#39;N&#39;: left eigenvectors of A are not computed;
            = &#39;V&#39;: left eigenvectors of A are computed.

    JOBVR   (input) CHARACTER*1
            = &#39;N&#39;: right eigenvectors of A are not computed;
            = &#39;V&#39;: right eigenvectors of A are computed.

    N       (input) INTEGER
            The order of the matrix A. N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    WR      (output) DOUBLE PRECISION array, dimension (N)
    WI      (output) DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.

    VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = &#39;N&#39;, VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).

    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL &gt;= 1; if
            JOBVL = &#39;V&#39;, LDVL &gt;= N.

    VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = &#39;N&#39;, VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).

    LDVR    (input) INTEGER
            The leading dimension of the array VR.  LDVR &gt;= 1; if
            JOBVR = &#39;V&#39;, LDVR &gt;= N.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK &gt;= max(1,3*N), and
            if JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;, LWORK &gt;= 4*N.  For good
            performance, LWORK must generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>eigenReal[size(A, 1)]</td><td>Real part of eigen values</td></tr>
<tr><td>eigenImag[size(A, 1)]</td><td>Imaginary part of eigen values</td></tr>
<tr><td>eigenVectors[size(A, 1), size(A, 1)]</td><td>Right eigen vectors</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgeev_eigenValues<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgeev_eigenValues" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgeev_eigenValues"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgeev_eigenValues</h2>
<p>
<span class="ModelicaDescription">Compute eigenvalues for real nonsymmetric matrix A</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGEEV computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues and, optionally, the left and/or right eigenvectors.

    The right eigenvector v(j) of A satisfies
                     A * v(j) = lambda(j) * v(j)
    where lambda(j) is its eigenvalue.
    The left eigenvector u(j) of A satisfies
                  u(j)**H * A = lambda(j) * u(j)**H
    where u(j)**H denotes the conjugate transpose of u(j).

    The computed eigenvectors are normalized to have Euclidean norm
    equal to 1 and largest component real.

    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = &#39;N&#39;: left eigenvectors of A are not computed;
            = &#39;V&#39;: left eigenvectors of A are computed.

    JOBVR   (input) CHARACTER*1
            = &#39;N&#39;: right eigenvectors of A are not computed;
            = &#39;V&#39;: right eigenvectors of A are computed.

    N       (input) INTEGER
            The order of the matrix A. N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    WR      (output) DOUBLE PRECISION array, dimension (N)
    WI      (output) DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.

    VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = &#39;N&#39;, VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).

    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL &gt;= 1; if
            JOBVL = &#39;V&#39;, LDVL &gt;= N.

    VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = &#39;N&#39;, VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).

    LDVR    (input) INTEGER
            The leading dimension of the array VR.  LDVR &gt;= 1; if
            JOBVR = &#39;V&#39;, LDVR &gt;= N.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK &gt;= max(1,3*N), and
            if JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;, LWORK &gt;= 4*N.  For good
            performance, LWORK must generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>EigenReal[size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>EigenImag[size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgegv<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgegv" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgegv"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgegv</h2>
<p>
<span class="ModelicaDescription">Compute generalized eigenvalues for a (A,B) system</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    This routine is deprecated and has been replaced by routine DGGEV.

    DGEGV computes the eigenvalues and, optionally, the left and/or right
    eigenvectors of a real matrix pair (A,B).
    Given two square matrices A and B,
    the generalized nonsymmetric eigenvalue problem (GNEP) is to find the
    eigenvalues lambda and corresponding (non-zero) eigenvectors x such
    that

       A*x = lambda*B*x.

    An alternate form is to find the eigenvalues mu and corresponding
    eigenvectors y such that

       mu*A*y = B*y.

    These two forms are equivalent with mu = 1/lambda and x = y if
    neither lambda nor mu is zero.  In order to deal with the case that
    lambda or mu is zero or small, two values alpha and beta are returned
    for each eigenvalue, such that lambda = alpha/beta and
    mu = beta/alpha.

    The vectors x and y in the above equations are right eigenvectors of
    the matrix pair (A,B).  Vectors u and v satisfying

       u**H*A = lambda*u**H*B  or  mu*v**H*A = v**H*B

    are left eigenvectors of (A,B).

    Note: this routine performs &quot;full balancing&quot; on A and B -- see
    &quot;Further Details&quot;, below.

    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = &#39;N&#39;:  do not compute the left generalized eigenvectors;
            = &#39;V&#39;:  compute the left generalized eigenvectors (returned
                    in VL).

    JOBVR   (input) CHARACTER*1
            = &#39;N&#39;:  do not compute the right generalized eigenvectors;
            = &#39;V&#39;:  compute the right generalized eigenvectors (returned
                    in VR).

    N       (input) INTEGER
            The order of the matrices A, B, VL, and VR.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the matrix A.
            If JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;, then on exit A
            contains the real Schur form of A from the generalized Schur
            factorization of the pair (A,B) after balancing.
            If no eigenvectors were computed, then only the diagonal
            blocks from the Schur form will be correct.  See DGGHRD and
            DHGEQZ for details.

    LDA     (input) INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the matrix B.
            If JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;, then on exit B contains the
            upper triangular matrix obtained from B in the generalized
            Schur factorization of the pair (A,B) after balancing.
            If no eigenvectors were computed, then only those elements of
            B corresponding to the diagonal blocks from the Schur form of
            A will be correct.  See DGGHRD and DHGEQZ for details.

    LDB     (input) INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).

    ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
            The real parts of each scalar alpha defining an eigenvalue of
            GNEP.

    ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
            The imaginary parts of each scalar alpha defining an
            eigenvalue of GNEP.  If ALPHAI(j) is zero, then the j-th
            eigenvalue is real; if positive, then the j-th and
            (j+1)-st eigenvalues are a complex conjugate pair, with
            ALPHAI(j+1) = -ALPHAI(j).

    BETA    (output) DOUBLE PRECISION array, dimension (N)
            The scalars beta that define the eigenvalues of GNEP.

            Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
            beta = BETA(j) represent the j-th eigenvalue of the matrix
            pair (A,B), in one of the forms lambda = alpha/beta or
            mu = beta/alpha.  Since either lambda or mu may overflow,
            they should not, in general, be computed.

    VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored
            in the columns of VL, in the same order as their eigenvalues.
            If the j-th eigenvalue is real, then u(j) = VL(:,j).
            If the j-th and (j+1)-st eigenvalues form a complex conjugate
            pair, then
               u(j) = VL(:,j) + i*VL(:,j+1)
            and
              u(j+1) = VL(:,j) - i*VL(:,j+1).

            Each eigenvector is scaled so that its largest component has
            abs(real part) + abs(imag. part) = 1, except for eigenvectors
            corresponding to an eigenvalue with alpha = beta = 0, which
            are set to zero.
            Not referenced if JOBVL = &#39;N&#39;.

    LDVL    (input) INTEGER
            The leading dimension of the matrix VL. LDVL &gt;= 1, and
            if JOBVL = &#39;V&#39;, LDVL &gt;= N.

    VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = &#39;V&#39;, the right eigenvectors x(j) are stored
            in the columns of VR, in the same order as their eigenvalues.
            If the j-th eigenvalue is real, then x(j) = VR(:,j).
            If the j-th and (j+1)-st eigenvalues form a complex conjugate
            pair, then
              x(j) = VR(:,j) + i*VR(:,j+1)
            and
              x(j+1) = VR(:,j) - i*VR(:,j+1).

            Each eigenvector is scaled so that its largest component has
            abs(real part) + abs(imag. part) = 1, except for eigenvalues
            corresponding to an eigenvalue with alpha = beta = 0, which
            are set to zero.
            Not referenced if JOBVR = &#39;N&#39;.

    LDVR    (input) INTEGER
            The leading dimension of the matrix VR. LDVR &gt;= 1, and
            if JOBVR = &#39;V&#39;, LDVR &gt;= N.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK &gt;= max(1,8*N).
            For good performance, LWORK must generally be larger.
            To compute the optimal value of LWORK, call ILAENV to get
            blocksizes (for DGEQRF, DORMQR, and DORGQR.)  Then compute:
            NB  -- MAX of the blocksizes for DGEQRF, DORMQR, and DORGQR;
            The optimal LWORK is:
                2*N + MAX( 6*N, N*(NB+1) ).

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1,...,N:
                  The QZ iteration failed.  No eigenvectors have been
                  calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                  should be correct for j=INFO+1,...,N.
            &gt; N:  errors that usually indicate LAPACK problems:
                  =N+1: error return from DGGBAL
                  =N+2: error return from DGEQRF
                  =N+3: error return from DORMQR
                  =N+4: error return from DORGQR
                  =N+5: error return from DGGHRD
                  =N+6: error return from DHGEQZ (other than failed
                                                  iteration)
                  =N+7: error return from DTGEVC
                  =N+8: error return from DGGBAK (computing VL)
                  =N+9: error return from DGGBAK (computing VR)
                  =N+10: error return from DLASCL (various calls)

    Further Details
    ===============

    Balancing
    ---------

    This driver calls DGGBAL to both permute and scale rows and columns
    of A and B.  The permutations PL and PR are chosen so that PL*A*PR
    and PL*B*R will be upper triangular except for the diagonal blocks
    A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
    possible.  The diagonal scaling matrices DL and DR are chosen so
    that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
    one (except for the elements that start out zero.)

    After the eigenvalues and eigenvectors of the balanced matrices
    have been computed, DGGBAK transforms the eigenvectors back to what
    they would have been (in perfect arithmetic) if they had not been
    balanced.

    Contents of A and B on Exit
    -------- -- - --- - -- ----

    If any eigenvectors are computed (either JOBVL=&#39;V&#39; or JOBVR=&#39;V&#39; or
    both), then on exit the arrays A and B will contain the real Schur
    form[*] of the &quot;balanced&quot; versions of A and B.  If no eigenvectors
    are computed, then only the diagonal blocks will be correct.

    [*] See DHGEQZ, DGEGS, or read the book &quot;Matrix Computations&quot;,
        by Golub &amp; van Loan, pub. by Johns Hopkins U. Press.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha</td></tr>
<tr><td>beta[size(A, 1)]</td><td>Denominator of eigenvalue</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgelsx<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgelsx" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgelsx"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgelsx</h2>
<p>
<span class="ModelicaDescription">Computes the minimum-norm solution to a real linear least squares problem with rank deficient A</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    This routine is deprecated and has been replaced by routine DGELSY.

    DGELSX computes the minimum-norm solution to a real linear least
    squares problem:
        minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
        A * P = Q * [ R11 R12 ]
                    [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
       A * P = Q * [ T11 0 ] * Z
                   [  0  0 ]
    The minimum-norm solution is then
       X = P * Z&#39; [ inv(T11)*Q1&#39;*B ]
                  [        0       ]
    where Q1 consists of the first RANK columns of Q.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of matrices B and X. NRHS &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been overwritten by details of its
            complete orthogonal factorization.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, the N-by-NRHS solution matrix X.
            If m &gt;= n and RANK = n, the residual sum-of-squares for
            the solution in the i-th column is given by the sum of
            squares of elements N+1:M in that column.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB &gt;= max(1,M,N).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is an
            initial column, otherwise it is a free column.  Before
            the QR factorization of A, all initial columns are
            permuted to the leading positions; only the remaining
            free columns are moved as a result of column pivoting
            during the factorization.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.

    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number &lt; 1/RCOND.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the order of the submatrix
            R11.  This is the same as the order of the submatrix T11
            in the complete orthogonal factorization of A.

    WORK    (workspace) DOUBLE PRECISION array, dimension
                        (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), :]</td><td>&nbsp;</td></tr>
<tr><td>rcond</td><td>Reciprocal condition number to estimate rank</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[max(size(A, 1), size(A, 2)), size(B, 2)]</td><td>Solution is in first size(A,2) rows</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>rank</td><td>Effective rank of A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgelsx_vec<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgelsx_vec" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgelsx_vec"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgelsx_vec</h2>
<p>
<span class="ModelicaDescription">Computes the minimum-norm solution to a real linear least squares problem with rank deficient A</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    This routine is deprecated and has been replaced by routine DGELSY.

    DGELSX computes the minimum-norm solution to a real linear least
    squares problem:
        minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
        A * P = Q * [ R11 R12 ]
                    [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
       A * P = Q * [ T11 0 ] * Z
                   [  0  0 ]
    The minimum-norm solution is then
       X = P * Z&#39; [ inv(T11)*Q1&#39;*B ]
                  [        0       ]
    where Q1 consists of the first RANK columns of Q.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of matrices B and X. NRHS &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been overwritten by details of its
            complete orthogonal factorization.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, the N-by-NRHS solution matrix X.
            If m &gt;= n and RANK = n, the residual sum-of-squares for
            the solution in the i-th column is given by the sum of
            squares of elements N+1:M in that column.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB &gt;= max(1,M,N).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is an
            initial column, otherwise it is a free column.  Before
            the QR factorization of A, all initial columns are
            permuted to the leading positions; only the remaining
            free columns are moved as a result of column pivoting
            during the factorization.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.

    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number &lt; 1/RCOND.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the order of the submatrix
            R11.  This is the same as the order of the submatrix T11
            in the complete orthogonal factorization of A.

    WORK    (workspace) DOUBLE PRECISION array, dimension
                        (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>b[size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>rcond</td><td>Reciprocal condition number to estimate rank</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[max(size(A, 1), size(A, 2))]</td><td>solution is in first size(A,2) rows</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>rank</td><td>Effective rank of A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgels_vec<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgels_vec" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgels_vec"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgels_vec</h2>
<p>
<span class="ModelicaDescription">Solves overdetermined or underdetermined real linear equations A*x=b with a b vector</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGELS solves overdetermined or underdetermined real linear systems
    involving an M-by-N matrix A, or its transpose, using a QR or LQ
    factorization of A.  It is assumed that A has full rank.

    The following options are provided:

    1. If TRANS = &#39;N&#39; and m &gt;= n:  find the least squares solution of
       an overdetermined system, i.e., solve the least squares problem
                    minimize || B - A*X ||.

    2. If TRANS = &#39;N&#39; and m &lt; n:  find the minimum norm solution of
       an underdetermined system A * X = B.

    3. If TRANS = &#39;T&#39; and m &gt;= n:  find the minimum norm solution of
       an undetermined system A**T * X = B.

    4. If TRANS = &#39;T&#39; and m &lt; n:  find the least squares solution of
       an overdetermined system, i.e., solve the least squares problem
                    minimize || B - A**T * X ||.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    Arguments
    =========

    TRANS   (input) CHARACTER*1
            = &#39;N&#39;: the linear system involves A;
            = &#39;T&#39;: the linear system involves A**T.

    M       (input) INTEGER
            The number of rows of the matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of the matrices B and X. NRHS &gt;=0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
              if M &gt;= N, A is overwritten by details of its QR
                         factorization as returned by DGEQRF;
              if M &lt;  N, A is overwritten by details of its LQ
                         factorization as returned by DGELQF.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the matrix B of right hand side vectors, stored
            columnwise; B is M-by-NRHS if TRANS = &#39;N&#39;, or N-by-NRHS
            if TRANS = &#39;T&#39;.
            On exit, if INFO = 0, B is overwritten by the solution
            vectors, stored columnwise:
            if TRANS = &#39;N&#39; and m &gt;= n, rows 1 to n of B contain the least
            squares solution vectors; the residual sum of squares for the
            solution in each column is given by the sum of squares of
            elements N+1 to M in that column;
            if TRANS = &#39;N&#39; and m &lt; n, rows 1 to N of B contain the
            minimum norm solution vectors;
            if TRANS = &#39;T&#39; and m &gt;= n, rows 1 to M of B contain the
            minimum norm solution vectors;
            if TRANS = &#39;T&#39; and m &lt; n, rows 1 to M of B contain the
            least squares solution vectors; the residual sum of squares
            for the solution in each column is given by the sum of
            squares of elements M+1 to N in that column.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB &gt;= MAX(1,M,N).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            LWORK &gt;= max( 1, MN + max( MN, NRHS ) ).
            For optimal performance,
            LWORK &gt;= max( 1, MN + max( MN, NRHS )*NB ).
            where MN = min(M,N) and NB is the optimum block size.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO =  i, the i-th diagonal element of the
                  triangular factor of A is zero, so that A does not have
                  full rank; the least squares solution could not be
                  computed.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>b[size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[max(size(A, 1), size(A, 2))]</td><td>solution is in first size(A,2) rows</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgesv<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgesv" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgesv"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgesv</h2>
<p>
<span class="ModelicaDescription">Solve real system of linear equations A*X=B with a B matrix</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGESV computes the solution to a real system of linear equations
       A * X = B,
    where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

    The LU decomposition with partial pivoting and row interchanges is
    used to factor A as
       A = P * L * U,
    where P is a permutation matrix, L is unit lower triangular, and U is
    upper triangular.  The factored form of A is then used to solve the
    system of equations A * X = B.

    Arguments
    =========

    N       (input) INTEGER
            The number of linear equations, i.e., the order of the
            matrix A.  N &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N coefficient matrix A.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    IPIV    (output) INTEGER array, dimension (N)
            The pivot indices that define the permutation matrix P;
            row i of the matrix was interchanged with row IPIV(i).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the N-by-NRHS matrix of right hand side matrix B.
            On exit, if INFO = 0, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
                  has been completed, but the factor U is exactly
                  singular, so the solution could not be computed.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), :]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(A, 1), size(B, 2)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgesv_vec<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgesv_vec" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgesv_vec"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgesv_vec</h2>
<p>
<span class="ModelicaDescription">Solve real system of linear equations A*x=b with a b vector</span>
</p>
<h3>Information</h3>
<pre>
Same as function LAPACK.dgesv, but right hand side is a vector and not a matrix.
For details of the arguments, see documentation of dgesv.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>b[size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgglse_vec<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgglse_vec" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgglse_vec"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgglse_vec</h2>
<p>
<span class="ModelicaDescription">Solve a linear equality constrained least squares problem</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGGLSE solves the linear equality-constrained least squares (LSE)
    problem:

            minimize || c - A*x ||_2   subject to   B*x = d

    where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
    M-vector, and d is a given P-vector. It is assumed that
    P &lt;= N &lt;= M+P, and

             rank(B) = P and  rank( (A) ) = N.
                                  ( (B) )

    These conditions ensure that the LSE problem has a unique solution,
    which is obtained using a generalized RQ factorization of the
    matrices (B, A) given by

       B = (0 R)*Q,   A = Z*T*Q.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrices A and B. N &gt;= 0.

    P       (input) INTEGER
            The number of rows of the matrix B. 0 &lt;= P &lt;= N &lt;= M+P.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix T.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, the upper triangle of the subarray B(1:P,N-P+1:N)
            contains the P-by-P upper triangular matrix R.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB &gt;= max(1,P).

    C       (input/output) DOUBLE PRECISION array, dimension (M)
            On entry, C contains the right hand side vector for the
            least squares part of the LSE problem.
            On exit, the residual sum of squares for the solution
            is given by the sum of squares of elements N-P+1 to M of
            vector C.

    D       (input/output) DOUBLE PRECISION array, dimension (P)
            On entry, D contains the right hand side vector for the
            constrained equation.
            On exit, D is destroyed.

    X       (output) DOUBLE PRECISION array, dimension (N)
            On exit, X is the solution of the LSE problem.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK &gt;= max(1,M+N+P).
            For optimum performance LWORK &gt;= P+min(M,N)+max(M,N)*NB,
            where NB is an upper bound for the optimal blocksizes for
            DGEQRF, SGERQF, DORMQR and SORMRQ.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1:  the upper triangular factor R associated with B in the
                  generalized RQ factorization of the pair (B, A) is
                  singular, so that rank(B) &lt; P; the least squares
                  solution could not be computed.
            = 2:  the (N-P) by (N-P) part of the upper trapezoidal factor
                  T associated with A in the generalized RQ factorization
                  of the pair (B, A) is singular, so that
                  rank( (A) ) &lt; N; the least squares solution could not
                      ( (B) )
                  be computed.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Minimize |A*x - c|^2</td></tr>
<tr><td>c[size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[:, size(A, 2)]</td><td>subject to B*x=d</td></tr>
<tr><td>d[size(B, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[size(A, 2)]</td><td>solution vector</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgtsv<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgtsv" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgtsv"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgtsv</h2>
<p>
<span class="ModelicaDescription">Solve real system of linear equations A*X=B with B matrix and tridiagonal A</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGTSV  solves the equation

       A*X = B,

    where A is an n by n tridiagonal matrix, by Gaussian elimination with
    partial pivoting.

    Note that the equation  A&#39;*X = B  may be solved by interchanging the
    order of the arguments DU and DL.

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.  N &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.

    DL      (input/output) DOUBLE PRECISION array, dimension (N-1)
            On entry, DL must contain the (n-1) sub-diagonal elements of
            A.

            On exit, DL is overwritten by the (n-2) elements of the
            second super-diagonal of the upper triangular matrix U from
            the LU factorization of A, in DL(1), ..., DL(n-2).

    D       (input/output) DOUBLE PRECISION array, dimension (N)
            On entry, D must contain the diagonal elements of A.

            On exit, D is overwritten by the n diagonal elements of U.

    DU      (input/output) DOUBLE PRECISION array, dimension (N-1)
            On entry, DU must contain the (n-1) super-diagonal elements
            of A.

            On exit, DU is overwritten by the (n-1) elements of the first
            super-diagonal of U.

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the N by NRHS matrix of right hand side matrix B.
            On exit, if INFO = 0, the N by NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            &gt; 0: if INFO = i, U(i,i) is exactly zero, and the solution
                 has not been computed.  The factorization has not been
                 completed unless i = N.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>superdiag[:]</td><td>&nbsp;</td></tr>
<tr><td>diag[size(superdiag, 1) + 1]</td><td>&nbsp;</td></tr>
<tr><td>subdiag[size(superdiag, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(diag, 1), :]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(B, 1), size(B, 2)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgtsv_vec<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgtsv_vec" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgtsv_vec"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgtsv_vec</h2>
<p>
<span class="ModelicaDescription">Solve real system of linear equations A*x=b with b vector and tridiagonal A</span>
</p>
<h3>Information</h3>
<pre>
Same as function LAPACK.dgtsv, but right hand side is a vector and not a matrix.
For details of the arguments, see documentation of dgtsv.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>superdiag[:]</td><td>&nbsp;</td></tr>
<tr><td>diag[size(superdiag, 1) + 1]</td><td>&nbsp;</td></tr>
<tr><td>subdiag[size(superdiag, 1)]</td><td>&nbsp;</td></tr>
<tr><td>b[size(diag, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[size(b, 1)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgbsv<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgbsv" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgbsv"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgbsv</h2>
<p>
<span class="ModelicaDescription">Solve real system of linear equations A*X=B with a B matrix</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGBSV computes the solution to a real system of linear equations
    A * X = B, where A is a band matrix of order N with KL subdiagonals
    and KU superdiagonals, and X and B are N-by-NRHS matrices.

    The LU decomposition with partial pivoting and row interchanges is
    used to factor A as A = L * U, where L is a product of permutation
    and unit lower triangular matrices with KL subdiagonals, and U is
    upper triangular with KL+KU superdiagonals.  The factored form of A
    is then used to solve the system of equations A * X = B.

    Arguments
    =========

    N       (input) INTEGER
            The number of linear equations, i.e., the order of the
            matrix A.  N &gt;= 0.

    KL      (input) INTEGER
            The number of subdiagonals within the band of A.  KL &gt;= 0.

    KU      (input) INTEGER
            The number of superdiagonals within the band of A.  KU &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.

    AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)&lt;=i&lt;=min(N,j+KL)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.

    LDAB    (input) INTEGER
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.

    IPIV    (output) INTEGER array, dimension (N)
            The pivot indices that define the permutation matrix P;
            row i of the matrix was interchanged with row IPIV(i).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the N-by-NRHS right hand side matrix B.
            On exit, if INFO = 0, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
                  has been completed, but the factor U is exactly
                  singular, and the solution has not been computed.

    Further Details
    ===============

    The band storage scheme is illustrated by the following example, when
    M = N = 6, KL = 2, KU = 1:

    On entry:                       On exit:

        *    *    *    +    +    +       *    *    *   u14  u25  u36
        *    *    +    +    +    +       *    *   u13  u24  u35  u46
        *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
       a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
       a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
       a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *

    Array elements marked * are not used by the routine; elements marked
    + need not be set on entry, but are required by the routine to store
    elements of U because of fill-in resulting from the row interchanges.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>n</td><td>Number of equations</td></tr>
<tr><td>kLower</td><td>Number of lower bands</td></tr>
<tr><td>kUpper</td><td>Number of upper bands</td></tr>
<tr><td>A[2*kLower + kUpper + 1, n]</td><td>&nbsp;</td></tr>
<tr><td>B[n, :]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[n, size(B, 2)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgbsv_vec<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgbsv_vec" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgbsv_vec"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgbsv_vec</h2>
<p>
<span class="ModelicaDescription">Solve real system of linear equations A*x=b with a b vector</span>
</p>
<h3>Information</h3>
<pre>
Same as function LAPACK.dgbsv, but right hand side is a vector and not a matrix.
For details of the arguments, see documentation of dgbsv.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>n</td><td>Number of equations</td></tr>
<tr><td>kLower</td><td>Number of lower bands</td></tr>
<tr><td>kUpper</td><td>Number of upper bands</td></tr>
<tr><td>A[2*kLower + kUpper + 1, n]</td><td>&nbsp;</td></tr>
<tr><td>b[n]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[n]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgesvd<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgesvd" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgesvd"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgesvd</h2>
<p>
<span class="ModelicaDescription">Determine singular value decomposition</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGESVD computes the singular value decomposition (SVD) of a real
    M-by-N matrix A, optionally computing the left and/or right singular
    vectors. The SVD is written

         A = U * SIGMA * transpose(V)

    where SIGMA is an M-by-N matrix which is zero except for its
    min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
    V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
    are the singular values of A; they are real and non-negative, and
    are returned in descending order.  The first min(m,n) columns of
    U and V are the left and right singular vectors of A.

    Note that the routine returns V**T, not V.

    Arguments
    =========

    JOBU    (input) CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = &#39;A&#39;:  all M columns of U are returned in array U:
            = &#39;S&#39;:  the first min(m,n) columns of U (the left singular
                    vectors) are returned in the array U;
            = &#39;O&#39;:  the first min(m,n) columns of U (the left singular
                    vectors) are overwritten on the array A;
            = &#39;N&#39;:  no columns of U (no left singular vectors) are
                    computed.

    JOBVT   (input) CHARACTER*1
            Specifies options for computing all or part of the matrix
            V**T:
            = &#39;A&#39;:  all N rows of V**T are returned in the array VT;
            = &#39;S&#39;:  the first min(m,n) rows of V**T (the right singular
                    vectors) are returned in the array VT;
            = &#39;O&#39;:  the first min(m,n) rows of V**T (the right singular
                    vectors) are overwritten on the array A;
            = &#39;N&#39;:  no rows of V**T (no right singular vectors) are
                    computed.

            JOBVT and JOBU cannot both be &#39;O&#39;.

    M       (input) INTEGER
            The number of rows of the input matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the input matrix A.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBU = &#39;O&#39;,  A is overwritten with the first min(m,n)
                            columns of U (the left singular vectors,
                            stored columnwise);
            if JOBVT = &#39;O&#39;, A is overwritten with the first min(m,n)
                            rows of V**T (the right singular vectors,
                            stored rowwise);
            if JOBU .ne. &#39;O&#39; and JOBVT .ne. &#39;O&#39;, the contents of A
                            are destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).

    S       (output) DOUBLE PRECISION array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) &gt;= S(i+1).

    U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
            (LDU,M) if JOBU = &#39;A&#39; or (LDU,min(M,N)) if JOBU = &#39;S&#39;.
            If JOBU = &#39;A&#39;, U contains the M-by-M orthogonal matrix U;
            if JOBU = &#39;S&#39;, U contains the first min(m,n) columns of U
            (the left singular vectors, stored columnwise);
            if JOBU = &#39;N&#39; or &#39;O&#39;, U is not referenced.

    LDU     (input) INTEGER
            The leading dimension of the array U.  LDU &gt;= 1; if
            JOBU = &#39;S&#39; or &#39;A&#39;, LDU &gt;= M.

    VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
            If JOBVT = &#39;A&#39;, VT contains the N-by-N orthogonal matrix
            V**T;
            if JOBVT = &#39;S&#39;, VT contains the first min(m,n) rows of
            V**T (the right singular vectors, stored rowwise);
            if JOBVT = &#39;N&#39; or &#39;O&#39;, VT is not referenced.

    LDVT    (input) INTEGER
            The leading dimension of the array VT.  LDVT &gt;= 1; if
            JOBVT = &#39;A&#39;, LDVT &gt;= N; if JOBVT = &#39;S&#39;, LDVT &gt;= min(M,N).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
            if INFO &gt; 0, WORK(2:MIN(M,N)) contains the unconverged
            superdiagonal elements of an upper bidiagonal matrix B
            whose diagonal is in S (not necessarily sorted). B
            satisfies A = U * B * VT, so it has the same singular values
            as A, and singular vectors related by U and VT.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            LWORK &gt;= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).
            For good performance, LWORK should generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if DBDSQR did not converge, INFO specifies how many
                  superdiagonals of an intermediate bidiagonal form B
                  did not converge to zero. See the description of WORK
                  above for details.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>sigma[min(size(A, 1), size(A, 2))]</td><td>&nbsp;</td></tr>
<tr><td>U[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>VT[size(A, 2), size(A, 2)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgesvd_sigma<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgesvd_sigma" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgesvd_sigma"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgesvd_sigma</h2>
<p>
<span class="ModelicaDescription">Determine singular values</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGESVD computes the singular value decomposition (SVD) of a real
    M-by-N matrix A, optionally computing the left and/or right singular
    vectors. The SVD is written

         A = U * SIGMA * transpose(V)

    where SIGMA is an M-by-N matrix which is zero except for its
    min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
    V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
    are the singular values of A; they are real and non-negative, and
    are returned in descending order.  The first min(m,n) columns of
    U and V are the left and right singular vectors of A.

    Note that the routine returns V**T, not V.

    Arguments
    =========

    JOBU    (input) CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = &#39;A&#39;:  all M columns of U are returned in array U:
            = &#39;S&#39;:  the first min(m,n) columns of U (the left singular
                    vectors) are returned in the array U;
            = &#39;O&#39;:  the first min(m,n) columns of U (the left singular
                    vectors) are overwritten on the array A;
            = &#39;N&#39;:  no columns of U (no left singular vectors) are
                    computed.

    JOBVT   (input) CHARACTER*1
            Specifies options for computing all or part of the matrix
            V**T:
            = &#39;A&#39;:  all N rows of V**T are returned in the array VT;
            = &#39;S&#39;:  the first min(m,n) rows of V**T (the right singular
                    vectors) are returned in the array VT;
            = &#39;O&#39;:  the first min(m,n) rows of V**T (the right singular
                    vectors) are overwritten on the array A;
            = &#39;N&#39;:  no rows of V**T (no right singular vectors) are
                    computed.

            JOBVT and JOBU cannot both be &#39;O&#39;.

    M       (input) INTEGER
            The number of rows of the input matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the input matrix A.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBU = &#39;O&#39;,  A is overwritten with the first min(m,n)
                            columns of U (the left singular vectors,
                            stored columnwise);
            if JOBVT = &#39;O&#39;, A is overwritten with the first min(m,n)
                            rows of V**T (the right singular vectors,
                            stored rowwise);
            if JOBU .ne. &#39;O&#39; and JOBVT .ne. &#39;O&#39;, the contents of A
                            are destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).

    S       (output) DOUBLE PRECISION array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) &gt;= S(i+1).

    U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
            (LDU,M) if JOBU = &#39;A&#39; or (LDU,min(M,N)) if JOBU = &#39;S&#39;.
            If JOBU = &#39;A&#39;, U contains the M-by-M orthogonal matrix U;
            if JOBU = &#39;S&#39;, U contains the first min(m,n) columns of U
            (the left singular vectors, stored columnwise);
            if JOBU = &#39;N&#39; or &#39;O&#39;, U is not referenced.

    LDU     (input) INTEGER
            The leading dimension of the array U.  LDU &gt;= 1; if
            JOBU = &#39;S&#39; or &#39;A&#39;, LDU &gt;= M.

    VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
            If JOBVT = &#39;A&#39;, VT contains the N-by-N orthogonal matrix
            V**T;
            if JOBVT = &#39;S&#39;, VT contains the first min(m,n) rows of
            V**T (the right singular vectors, stored rowwise);
            if JOBVT = &#39;N&#39; or &#39;O&#39;, VT is not referenced.

    LDVT    (input) INTEGER
            The leading dimension of the array VT.  LDVT &gt;= 1; if
            JOBVT = &#39;A&#39;, LDVT &gt;= N; if JOBVT = &#39;S&#39;, LDVT &gt;= min(M,N).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
            if INFO &gt; 0, WORK(2:MIN(M,N)) contains the unconverged
            superdiagonal elements of an upper bidiagonal matrix B
            whose diagonal is in S (not necessarily sorted). B
            satisfies A = U * B * VT, so it has the same singular values
            as A, and singular vectors related by U and VT.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            LWORK &gt;= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).
            For good performance, LWORK should generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if DBDSQR did not converge, INFO specifies how many
                  superdiagonals of an intermediate bidiagonal form B
                  did not converge to zero. See the description of WORK
                  above for details.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>sigma[min(size(A, 1), size(A, 2))]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgetrf<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgetrf" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgetrf"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgetrf</h2>
<p>
<span class="ModelicaDescription">Compute LU factorization of square or rectangular matrix A (A = P*L*U)</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGETRF computes an LU factorization of a general M-by-N matrix A
    using partial pivoting with row interchanges.

    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m &gt; n), and U is upper
    triangular (upper trapezoidal if m &lt; n).

    This is the right-looking Level 3 BLAS version of the algorithm.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).

    IPIV    (output) INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Square or rectangular matrix</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>LU[size(A, 1), size(A, 2)]</td><td>&nbsp;</td></tr>
<tr><td>pivots[min(size(A, 1), size(A, 2))]</td><td>Pivot vector</td></tr>
<tr><td>info</td><td>Information</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgetrs<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgetrs" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgetrs"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgetrs</h2>
<p>
<span class="ModelicaDescription">Solves a system of linear equations with the LU decomposition from dgetrf(..)</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGETRS solves a system of linear equations
       A * X = B  or  A&#39; * X = B
    with a general N-by-N matrix A using the LU factorization computed
    by DGETRF.

    Arguments
    =========

    TRANS   (input) CHARACTER*1
            Specifies the form of the system of equations:
            = &#39;N&#39;:  A * X = B  (No transpose)
            = &#39;T&#39;:  A&#39;* X = B  (Transpose)
            = &#39;C&#39;:  A&#39;* X = B  (Conjugate transpose = Transpose)

    N       (input) INTEGER
            The order of the matrix A.  N &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.

    A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    IPIV    (input) INTEGER array, dimension (N)
            The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
            matrix was interchanged with row IPIV(i).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>LU[:, size(LU, 1)]</td><td>LU factorization of dgetrf of a square matrix</td></tr>
<tr><td>pivots[size(LU, 1)]</td><td>Pivot vector of dgetrf</td></tr>
<tr><td>B[size(LU, 1), :]</td><td>Right hand side matrix B</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(B, 1), size(B, 2)]</td><td>Solution matrix X</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgetrs_vec<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgetrs_vec" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgetrs_vec"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgetrs_vec</h2>
<p>
<span class="ModelicaDescription">Solves a system of linear equations with the LU decomposition from dgetrf(..)</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGETRS solves a system of linear equations
       A * X = B  or  A&#39; * X = B
    with a general N-by-N matrix A using the LU factorization computed
    by DGETRF.

    Arguments
    =========

    TRANS   (input) CHARACTER*1
            Specifies the form of the system of equations:
            = &#39;N&#39;:  A * X = B  (No transpose)
            = &#39;T&#39;:  A&#39;* X = B  (Transpose)
            = &#39;C&#39;:  A&#39;* X = B  (Conjugate transpose = Transpose)

    N       (input) INTEGER
            The order of the matrix A.  N &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.

    A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    IPIV    (input) INTEGER array, dimension (N)
            The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
            matrix was interchanged with row IPIV(i).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>LU[:, size(LU, 1)]</td><td>LU factorization of dgetrf of a square matrix</td></tr>
<tr><td>pivots[size(LU, 1)]</td><td>Pivot vector of dgetrf</td></tr>
<tr><td>b[size(LU, 1)]</td><td>Right hand side vector b</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[size(b, 1)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgetri<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgetri" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgetri"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgetri</h2>
<p>
<span class="ModelicaDescription">Computes the inverse of a matrix using the LU factorization from dgetrf(..)</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGETRI computes the inverse of a matrix using the LU factorization
    computed by DGETRF.

    This method inverts U and then computes inv(A) by solving the system
    inv(A)*L = inv(U) for inv(A).

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by DGETRF.
            On exit, if INFO = 0, the inverse of the original matrix A.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    IPIV    (input) INTEGER array, dimension (N)
            The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
            matrix was interchanged with row IPIV(i).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, then WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK &gt;= max(1,N).
            For optimal performance LWORK &gt;= N*NB, where NB is
            the optimal blocksize returned by ILAENV.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>LU[:, size(LU, 1)]</td><td>LU factorization of dgetrf of a square matrix</td></tr>
<tr><td>pivots[size(LU, 1)]</td><td>Pivot vector of dgetrf</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>inv[size(LU, 1), size(LU, 2)]</td><td>Inverse of matrix P*L*U</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgeqpf<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgeqpf" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgeqpf"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgeqpf</h2>
<p>
<span class="ModelicaDescription">Compute QR factorization of square or rectangular matrix A with column pivoting (A(:,p) = Q*R)</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    This routine is deprecated and has been replaced by routine DGEQP3.

    DGEQPF computes a QR factorization with column pivoting of a
    real M-by-N matrix A: A*P = Q*R.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A. M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix A. N &gt;= 0

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper triangular matrix R; the elements
            below the diagonal, together with the array TAU,
            represent the orthogonal matrix Q as a product of
            min(m,n) elementary reflectors.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,M).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(i) = 0,
            the i-th column of A is a free column.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.

    TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.

    WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value

    Further Details
    ===============

    The matrix Q is represented as a product of elementary reflectors

       Q = H(1) H(2) . . . H(n)

    Each H(i) has the form

       H = I - tau * v * v&#39;

    where tau is a real scalar, and v is a real vector with
    v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).

    The matrix P is represented in jpvt as follows: If
       jpvt(j) = i
    then the jth column of P is the ith canonical unit vector.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Square or rectangular matrix</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>QR[size(A, 1), size(A, 2)]</td><td>QR factorization in packed format</td></tr>
<tr><td>tau[min(size(A, 1), size(A, 2))]</td><td>The scalar factors of the elementary reflectors of Q</td></tr>
<tr><td>p[size(A, 2)]</td><td>Pivot vector</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dorgqr<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dorgqr" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dorgqr"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dorgqr</h2>
<p>
<span class="ModelicaDescription">Generates a Real orthogonal matrix Q which is defined as the product of elementary reflectors as returned from dgeqpf</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DORGQR generates an M-by-N real matrix Q with orthonormal columns,
    which is defined as the first N columns of a product of K elementary
    reflectors of order M

          Q  =  H(1) H(2) . . . H(k)

    as returned by DGEQRF.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix Q. M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix Q. M &gt;= N &gt;= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N &gt;= K &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by DGEQRF in the first k columns of its array
            argument A.
            On exit, the M-by-N matrix Q.

    LDA     (input) INTEGER
            The first dimension of the array A. LDA &gt;= max(1,M).

    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK &gt;= max(1,N).
            For optimum performance LWORK &gt;= N*NB, where NB is the
            optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument has an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>QR[:, :]</td><td>QR from dgeqpf</td></tr>
<tr><td>tau[min(size(QR, 1), size(QR, 2))]</td><td>The scalar factors of the elementary reflectors of Q</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Q[size(QR, 1), size(QR, 2)]</td><td>Orthogonal matrix Q</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgees<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgees" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgees"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgees</h2>
<p>
<span class="ModelicaDescription">Computes real Schur form T of real nonsymmetric matrix A, and, optionally, the matrix of Schur vectors Z as well as the eigenvalues</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGEES computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues, the real Schur form T, and, optionally, the matrix of
    Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).

    Optionally, it also orders the eigenvalues on the diagonal of the
    real Schur form so that selected eigenvalues are at the top left.
    The leading columns of Z then form an orthonormal basis for the
    invariant subspace corresponding to the selected eigenvalues.

    A matrix is in real Schur form if it is upper quasi-triangular with
    1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
    form
            [  a  b  ]
            [  c  a  ]

    where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).

    Arguments
    =========

    JOBVS   (input) CHARACTER*1
            = &#39;N&#39;: Schur vectors are not computed;
            = &#39;V&#39;: Schur vectors are computed.

    SORT    (input) CHARACTER*1
            Specifies whether or not to order the eigenvalues on the
            diagonal of the Schur form.
            = &#39;N&#39;: Eigenvalues are not ordered;
            = &#39;S&#39;: Eigenvalues are ordered (see SELECT).

    SELECT  (external procedure) LOGICAL FUNCTION of two DOUBLE PRECISION arguments
            SELECT must be declared EXTERNAL in the calling subroutine.
            If SORT = &#39;S&#39;, SELECT is used to select eigenvalues to sort
            to the top left of the Schur form.
            If SORT = &#39;N&#39;, SELECT is not referenced.
            An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
            SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex
            conjugate pair of eigenvalues is selected, then both complex
            eigenvalues are selected.
            Note that a selected complex eigenvalue may no longer
            satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
            ordering may change the value of complex eigenvalues
            (especially if the eigenvalue is ill-conditioned); in this
            case INFO is set to N+2 (see INFO below).

    N       (input) INTEGER
            The order of the matrix A. N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten by its real Schur form T.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    SDIM    (output) INTEGER
            If SORT = &#39;N&#39;, SDIM = 0.
            If SORT = &#39;S&#39;, SDIM = number of eigenvalues (after sorting)
                           for which SELECT is true. (Complex conjugate
                           pairs for which SELECT is true for either
                           eigenvalue count as 2.)

    WR      (output) DOUBLE PRECISION array, dimension (N)
    WI      (output) DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues in the same order
            that they appear on the diagonal of the output Schur form T.
            Complex conjugate pairs of eigenvalues will appear
            consecutively with the eigenvalue having the positive
            imaginary part first.

    VS      (output) DOUBLE PRECISION array, dimension (LDVS,N)
            If JOBVS = &#39;V&#39;, VS contains the orthogonal matrix Z of Schur
            vectors.
            If JOBVS = &#39;N&#39;, VS is not referenced.

    LDVS    (input) INTEGER
            The leading dimension of the array VS.  LDVS &gt;= 1; if
            JOBVS = &#39;V&#39;, LDVS &gt;= N.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) contains the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK &gt;= max(1,3*N).
            For good performance, LWORK must generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    BWORK   (workspace) LOGICAL array, dimension (N)
            Not referenced if SORT = &#39;N&#39;.

    INFO    (output) INTEGER
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value.
            &gt; 0: if INFO = i, and i is
               &lt;= N: the QR algorithm failed to compute all the
                     eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
                     contain those eigenvalues which have converged; if
                     JOBVS = &#39;V&#39;, VS contains the matrix which reduces A
                     to its partially converged Schur form.
               = N+1: the eigenvalues could not be reordered because some
                     eigenvalues were too close to separate (the problem
                     is very ill-conditioned);
               = N+2: after reordering, roundoff changed values of some
                     complex eigenvalues so that leading eigenvalues in
                     the Schur form no longer satisfy SELECT=.TRUE.  This
                     could also be caused by underflow due to scaling.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Square matrix</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>T[size(A, 1), size(A, 2)]</td><td>Real Schur form with A = Z*T*Z&#39;</td></tr>
<tr><td>Z[size(A, 1), size(A, 1)]</td><td>orthogonal matrix Z of Schur vectors</td></tr>
<tr><td>eval_real[size(A, 1)]</td><td>real part of the eigenvectors of A</td></tr>
<tr><td>eval_imag[size(A, 1)]</td><td>imaginary part of the eigenvectors of A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrsen<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dtrsen" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dtrsen"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dtrsen</h2>
<p>
<span class="ModelicaDescription">Reorder the real Schur factorization of a real matrix</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DTRSEN reorders the real Schur factorization of a real matrix
    A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
    the leading diagonal blocks of the upper quasi-triangular matrix T,
    and the leading columns of Q form an orthonormal basis of the
    corresponding right invariant subspace.

    Optionally the routine computes the reciprocal condition numbers of
    the cluster of eigenvalues and/or the invariant subspace.

    T must be in Schur canonical form (as returned by DHSEQR), that is,
    block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
    2-by-2 diagonal block has its diagonal elemnts equal and its
    off-diagonal elements of opposite sign.

    Arguments
    =========

    JOB     (input) CHARACTER*1
            Specifies whether condition numbers are required for the
            cluster of eigenvalues (S) or the invariant subspace (SEP):
            = &#39;N&#39;: none;
            = &#39;E&#39;: for eigenvalues only (S);
            = &#39;V&#39;: for invariant subspace only (SEP);
            = &#39;B&#39;: for both eigenvalues and invariant subspace (S and
                   SEP).

    COMPQ   (input) CHARACTER*1
            = &#39;V&#39;: update the matrix Q of Schur vectors;
            = &#39;N&#39;: do not update Q.

    SELECT  (input) LOGICAL array, dimension (N)
            SELECT specifies the eigenvalues in the selected cluster. To
            select a real eigenvalue w(j), SELECT(j) must be set to
            .TRUE.. To select a complex conjugate pair of eigenvalues
            w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,
            either SELECT(j) or SELECT(j+1) or both must be set to
            .TRUE.; a complex conjugate pair of eigenvalues must be
            either both included in the cluster or both excluded.

    N       (input) INTEGER
            The order of the matrix T. N &gt;= 0.

    T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)
            On entry, the upper quasi-triangular matrix T, in Schur
            canonical form.
            On exit, T is overwritten by the reordered matrix T, again in
            Schur canonical form, with the selected eigenvalues in the
            leading diagonal blocks.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT &gt;= max(1,N).

    Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
            On entry, if COMPQ = &#39;V&#39;, the matrix Q of Schur vectors.
            On exit, if COMPQ = &#39;V&#39;, Q has been postmultiplied by the
            orthogonal transformation matrix which reorders T; the
            leading M columns of Q form an orthonormal basis for the
            specified invariant subspace.
            If COMPQ = &#39;N&#39;, Q is not referenced.

    LDQ     (input) INTEGER
            The leading dimension of the array Q.
            LDQ &gt;= 1; and if COMPQ = &#39;V&#39;, LDQ &gt;= N.

    WR      (output) DOUBLE PRECISION array, dimension (N)
    WI      (output) DOUBLE PRECISION array, dimension (N)
            The real and imaginary parts, respectively, of the reordered
            eigenvalues of T. The eigenvalues are stored in the same
            order as on the diagonal of T, with WR(i) = T(i,i) and, if
            T(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) &gt; 0 and
            WI(i+1) = -WI(i). Note that if a complex eigenvalue is
            sufficiently ill-conditioned, then its value may differ
            significantly from its value before reordering.

    M       (output) INTEGER
            The dimension of the specified invariant subspace.
            0 &lt; = M &lt;= N.

    S       (output) DOUBLE PRECISION
            If JOB = &#39;E&#39; or &#39;B&#39;, S is a lower bound on the reciprocal
            condition number for the selected cluster of eigenvalues.
            S cannot underestimate the true reciprocal condition number
            by more than a factor of sqrt(N). If M = 0 or N, S = 1.
            If JOB = &#39;N&#39; or &#39;V&#39;, S is not referenced.

    SEP     (output) DOUBLE PRECISION
            If JOB = &#39;V&#39; or &#39;B&#39;, SEP is the estimated reciprocal
            condition number of the specified invariant subspace. If
            M = 0 or N, SEP = norm(T).
            If JOB = &#39;N&#39; or &#39;E&#39;, SEP is not referenced.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If JOB = &#39;N&#39;, LWORK &gt;= max(1,N);
            if JOB = &#39;E&#39;, LWORK &gt;= max(1,M*(N-M));
            if JOB = &#39;V&#39; or &#39;B&#39;, LWORK &gt;= max(1,2*M*(N-M)).

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.

    LIWORK  (input) INTEGER
            The dimension of the array IWORK.
            If JOB = &#39;N&#39; or &#39;E&#39;, LIWORK &gt;= 1;
            if JOB = &#39;V&#39; or &#39;B&#39;, LIWORK &gt;= max(1,M*(N-M)).

            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal size of the IWORK array,
            returns this value as the first entry of the IWORK array, and
            no error message related to LIWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            = 1: reordering of T failed because some eigenvalues are too
                 close to separate (the problem is very ill-conditioned);
                 T may have been partially reordered, and WR and WI
                 contain the eigenvalues in the same order as in T; S and
                 SEP (if requested) are set to zero.

    Further Details
    ===============

    DTRSEN first collects the selected eigenvalues by computing an
    orthogonal transformation Z to move them to the top left corner of T.
    In other words, the selected eigenvalues are the eigenvalues of T11
    in:

                  Z&#39;*T*Z = ( T11 T12 ) n1
                           (  0  T22 ) n2
                              n1  n2

    where N = n1+n2 and Z&#39; means the transpose of Z. The first n1 columns
    of Z span the specified invariant subspace of T.

    If T has been obtained from the real Schur factorization of a matrix
    A = Q*T*Q&#39;, then the reordered real Schur factorization of A is given
    by A = (Q*Z)*(Z&#39;*T*Z)*(Q*Z)&#39;, and the first n1 columns of Q*Z span
    the corresponding invariant subspace of A.

    The reciprocal condition number of the average of the eigenvalues of
    T11 may be returned in S. S lies between 0 (very badly conditioned)
    and 1 (very well conditioned). It is computed as follows. First we
    compute R so that

                           P = ( I  R ) n1
                               ( 0  0 ) n2
                                 n1 n2

    is the projector on the invariant subspace associated with T11.
    R is the solution of the Sylvester equation:

                          T11*R - R*T22 = T12.

    Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote
    the two-norm of M. Then S is computed as the lower bound

                        (1 + F-norm(R)**2)**(-1/2)

    on the reciprocal of 2-norm(P), the true reciprocal condition number.
    S cannot underestimate 1 / 2-norm(P) by more than a factor of
    sqrt(N).

    An approximate error bound for the computed average of the
    eigenvalues of T11 is

                           EPS * norm(T) / S

    where EPS is the machine precision.

    The reciprocal condition number of the right invariant subspace
    spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP.
    SEP is defined as the separation of T11 and T22:

                       sep( T11, T22 ) = sigma-min( C )

    where sigma-min(C) is the smallest singular value of the
    n1*n2-by-n1*n2 matrix

       C  = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )

    I(m) is an m by m identity matrix, and kprod denotes the Kronecker
    product. We estimate sigma-min(C) by the reciprocal of an estimate of
    the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C)
    cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).

    When SEP is small, small changes in T can cause large changes in
    the invariant subspace. An approximate bound on the maximum angular
    error in the computed right invariant subspace is

                        EPS * norm(T) / SEP
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>job</td><td>Specifies the usage of a condition number</td></tr>
<tr><td>compq</td><td>Is &quot;V&quot; if Schur vector matrix is to be updated</td></tr>
<tr><td>select[:]</td><td>Specifies the eigenvalues to reorder</td></tr>
<tr><td>T[:, :]</td><td>Real Schur form to be reordered</td></tr>
<tr><td>Q[:, size(T, 2)]</td><td>Matrix of the Schur vectors</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>To[:, :]</td><td>Reordered Schur form</td></tr>
<tr><td>Qo[:, :]</td><td>Reordered Schur vectors</td></tr>
<tr><td>wr[size(T, 2)]</td><td>Reordered eigenvalues, real part</td></tr>
<tr><td>wi[size(T, 2)]</td><td>Reordered eigenvalues, imaginary part</td></tr>
<tr><td>m</td><td>Dimension of the invariant sub space spanned bei the selected eigenvalues</td></tr>
<tr><td>s</td><td>Lower bound of the reciprocal condition number. Not referenced for job==V</td></tr>
<tr><td>sep</td><td>Estimated reciprocal condition number of the specified invariant subspace</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgesvx<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgesvx" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgesvx"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgesvx</h2>
<p>
<span class="ModelicaDescription">Solve real system of linear equations op(A)*X=B, op(A) is A or A&#39; according to the Boolean input transposed</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGESVX uses the LU factorization to compute the solution to a real
    system of linear equations
       A * X = B,
    where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

    Error bounds on the solution and a condition estimate are also
    provided.

    Description
    ===========

    The following steps are performed:

    1. If FACT = &#39;E&#39;, real scaling factors are computed to equilibrate
       the system:
          TRANS = &#39;N&#39;:  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
          TRANS = &#39;T&#39;: (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
          TRANS = &#39;C&#39;: (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
       Whether or not the system will be equilibrated depends on the
       scaling of the matrix A, but if equilibration is used, A is
       overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=&#39;N&#39;)
       or diag(C)*B (if TRANS = &#39;T&#39; or &#39;C&#39;).

    2. If FACT = &#39;N&#39; or &#39;E&#39;, the LU decomposition is used to factor the
       matrix A (after equilibration if FACT = &#39;E&#39;) as
          A = P * L * U,
       where P is a permutation matrix, L is a unit lower triangular
       matrix, and U is upper triangular.

    3. If some U(i,i)=0, so that U is exactly singular, then the routine
       returns with INFO = i. Otherwise, the factored form of A is used
       to estimate the condition number of the matrix A.  If the
       reciprocal of the condition number is less than machine precision,
       INFO = N+1 is returned as a warning, but the routine still goes on
       to solve for X and compute error bounds as described below.

    4. The system of equations is solved for X using the factored form
       of A.

    5. Iterative refinement is applied to improve the computed solution
       matrix and calculate error bounds and backward error estimates
       for it.

    6. If equilibration was used, the matrix X is premultiplied by
       diag(C) (if TRANS = &#39;N&#39;) or diag(R) (if TRANS = &#39;T&#39; or &#39;C&#39;) so
       that it solves the original system before equilibration.

    Arguments
    =========

    FACT    (input) CHARACTER*1
            Specifies whether or not the factored form of the matrix A is
            supplied on entry, and if not, whether the matrix A should be
            equilibrated before it is factored.
            = &#39;F&#39;:  On entry, AF and IPIV contain the factored form of A.
                    If EQUED is not &#39;N&#39;, the matrix A has been
                    equilibrated with scaling factors given by R and C.
                    A, AF, and IPIV are not modified.
            = &#39;N&#39;:  The matrix A will be copied to AF and factored.
            = &#39;E&#39;:  The matrix A will be equilibrated if necessary, then
                    copied to AF and factored.

    TRANS   (input) CHARACTER*1
            Specifies the form of the system of equations:
            = &#39;N&#39;:  A * X = B     (No transpose)
            = &#39;T&#39;:  A**T * X = B  (Transpose)
            = &#39;C&#39;:  A**H * X = B  (Transpose)

    N       (input) INTEGER
            The number of linear equations, i.e., the order of the
            matrix A.  N &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrices B and X.  NRHS &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.  If FACT = &#39;F&#39; and EQUED is
            not &#39;N&#39;, then A must have been equilibrated by the scaling
            factors in R and/or C.  A is not modified if FACT = &#39;F&#39; or
            &#39;N&#39;, or if FACT = &#39;E&#39; and EQUED = &#39;N&#39; on exit.

            On exit, if EQUED .ne. &#39;N&#39;, A is scaled as follows:
            EQUED = &#39;R&#39;:  A := diag(R) * A
            EQUED = &#39;C&#39;:  A := A * diag(C)
            EQUED = &#39;B&#39;:  A := diag(R) * A * diag(C).

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N)
            If FACT = &#39;F&#39;, then AF is an input argument and on entry
            contains the factors L and U from the factorization
            A = P*L*U as computed by DGETRF.  If EQUED .ne. &#39;N&#39;, then
            AF is the factored form of the equilibrated matrix A.

            If FACT = &#39;N&#39;, then AF is an output argument and on exit
            returns the factors L and U from the factorization A = P*L*U
            of the original matrix A.

            If FACT = &#39;E&#39;, then AF is an output argument and on exit
            returns the factors L and U from the factorization A = P*L*U
            of the equilibrated matrix A (see the description of A for
            the form of the equilibrated matrix).

    LDAF    (input) INTEGER
            The leading dimension of the array AF.  LDAF &gt;= max(1,N).

    IPIV    (input or output) INTEGER array, dimension (N)
            If FACT = &#39;F&#39;, then IPIV is an input argument and on entry
            contains the pivot indices from the factorization A = P*L*U
            as computed by DGETRF; row i of the matrix was interchanged
            with row IPIV(i).

            If FACT = &#39;N&#39;, then IPIV is an output argument and on exit
            contains the pivot indices from the factorization A = P*L*U
            of the original matrix A.

            If FACT = &#39;E&#39;, then IPIV is an output argument and on exit
            contains the pivot indices from the factorization A = P*L*U
            of the equilibrated matrix A.

    EQUED   (input or output) CHARACTER*1
            Specifies the form of equilibration that was done.
            = &#39;N&#39;:  No equilibration (always true if FACT = &#39;N&#39;).
            = &#39;R&#39;:  Row equilibration, i.e., A has been premultiplied by
                    diag(R).
            = &#39;C&#39;:  Column equilibration, i.e., A has been postmultiplied
                    by diag(C).
            = &#39;B&#39;:  Both row and column equilibration, i.e., A has been
                    replaced by diag(R) * A * diag(C).
            EQUED is an input argument if FACT = &#39;F&#39;; otherwise, it is an
            output argument.

    R       (input or output) DOUBLE PRECISION array, dimension (N)
            The row scale factors for A.  If EQUED = &#39;R&#39; or &#39;B&#39;, A is
            multiplied on the left by diag(R); if EQUED = &#39;N&#39; or &#39;C&#39;, R
            is not accessed.  R is an input argument if FACT = &#39;F&#39;;
            otherwise, R is an output argument.  If FACT = &#39;F&#39; and
            EQUED = &#39;R&#39; or &#39;B&#39;, each element of R must be positive.

    C       (input or output) DOUBLE PRECISION array, dimension (N)
            The column scale factors for A.  If EQUED = &#39;C&#39; or &#39;B&#39;, A is
            multiplied on the right by diag(C); if EQUED = &#39;N&#39; or &#39;R&#39;, C
            is not accessed.  C is an input argument if FACT = &#39;F&#39;;
            otherwise, C is an output argument.  If FACT = &#39;F&#39; and
            EQUED = &#39;C&#39; or &#39;B&#39;, each element of C must be positive.

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the N-by-NRHS right hand side matrix B.
            On exit,
            if EQUED = &#39;N&#39;, B is not modified;
            if TRANS = &#39;N&#39; and EQUED = &#39;R&#39; or &#39;B&#39;, B is overwritten by
            diag(R)*B;
            if TRANS = &#39;T&#39; or &#39;C&#39; and EQUED = &#39;C&#39; or &#39;B&#39;, B is
            overwritten by diag(C)*B.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).

    X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
            If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
            to the original system of equations.  Note that A and B are
            modified on exit if EQUED .ne. &#39;N&#39;, and the solution to the
            equilibrated system is inv(diag(C))*X if TRANS = &#39;N&#39; and
            EQUED = &#39;C&#39; or &#39;B&#39;, or inv(diag(R))*X if TRANS = &#39;T&#39; or &#39;C&#39;
            and EQUED = &#39;R&#39; or &#39;B&#39;.

    LDX     (input) INTEGER
            The leading dimension of the array X.  LDX &gt;= max(1,N).

    RCOND   (output) DOUBLE PRECISION
            The estimate of the reciprocal condition number of the matrix
            A after equilibration (if done).  If RCOND is less than the
            machine precision (in particular, if RCOND = 0), the matrix
            is singular to working precision.  This condition is
            indicated by a return code of INFO &gt; 0.

    FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
            The estimated forward error bound for each solution vector
            X(j) (the j-th column of the solution matrix X).
            If XTRUE is the true solution corresponding to X(j), FERR(j)
            is an estimated upper bound for the magnitude of the largest
            element in (X(j) - XTRUE) divided by the magnitude of the
            largest element in X(j).  The estimate is as reliable as
            the estimate for RCOND, and is almost always a slight
            overestimate of the true error.

    BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
            The componentwise relative backward error of each solution
            vector X(j) (i.e., the smallest relative change in
            any element of A or B that makes X(j) an exact solution).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (4*N)
            On exit, WORK(1) contains the reciprocal pivot growth
            factor norm(A)/norm(U). The &quot;max absolute element&quot; norm is
            used. If WORK(1) is much less than 1, then the stability
            of the LU factorization of the (equilibrated) matrix A
            could be poor. This also means that the solution X, condition
            estimator RCOND, and forward error bound FERR could be
            unreliable. If factorization fails with 0&lt;INFO&lt;=N, then
            WORK(1) contains the reciprocal pivot growth factor for the
            leading INFO columns of A.

    IWORK   (workspace) INTEGER array, dimension (N)

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, and i is
                  &lt;= N:  U(i,i) is exactly zero.  The factorization has
                         been completed, but the factor U is exactly
                         singular, so the solution and error bounds
                         could not be computed. RCOND = 0 is returned.
                  = N+1: U is nonsingular, but RCOND is less than machine
                         precision, meaning that the matrix is singular
                         to working precision.  Nevertheless, the
                         solution and error bounds are computed because
                         there are a number of situations where the
                         computed solution can be more accurate than the
                         value of RCOND would suggest.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Real square matrix A</td></tr>
<tr><td>B[size(A, 1), :]</td><td>Real matrix B</td></tr>
<tr><td>transposed</td><td>True if the equation to be solved is A&#39;*X=B</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(A, 1), size(B, 2)]</td><td>Solution matrix</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>rcond</td><td>reciprocal condition number of the matrix A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrsyl<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dtrsyl" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dtrsyl"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dtrsyl</h2>
<p>
<span class="ModelicaDescription">Solve the real Sylvester matrix equation op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DTRSYL solves the real Sylvester matrix equation:

       op(A)*X + X*op(B) = scale*C or
       op(A)*X - X*op(B) = scale*C,

    where op(A) = A or A**T, and  A and B are both upper quasi-
    triangular. A is M-by-M and B is N-by-N; the right hand side C and
    the solution X are M-by-N; and scale is an output scale factor, set
    &lt;= 1 to avoid overflow in X.

    A and B must be in Schur canonical form (as returned by DHSEQR), that
    is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
    each 2-by-2 diagonal block has its diagonal elements equal and its
    off-diagonal elements of opposite sign.

    Arguments
    =========

    TRANA   (input) CHARACTER*1
            Specifies the option op(A):
            = &#39;N&#39;: op(A) = A    (No transpose)
            = &#39;T&#39;: op(A) = A**T (Transpose)
            = &#39;C&#39;: op(A) = A**H (Conjugate transpose = Transpose)

    TRANB   (input) CHARACTER*1
            Specifies the option op(B):
            = &#39;N&#39;: op(B) = B    (No transpose)
            = &#39;T&#39;: op(B) = B**T (Transpose)
            = &#39;C&#39;: op(B) = B**H (Conjugate transpose = Transpose)

    ISGN    (input) INTEGER
            Specifies the sign in the equation:
            = +1: solve op(A)*X + X*op(B) = scale*C
            = -1: solve op(A)*X - X*op(B) = scale*C

    M       (input) INTEGER
            The order of the matrix A, and the number of rows in the
            matrices X and C. M &gt;= 0.

    N       (input) INTEGER
            The order of the matrix B, and the number of columns in the
            matrices X and C. N &gt;= 0.

    A       (input) DOUBLE PRECISION array, dimension (LDA,M)
            The upper quasi-triangular matrix A, in Schur canonical form.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,M).

    B       (input) DOUBLE PRECISION array, dimension (LDB,N)
            The upper quasi-triangular matrix B, in Schur canonical form.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB &gt;= max(1,N).

    C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N right hand side matrix C.
            On exit, C is overwritten by the solution matrix X.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M)

    SCALE   (output) DOUBLE PRECISION
            The scale factor, scale, set &lt;= 1 to avoid overflow in X.

    INFO    (output) INTEGER
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            = 1: A and B have common or very close eigenvalues; perturbed
                 values were used to solve the equation (but the matrices
                 A and B are unchanged).
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Upper quais-triangular matrix</td></tr>
<tr><td>B[:, :]</td><td>Upper quais-triangular matrix</td></tr>
<tr><td>C[if tranA then size(A, 1) else size(A, 2), if tranB then size(B, 1) else size(B, 2)]</td><td>Right side of the Sylvester equation</td></tr>
<tr><td>tranA</td><td>True if op(A)=A&#39;</td></tr>
<tr><td>tranB</td><td>True if op(B)=B&#39;</td></tr>
<tr><td>isgn</td><td>Specifies the sign in the equation, +1 or -1</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(C, 1), size(C, 2)]</td><td>Solution of the Sylvester equation</td></tr>
<tr><td>scale</td><td>Scale factor</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dhseqr<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dhseqr" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dhseqr"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dhseqr</h2>
<p>
<span class="ModelicaDescription">Compute eigenvalues of a matrix H using lapack routine DHSEQR for Hessenberg form matrix</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DHSEQR computes the eigenvalues of a Hessenberg matrix H
    and, optionally, the matrices T and Z from the Schur decomposition
    H = Z T Z**T, where T is an upper quasi-triangular matrix (the
    Schur form), and Z is the orthogonal matrix of Schur vectors.

    Optionally Z may be postmultiplied into an input orthogonal
    matrix Q so that this routine can give the Schur factorization
    of a matrix A which has been reduced to the Hessenberg form H
    by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.

    Arguments
    =========

    JOB   (input) CHARACTER*1
          = &#39;E&#39;:  compute eigenvalues only;
          = &#39;S&#39;:  compute eigenvalues and the Schur form T.

    COMPZ (input) CHARACTER*1
          = &#39;N&#39;:  no Schur vectors are computed;
          = &#39;I&#39;:  Z is initialized to the unit matrix and the matrix Z
                  of Schur vectors of H is returned;
          = &#39;V&#39;:  Z must contain an orthogonal matrix Q on entry, and
                  the product Q*Z is returned.

    N     (input) INTEGER
          The order of the matrix H.  N &gt;= 0.

    ILO   (input) INTEGER
    IHI   (input) INTEGER
          It is assumed that H is already upper triangular in rows
          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
          set by a previous call to DGEBAL, and then passed to DGEHRD
          when the matrix output by DGEBAL is reduced to Hessenberg
          form. Otherwise ILO and IHI should be set to 1 and N
          respectively.  If N&gt;0, then 1&lt;=ILO&lt;=IHI&lt;=N.
          If N = 0, then ILO = 1 and IHI = 0.

    H     (input/output) DOUBLE PRECISION array, dimension (LDH,N)
          On entry, the upper Hessenberg matrix H.
          On exit, if INFO = 0 and JOB = &#39;S&#39;, then H contains the
          upper quasi-triangular matrix T from the Schur decomposition
          (the Schur form); 2-by-2 diagonal blocks (corresponding to
          complex conjugate pairs of eigenvalues) are returned in
          standard form, with H(i,i) = H(i+1,i+1) and
          H(i+1,i)*H(i,i+1)&lt;0. If INFO = 0 and JOB = &#39;E&#39;, the
          contents of H are unspecified on exit.  (The output value of
          H when INFO&gt;0 is given under the description of INFO
          below.)

          Unlike earlier versions of DHSEQR, this subroutine may
          explicitly H(i,j) = 0 for i&gt;j and j = 1, 2, ... ILO-1
          or j = IHI+1, IHI+2, ... N.

    LDH   (input) INTEGER
          The leading dimension of the array H. LDH &gt;= max(1,N).

    WR    (output) DOUBLE PRECISION array, dimension (N)
    WI    (output) DOUBLE PRECISION array, dimension (N)
          The real and imaginary parts, respectively, of the computed
          eigenvalues. If two eigenvalues are computed as a complex
          conjugate pair, they are stored in consecutive elements of
          WR and WI, say the i-th and (i+1)th, with WI(i) &gt; 0 and
          WI(i+1) &lt; 0. If JOB = &#39;S&#39;, the eigenvalues are stored in
          the same order as on the diagonal of the Schur form returned
          in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
          diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
          WI(i+1) = -WI(i).

    Z     (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
          If COMPZ = &#39;N&#39;, Z is not referenced.
          If COMPZ = &#39;I&#39;, on entry Z need not be set and on exit,
          if INFO = 0, Z contains the orthogonal matrix Z of the Schur
          vectors of H.  If COMPZ = &#39;V&#39;, on entry Z must contain an
          N-by-N matrix Q, which is assumed to be equal to the unit
          matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
          if INFO = 0, Z contains Q*Z.
          Normally Q is the orthogonal matrix generated by DORGHR
          after the call to DGEHRD which formed the Hessenberg matrix
          H. (The output value of Z when INFO&gt;0 is given under
          the description of INFO below.)

    LDZ   (input) INTEGER
          The leading dimension of the array Z.  if COMPZ = &#39;I&#39; or
          COMPZ = &#39;V&#39;, then LDZ&gt;=MAX(1,N).  Otherwize, LDZ&gt;=1.

    WORK  (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
          On exit, if INFO = 0, WORK(1) returns an estimate of
          the optimal value for LWORK.

    LWORK (input) INTEGER
          The dimension of the array WORK.  LWORK &gt;= max(1,N)
          is sufficient and delivers very good and sometimes
          optimal performance.  However, LWORK as large as 11*N
          may be required for optimal performance.  A workspace
          query is recommended to determine the optimal workspace
          size.

          If LWORK = -1, then DHSEQR does a workspace query.
          In this case, DHSEQR checks the input parameters and
          estimates the optimal workspace size for the given
          values of N, ILO and IHI.  The estimate is returned
          in WORK(1).  No error message related to LWORK is
          issued by XERBLA.  Neither H nor Z are accessed.


    INFO  (output) INTEGER
          = 0: successful exit
          &lt; 0: if INFO = -i, the i-th argument had an illegal
               value
          &gt; 0: if INFO = i, DHSEQR failed to compute all of
               the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
               and WI contain those eigenvalues which have been
               successfully computed.  (Failures are rare.)

               If INFO &gt; 0 and JOB = &#39;E&#39;, then on exit, the
               remaining unconverged eigenvalues are the eigen-
               values of the upper Hessenberg matrix rows and
               columns ILO through INFO of the final, output
               value of H.

               If INFO &gt; 0 and JOB   = &#39;S&#39;, then on exit

          (*)  (initial value of H)*U  = U*(final value of H)

               where U is an orthogonal matrix.  The final
               value of H is upper Hessenberg and quasi-triangular
               in rows and columns INFO+1 through IHI.

               If INFO &gt; 0 and COMPZ = &#39;V&#39;, then on exit

                 (final value of Z)  =  (initial value of Z)*U

               where U is the orthogonal matrix in (*) (regard-
               less of the value of JOB.)

               If INFO &gt; 0 and COMPZ = &#39;I&#39;, then on exit
                     (final value of Z)  = U
               where U is the orthogonal matrix in (*) (regard-
               less of the value of JOB.)

               If INFO &gt; 0 and COMPZ = &#39;N&#39;, then Z is not
               accessed.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>H[:, size(H, 1)]</td><td>Matrix H with Hessenberg form</td></tr>
<tr><td>eigenValuesOnly</td><td>True to compute the eigenvalues. False to compute the Schur form too</td></tr>
<tr><td>compz</td><td>Specifies the computation of the Schur vectors</td></tr>
<tr><td>Z[:, :]</td><td>Matrix Z</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(H, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))</td></tr>
<tr><td>alphaImag[size(H, 1)]</td><td>Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>Ho[:, :]</td><td>Schur decomposition (if eigenValuesOnly==false, unspecified else)</td></tr>
<tr><td>Zo[:, :]</td><td>&nbsp;</td></tr>
<tr><td>work[3*max(1, size(H, 1))]</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dlange<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dlange" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dlange"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dlange</h2>
<p>
<span class="ModelicaDescription">Norm of a matrix</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DLANGE  returns the value of the one norm,  or the Frobenius norm, or
    the  infinity norm,  or the  element of  largest absolute value  of a
    real matrix A.

    Description
    ===========

    DLANGE returns the value

       DLANGE = ( max(abs(A(i,j))), NORM = &#39;M&#39; or &#39;m&#39;
                (
                ( norm1(A),         NORM = &#39;1&#39;, &#39;O&#39; or &#39;o&#39;
                (
                ( normI(A),         NORM = &#39;I&#39; or &#39;i&#39;
                (
                ( normF(A),         NORM = &#39;F&#39;, &#39;f&#39;, &#39;E&#39; or &#39;e&#39;

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

    Arguments
    =========

    NORM    (input) CHARACTER*1
            Specifies the value to be returned in DLANGE as described
            above.

    M       (input) INTEGER
            The number of rows of the matrix A.  M &gt;= 0.  When M = 0,
            DLANGE is set to zero.

    N       (input) INTEGER
            The number of columns of the matrix A.  N &gt;= 0.  When N = 0,
            DLANGE is set to zero.

    A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            The m by n matrix A.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(M,1).

    WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK &gt;= M when NORM = &#39;I&#39;; otherwise, WORK is not
            referenced.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Real matrix A</td></tr>
<tr><td>norm</td><td>specifies the norm, i.e., 1, I, F, M</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>anorm</td><td>norm of A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgecon<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgecon" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgecon"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgecon</h2>
<p>
<span class="ModelicaDescription">Estimates the reciprocal of the condition number of a general real matrix A</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGECON estimates the reciprocal of the condition number of a general
    real matrix A, in either the 1-norm or the infinity-norm, using
    the LU factorization computed by DGETRF.

    An estimate is obtained for norm(inv(A)), and the reciprocal of the
    condition number is computed as
       RCOND = 1 / ( norm(A) * norm(inv(A)) ).

    Arguments
    =========

    NORM    (input) CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = &#39;1&#39; or &#39;O&#39;:  1-norm;
            = &#39;I&#39;:         Infinity-norm.

    N       (input) INTEGER
            The order of the matrix A.  N &gt;= 0.

    A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    ANORM   (input) DOUBLE PRECISION
            If NORM = &#39;1&#39; or &#39;O&#39;, the 1-norm of the original matrix A.
            If NORM = &#39;I&#39;, the infinity-norm of the original matrix A.

    RCOND   (output) DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).

    WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)

    IWORK   (workspace) INTEGER array, dimension (N)

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>LU_of_A[:, :]</td><td>LU factorization of a real matrix A</td></tr>
<tr><td>inf</td><td>Is true if infinity norm is used and false for 1-norm</td></tr>
<tr><td>anorm</td><td>norm of A</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>rcond</td><td>Reciprocal condition number of A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgehrd<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgehrd" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgehrd"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgehrd</h2>
<p>
<span class="ModelicaDescription">reduces a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGEHRD reduces a real general matrix A to upper Hessenberg form H by
    an orthogonal similarity transformation:  Q&#39; * A * Q = H .

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.  N &gt;= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to DGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the orthogonal matrix Q as a product of elementary
            reflectors. See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    TAU     (output) DOUBLE PRECISION array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
            zero.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The length of the array WORK.  LWORK &gt;= max(1,N).
            For optimum performance LWORK &gt;= N*NB, where NB is the
            optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    The matrix Q is represented as a product of (ihi-ilo) elementary
    reflectors

       Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Each H(i) has the form

       H(i) = I - tau * v * v&#39;

    where tau is a real scalar, and v is a real vector with
    v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
    exit in A(i+2:ihi,i), and tau in TAU(i).

    The contents of A are illustrated by the following example, with
    n = 7, ilo = 2 and ihi = 6:

    on entry,                        on exit,

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )

    where a denotes an element of the original matrix A, h denotes a
    modified element of the upper Hessenberg matrix H, and vi denotes an
    element of the vector defining H(i).
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 2)]</td><td>&nbsp;</td></tr>
<tr><td>ilo</td><td>lowest index where the original matrix had been Hessenbergform</td></tr>
<tr><td>ihi</td><td>highest index where the original matrix had been Hessenbergform</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Aout[size(A, 1), size(A, 2)]</td><td>contains the Hessenberg form in the upper triangle and the first subdiagonal and below the first subdiagonal it contains the elementary reflectors which represents (with array tau) as a product the orthogonal matrix Q</td></tr>
<tr><td>tau[max(size(A, 1), 1) - 1]</td><td>scalar factors of the elementary reflectors</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgeqrf<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgeqrf" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgeqrf"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgeqrf</h2>
<p>
<span class="ModelicaDescription">computes a QR factorization without pivoting</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGEQRF computes a QR factorization of a real M-by-N matrix A:
    A = Q * R.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m &gt;= n); the elements below the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).

    TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK &gt;= max(1,N).
            For optimum performance LWORK &gt;= N*NB, where NB is
            the optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value

    Further Details
    ===============

    The matrix Q is represented as a product of elementary reflectors

       Q = H(1) H(2) . . . H(k), where k = min(m,n).

    Each H(i) has the form

       H(i) = I - tau * v * v&#39;

    where tau is a real scalar, and v is a real vector with
    v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
    and tau in TAU(i).
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Square or rectangular matrix</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Aout[size(A, 1), size(A, 2)]</td><td>the upper triangle of the array contains the upper trapezoidal matrix R; the elements below the diagonal, together with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors</td></tr>
<tr><td>tau[min(size(A, 1), size(A, 2))]</td><td>scalar factors of the elementary reflectors</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>work[3*max(1, size(A, 2))]</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgeevx<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgeevx" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgeevx"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgeevx</h2>
<p>
<span class="ModelicaDescription">Compute the eigenvalues and the (real) left and right eigenvectors of matrix A, using lapack routine dgeevx</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGEEVX computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues and, optionally, the left and/or right eigenvectors.

    Optionally also, it computes a balancing transformation to improve
    the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
    SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
    (RCONDE), and reciprocal condition numbers for the right
    eigenvectors (RCONDV).

    The right eigenvector v(j) of A satisfies
                     A * v(j) = lambda(j) * v(j)
    where lambda(j) is its eigenvalue.
    The left eigenvector u(j) of A satisfies
                  u(j)**H * A = lambda(j) * u(j)**H
    where u(j)**H denotes the conjugate transpose of u(j).

    The computed eigenvectors are normalized to have Euclidean norm
    equal to 1 and largest component real.

    Balancing a matrix means permuting the rows and columns to make it
    more nearly upper triangular, and applying a diagonal similarity
    transformation D * A * D**(-1), where D is a diagonal matrix, to
    make its rows and columns closer in norm and the condition numbers
    of its eigenvalues and eigenvectors smaller.  The computed
    reciprocal condition numbers correspond to the balanced matrix.
    Permuting rows and columns will not change the condition numbers
    (in exact arithmetic) but diagonal scaling will.  For further
    explanation of balancing, see section 4.10.2 of the LAPACK
    Users&#39; Guide.

    Arguments
    =========

    BALANC  (input) CHARACTER*1
            Indicates how the input matrix should be diagonally scaled
            and/or permuted to improve the conditioning of its
            eigenvalues.
            = &#39;N&#39;: Do not diagonally scale or permute;
            = &#39;P&#39;: Perform permutations to make the matrix more nearly
                   upper triangular. Do not diagonally scale;
            = &#39;S&#39;: Diagonally scale the matrix, i.e. replace A by
                   D*A*D**(-1), where D is a diagonal matrix chosen
                   to make the rows and columns of A more equal in
                   norm. Do not permute;
            = &#39;B&#39;: Both diagonally scale and permute A.

            Computed reciprocal condition numbers will be for the matrix
            after balancing and/or permuting. Permuting does not change
            condition numbers (in exact arithmetic), but balancing does.

    JOBVL   (input) CHARACTER*1
            = &#39;N&#39;: left eigenvectors of A are not computed;
            = &#39;V&#39;: left eigenvectors of A are computed.
            If SENSE = &#39;E&#39; or &#39;B&#39;, JOBVL must = &#39;V&#39;.

    JOBVR   (input) CHARACTER*1
            = &#39;N&#39;: right eigenvectors of A are not computed;
            = &#39;V&#39;: right eigenvectors of A are computed.
            If SENSE = &#39;E&#39; or &#39;B&#39;, JOBVR must = &#39;V&#39;.

    SENSE   (input) CHARACTER*1
            Determines which reciprocal condition numbers are computed.
            = &#39;N&#39;: None are computed;
            = &#39;E&#39;: Computed for eigenvalues only;
            = &#39;V&#39;: Computed for right eigenvectors only;
            = &#39;B&#39;: Computed for eigenvalues and right eigenvectors.

            If SENSE = &#39;E&#39; or &#39;B&#39;, both left and right eigenvectors
            must also be computed (JOBVL = &#39;V&#39; and JOBVR = &#39;V&#39;).

    N       (input) INTEGER
            The order of the matrix A. N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.  If JOBVL = &#39;V&#39; or
            JOBVR = &#39;V&#39;, A contains the real Schur form of the balanced
            version of the input matrix A.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    WR      (output) DOUBLE PRECISION array, dimension (N)
    WI      (output) DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues will appear consecutively
            with the eigenvalue having the positive imaginary part
            first.

    VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = &#39;N&#39;, VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).

    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL &gt;= 1; if
            JOBVL = &#39;V&#39;, LDVL &gt;= N.

    VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = &#39;N&#39;, VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).

    LDVR    (input) INTEGER
            The leading dimension of the array VR.  LDVR &gt;= 1, and if
            JOBVR = &#39;V&#39;, LDVR &gt;= N.

    ILO     (output) INTEGER
    IHI     (output) INTEGER
            ILO and IHI are integer values determined when A was
            balanced.  The balanced A(i,j) = 0 if I &gt; J and
            J = 1,...,ILO-1 or I = IHI+1,...,N.

    SCALE   (output) DOUBLE PRECISION array, dimension (N)
            Details of the permutations and scaling factors applied
            when balancing A.  If P(j) is the index of the row and column
            interchanged with row and column j, and D(j) is the scaling
            factor applied to row and column j, then
            SCALE(J) = P(J),    for J = 1,...,ILO-1
                     = D(J),    for J = ILO,...,IHI
                     = P(J)     for J = IHI+1,...,N.
            The order in which the interchanges are made is N to IHI+1,
            then 1 to ILO-1.

    ABNRM   (output) DOUBLE PRECISION
            The one-norm of the balanced matrix (the maximum
            of the sum of absolute values of elements of any column).

    RCONDE  (output) DOUBLE PRECISION array, dimension (N)
            RCONDE(j) is the reciprocal condition number of the j-th
            eigenvalue.

    RCONDV  (output) DOUBLE PRECISION array, dimension (N)
            RCONDV(j) is the reciprocal condition number of the j-th
            right eigenvector.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.   If SENSE = &#39;N&#39; or &#39;E&#39;,
            LWORK &gt;= max(1,2*N), and if JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;,
            LWORK &gt;= 3*N.  If SENSE = &#39;V&#39; or &#39;B&#39;, LWORK &gt;= N*(N+6).
            For good performance, LWORK must generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    IWORK   (workspace) INTEGER array, dimension (2*N-2)
            If SENSE = &#39;N&#39; or &#39;E&#39;, not referenced.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors or condition numbers
                  have been computed; elements 1:ILO-1 and i+1:N of WR
                  and WI contain eigenvalues which have converged.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))</td></tr>
<tr><td>lEigenVectors[size(A, 1), size(A, 1)]</td><td>left eigenvectors of matrix A</td></tr>
<tr><td>rEigenVectors[size(A, 1), size(A, 1)]</td><td>right eigenvectors of matrix A</td></tr>
<tr><td>AS[size(A, 1), size(A, 2)]</td><td>AS iss the real Schur form of the balanced version of the input matrix A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgesdd<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dgesdd" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dgesdd"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dgesdd</h2>
<p>
<span class="ModelicaDescription">Determine singular value decomposition</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGESDD computes the singular value decomposition (SVD) of a real
    M-by-N matrix A, optionally computing the left and right singular
    vectors.  If singular vectors are desired, it uses a
    divide-and-conquer algorithm.

    The SVD is written

         A = U * SIGMA * transpose(V)

    where SIGMA is an M-by-N matrix which is zero except for its
    min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
    V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
    are the singular values of A; they are real and non-negative, and
    are returned in descending order.  The first min(m,n) columns of
    U and V are the left and right singular vectors of A.

    Note that the routine returns VT = V**T, not V.

    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    JOBZ    (input) CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = &#39;A&#39;:  all M columns of U and all N rows of V**T are
                    returned in the arrays U and VT;
            = &#39;S&#39;:  the first min(M,N) columns of U and the first
                    min(M,N) rows of V**T are returned in the arrays U
                    and VT;
            = &#39;O&#39;:  If M &gt;= N, the first N columns of U are overwritten
                    on the array A and all rows of V**T are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V**T are overwritten
                    in the array A;
            = &#39;N&#39;:  no columns of U or rows of V**T are computed.

    M       (input) INTEGER
            The number of rows of the input matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the input matrix A.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = &#39;O&#39;,  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M &gt;= N;
                            A is overwritten with the first M rows
                            of V**T (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. &#39;O&#39;, the contents of A are destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).

    S       (output) DOUBLE PRECISION array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) &gt;= S(i+1).

    U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &lt; N;
            UCOL = min(M,N) if JOBZ = &#39;S&#39;.
            If JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &lt; N, U contains the M-by-M
            orthogonal matrix U;
            if JOBZ = &#39;S&#39;, U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = &#39;O&#39; and M &gt;= N, or JOBZ = &#39;N&#39;, U is not referenced.

    LDU     (input) INTEGER
            The leading dimension of the array U.  LDU &gt;= 1; if
            JOBZ = &#39;S&#39; or &#39;A&#39; or JOBZ = &#39;O&#39; and M &lt; N, LDU &gt;= M.

    VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
            If JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &gt;= N, VT contains the
            N-by-N orthogonal matrix V**T;
            if JOBZ = &#39;S&#39;, VT contains the first min(M,N) rows of
            V**T (the right singular vectors, stored rowwise);
            if JOBZ = &#39;O&#39; and M &lt; N, or JOBZ = &#39;N&#39;, VT is not referenced.

    LDVT    (input) INTEGER
            The leading dimension of the array VT.  LDVT &gt;= 1; if
            JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &gt;= N, LDVT &gt;= N;
            if JOBZ = &#39;S&#39;, LDVT &gt;= min(M,N).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK;

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK &gt;= 1.
            If JOBZ = &#39;N&#39;,
              LWORK &gt;= 3*min(M,N) + max(max(M,N),7*min(M,N)).
            If JOBZ = &#39;O&#39;,
              LWORK &gt;= 3*min(M,N) +
                       max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
            If JOBZ = &#39;S&#39; or &#39;A&#39;
              LWORK &gt;= 3*min(M,N) +
                       max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).
            For good performance, LWORK should generally be larger.
            If LWORK = -1 but other input arguments are legal, WORK(1)
            returns the optimal LWORK.

    IWORK   (workspace) INTEGER array, dimension (8*min(M,N))

    INFO    (output) INTEGER
            = 0:  successful exit.
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            &gt; 0:  DBDSDC did not converge, updating process failed.

    Further Details
    ===============

    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>sigma[min(size(A, 1), size(A, 2))]</td><td>&nbsp;</td></tr>
<tr><td>U[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>VT[size(A, 2), size(A, 2)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dggev<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dggev" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dggev"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dggev</h2>
<p>
<span class="ModelicaDescription">Compute generalized eigenvalues, as well as the left and right eigenvectors for a (A,B) system</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
    the generalized eigenvalues, and optionally, the left and/or right
    generalized eigenvectors.

    A generalized eigenvalue for a pair of matrices (A,B) is a scalar
    lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
    singular. It is usually represented as the pair (alpha,beta), as
    there is a reasonable interpretation for beta=0, and even for both
    being zero.

    The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
    of (A,B) satisfies

                     A * v(j) = lambda(j) * B * v(j).

    The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
    of (A,B) satisfies

                     u(j)**H * A  = lambda(j) * u(j)**H * B .

    where u(j)**H is the conjugate-transpose of u(j).


    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = &#39;N&#39;:  do not compute the left generalized eigenvectors;
            = &#39;V&#39;:  compute the left generalized eigenvectors.

    JOBVR   (input) CHARACTER*1
            = &#39;N&#39;:  do not compute the right generalized eigenvectors;
            = &#39;V&#39;:  compute the right generalized eigenvectors.

    N       (input) INTEGER
            The order of the matrices A, B, VL, and VR.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the matrix A in the pair (A,B).
            On exit, A has been overwritten.

    LDA     (input) INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the matrix B in the pair (A,B).
            On exit, B has been overwritten.

    LDB     (input) INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).

    ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
    ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
    BETA    (output) DOUBLE PRECISION array, dimension (N)
            On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
            be the generalized eigenvalues.  If ALPHAI(j) is zero, then
            the j-th eigenvalue is real; if positive, then the j-th and
            (j+1)-st eigenvalues are a complex conjugate pair, with
            ALPHAI(j+1) negative.

            Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
            may easily over- or underflow, and BETA(j) may even be zero.
            Thus, the user should avoid naively computing the ratio
            alpha/beta.  However, ALPHAR and ALPHAI will be always less
            than and usually comparable with norm(A) in magnitude, and
            BETA always less than and usually comparable with norm(B).

    VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order as
            their eigenvalues. If the j-th eigenvalue is real, then
            u(j) = VL(:,j), the j-th column of VL. If the j-th and
            (j+1)-th eigenvalues form a complex conjugate pair, then
            u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
            Each eigenvector is scaled so the largest component has
            abs(real part)+abs(imag. part)=1.
            Not referenced if JOBVL = &#39;N&#39;.

    LDVL    (input) INTEGER
            The leading dimension of the matrix VL. LDVL &gt;= 1, and
            if JOBVL = &#39;V&#39;, LDVL &gt;= N.

    VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order as
            their eigenvalues. If the j-th eigenvalue is real, then
            v(j) = VR(:,j), the j-th column of VR. If the j-th and
            (j+1)-th eigenvalues form a complex conjugate pair, then
            v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
            Each eigenvector is scaled so the largest component has
            abs(real part)+abs(imag. part)=1.
            Not referenced if JOBVR = &#39;N&#39;.

    LDVR    (input) INTEGER
            The leading dimension of the matrix VR. LDVR &gt;= 1, and
            if JOBVR = &#39;V&#39;, LDVR &gt;= N.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK &gt;= max(1,8*N).
            For good performance, LWORK must generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1,...,N:
                  The QZ iteration failed.  No eigenvectors have been
                  calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                  should be correct for j=INFO+1,...,N.
            &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.
                  =N+2: error return from DTGEVC.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>nA</td><td>The actual dimensions of matrices A and B (the computation is performed for A[1:nA,1:nA], B[1:nA,1:nA])</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha</td></tr>
<tr><td>beta[size(A, 1)]</td><td>Denominator of eigenvalue</td></tr>
<tr><td>lEigenVectors[size(A, 1), size(A, 1)]</td><td>left eigenvectors of matrix A</td></tr>
<tr><td>rEigenVectors[size(A, 1), size(A, 1)]</td><td>right eigenvectors of matrix A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dggevx<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dggevx" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dggevx"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dggevx</h2>
<p>
<span class="ModelicaDescription">Compute generalized eigenvalues for a (A,B) system, using lapack routine dggevx</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
    the generalized eigenvalues, and optionally, the left and/or right
    generalized eigenvectors.

    Optionally also, it computes a balancing transformation to improve
    the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
    LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
    the eigenvalues (RCONDE), and reciprocal condition numbers for the
    right eigenvectors (RCONDV).

    A generalized eigenvalue for a pair of matrices (A,B) is a scalar
    lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
    singular. It is usually represented as the pair (alpha,beta), as
    there is a reasonable interpretation for beta=0, and even for both
    being zero.

    The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
    of (A,B) satisfies

                     A * v(j) = lambda(j) * B * v(j) .

    The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
    of (A,B) satisfies

                     u(j)**H * A  = lambda(j) * u(j)**H * B.

    where u(j)**H is the conjugate-transpose of u(j).


    Arguments
    =========

    BALANC  (input) CHARACTER*1
            Specifies the balance option to be performed.
            = &#39;N&#39;:  do not diagonally scale or permute;
            = &#39;P&#39;:  permute only;
            = &#39;S&#39;:  scale only;
            = &#39;B&#39;:  both permute and scale.
            Computed reciprocal condition numbers will be for the
            matrices after permuting and/or balancing. Permuting does
            not change condition numbers (in exact arithmetic), but
            balancing does.

    JOBVL   (input) CHARACTER*1
            = &#39;N&#39;:  do not compute the left generalized eigenvectors;
            = &#39;V&#39;:  compute the left generalized eigenvectors.

    JOBVR   (input) CHARACTER*1
            = &#39;N&#39;:  do not compute the right generalized eigenvectors;
            = &#39;V&#39;:  compute the right generalized eigenvectors.

    SENSE   (input) CHARACTER*1
            Determines which reciprocal condition numbers are computed.
            = &#39;N&#39;: none are computed;
            = &#39;E&#39;: computed for eigenvalues only;
            = &#39;V&#39;: computed for eigenvectors only;
            = &#39;B&#39;: computed for eigenvalues and eigenvectors.

    N       (input) INTEGER
            The order of the matrices A, B, VL, and VR.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the matrix A in the pair (A,B).
            On exit, A has been overwritten. If JOBVL=&#39;V&#39; or JOBVR=&#39;V&#39;
            or both, then A contains the first part of the real Schur
            form of the &quot;balanced&quot; versions of the input A and B.

    LDA     (input) INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the matrix B in the pair (A,B).
            On exit, B has been overwritten. If JOBVL=&#39;V&#39; or JOBVR=&#39;V&#39;
            or both, then B contains the second part of the real Schur
            form of the &quot;balanced&quot; versions of the input A and B.

    LDB     (input) INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).

    ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
    ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
    BETA    (output) DOUBLE PRECISION array, dimension (N)
            On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
            be the generalized eigenvalues.  If ALPHAI(j) is zero, then
            the j-th eigenvalue is real; if positive, then the j-th and
            (j+1)-st eigenvalues are a complex conjugate pair, with
            ALPHAI(j+1) negative.

            Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
            may easily over- or underflow, and BETA(j) may even be zero.
            Thus, the user should avoid naively computing the ratio
            ALPHA/BETA. However, ALPHAR and ALPHAI will be always less
            than and usually comparable with norm(A) in magnitude, and
            BETA always less than and usually comparable with norm(B).

    VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order as
            their eigenvalues. If the j-th eigenvalue is real, then
            u(j) = VL(:,j), the j-th column of VL. If the j-th and
            (j+1)-th eigenvalues form a complex conjugate pair, then
            u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
            Each eigenvector will be scaled so the largest component have
            abs(real part) + abs(imag. part) = 1.
            Not referenced if JOBVL = &#39;N&#39;.

    LDVL    (input) INTEGER
            The leading dimension of the matrix VL. LDVL &gt;= 1, and
            if JOBVL = &#39;V&#39;, LDVL &gt;= N.

    VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order as
            their eigenvalues. If the j-th eigenvalue is real, then
            v(j) = VR(:,j), the j-th column of VR. If the j-th and
            (j+1)-th eigenvalues form a complex conjugate pair, then
            v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
            Each eigenvector will be scaled so the largest component have
            abs(real part) + abs(imag. part) = 1.
            Not referenced if JOBVR = &#39;N&#39;.

    LDVR    (input) INTEGER
            The leading dimension of the matrix VR. LDVR &gt;= 1, and
            if JOBVR = &#39;V&#39;, LDVR &gt;= N.

    ILO     (output) INTEGER
    IHI     (output) INTEGER
            ILO and IHI are integer values such that on exit
            A(i,j) = 0 and B(i,j) = 0 if i &gt; j and
            j = 1,...,ILO-1 or i = IHI+1,...,N.
            If BALANC = &#39;N&#39; or &#39;S&#39;, ILO = 1 and IHI = N.

    LSCALE  (output) DOUBLE PRECISION array, dimension (N)
            Details of the permutations and scaling factors applied
            to the left side of A and B.  If PL(j) is the index of the
            row interchanged with row j, and DL(j) is the scaling
            factor applied to row j, then
              LSCALE(j) = PL(j)  for j = 1,...,ILO-1
                        = DL(j)  for j = ILO,...,IHI
                        = PL(j)  for j = IHI+1,...,N.
            The order in which the interchanges are made is N to IHI+1,
            then 1 to ILO-1.

    RSCALE  (output) DOUBLE PRECISION array, dimension (N)
            Details of the permutations and scaling factors applied
            to the right side of A and B.  If PR(j) is the index of the
            column interchanged with column j, and DR(j) is the scaling
            factor applied to column j, then
              RSCALE(j) = PR(j)  for j = 1,...,ILO-1
                        = DR(j)  for j = ILO,...,IHI
                        = PR(j)  for j = IHI+1,...,N
            The order in which the interchanges are made is N to IHI+1,
            then 1 to ILO-1.

    ABNRM   (output) DOUBLE PRECISION
            The one-norm of the balanced matrix A.

    BBNRM   (output) DOUBLE PRECISION
            The one-norm of the balanced matrix B.

    RCONDE  (output) DOUBLE PRECISION array, dimension (N)
            If SENSE = &#39;E&#39; or &#39;B&#39;, the reciprocal condition numbers of
            the eigenvalues, stored in consecutive elements of the array.
            For a complex conjugate pair of eigenvalues two consecutive
            elements of RCONDE are set to the same value. Thus RCONDE(j),
            RCONDV(j), and the j-th columns of VL and VR all correspond
            to the j-th eigenpair.
            If SENSE = &#39;N or &#39;V&#39;, RCONDE is not referenced.

    RCONDV  (output) DOUBLE PRECISION array, dimension (N)
            If SENSE = &#39;V&#39; or &#39;B&#39;, the estimated reciprocal condition
            numbers of the eigenvectors, stored in consecutive elements
            of the array. For a complex eigenvector two consecutive
            elements of RCONDV are set to the same value. If the
            eigenvalues cannot be reordered to compute RCONDV(j),
            RCONDV(j) is set to 0; this can only occur when the true
            value would be very small anyway.
            If SENSE = &#39;N&#39; or &#39;E&#39;, RCONDV is not referenced.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK &gt;= max(1,2*N).
            If BALANC = &#39;S&#39; or &#39;B&#39;, or JOBVL = &#39;V&#39;, or JOBVR = &#39;V&#39;,
            LWORK &gt;= max(1,6*N).
            If SENSE = &#39;E&#39; or &#39;B&#39;, LWORK &gt;= max(1,10*N).
            If SENSE = &#39;V&#39; or &#39;B&#39;, LWORK &gt;= 2*N*N+8*N+16.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    IWORK   (workspace) INTEGER array, dimension (N+6)
            If SENSE = &#39;E&#39;, IWORK is not referenced.

    BWORK   (workspace) LOGICAL array, dimension (N)
            If SENSE = &#39;N&#39;, BWORK is not referenced.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1,...,N:
                  The QZ iteration failed.  No eigenvectors have been
                  calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                  should be correct for j=INFO+1,...,N.
            &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.
                  =N+2: error return from DTGEVC.

    Further Details
    ===============

    Balancing a matrix pair (A,B) includes, first, permuting rows and
    columns to isolate eigenvalues, second, applying diagonal similarity
    transformation to the rows and columns to make the rows and columns
    as close in norm as possible. The computed reciprocal condition
    numbers correspond to the balanced matrix. Permuting rows and columns
    will not change the condition numbers (in exact arithmetic) but
    diagonal scaling will.  For further explanation of balancing, see
    section 4.11.1.2 of LAPACK Users&#39; Guide.

    An approximate error bound on the chordal distance between the i-th
    computed generalized eigenvalue w and the corresponding exact
    eigenvalue lambda is

         chord(w, lambda) &lt;= EPS * norm(ABNRM, BBNRM) / RCONDE(I)

    An approximate error bound for the angle between the i-th computed
    eigenvector VL(i) or VR(i) is given by

         EPS * norm(ABNRM, BBNRM) / DIF(i).

    For further explanation of the reciprocal condition numbers RCONDE
    and RCONDV, see section 4.11 of LAPACK User&#39;s Guide.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha</td></tr>
<tr><td>beta[size(A, 1)]</td><td>Denominator of eigenvalue</td></tr>
<tr><td>lEigenVectors[size(A, 1), size(A, 1)]</td><td>left eigenvectors of matrix A</td></tr>
<tr><td>rEigenVectors[size(A, 1), size(A, 1)]</td><td>right eigenvectors of matrix A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dhgeqz<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dhgeqz" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dhgeqz"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dhgeqz</h2>
<p>
<span class="ModelicaDescription">Compute generalized eigenvalues for a (A,B) system</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DHGEQZ computes the eigenvalues of a real matrix pair (H,T),
    where H is an upper Hessenberg matrix and T is upper triangular,
    using the double-shift QZ method.
    Matrix pairs of this type are produced by the reduction to
    generalized upper Hessenberg form of a real matrix pair (A,B):

       A = Q1*H*Z1**T,  B = Q1*T*Z1**T,

    as computed by DGGHRD.

    If JOB=&#39;S&#39;, then the Hessenberg-triangular pair (H,T) is
    also reduced to generalized Schur form,

       H = Q*S*Z**T,  T = Q*P*Z**T,

    where Q and Z are orthogonal matrices, P is an upper triangular
    matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
    diagonal blocks.

    The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
    (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
    eigenvalues.

    Additionally, the 2-by-2 upper triangular diagonal blocks of P
    corresponding to 2-by-2 blocks of S are reduced to positive diagonal
    form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
    P(j,j) &gt; 0, and P(j+1,j+1) &gt; 0.

    Optionally, the orthogonal matrix Q from the generalized Schur
    factorization may be postmultiplied into an input matrix Q1, and the
    orthogonal matrix Z may be postmultiplied into an input matrix Z1.
    If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
    the matrix pair (A,B) to generalized upper Hessenberg form, then the
    output matrices Q1*Q and Z1*Z are the orthogonal factors from the
    generalized Schur factorization of (A,B):

       A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.

    To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
    of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
    complex and beta real.
    If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
    generalized nonsymmetric eigenvalue problem (GNEP)
       A*x = lambda*B*x
    and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
    alternate form of the GNEP
       mu*A*y = B*y.
    Real eigenvalues can be read directly from the generalized Schur
    form:
      alpha = S(i,i), beta = P(i,i).

    Ref: C.B. Moler &amp; G.W. Stewart, &quot;An Algorithm for Generalized Matrix
         Eigenvalue Problems&quot;, SIAM J. Numer. Anal., 10(1973),
         pp. 241--256.

    Arguments
    =========

    JOB     (input) CHARACTER*1
            = &#39;E&#39;: Compute eigenvalues only;
            = &#39;S&#39;: Compute eigenvalues and the Schur form.

    COMPQ   (input) CHARACTER*1
            = &#39;N&#39;: Left Schur vectors (Q) are not computed;
            = &#39;I&#39;: Q is initialized to the unit matrix and the matrix Q
                   of left Schur vectors of (H,T) is returned;
            = &#39;V&#39;: Q must contain an orthogonal matrix Q1 on entry and
                   the product Q1*Q is returned.

    COMPZ   (input) CHARACTER*1
            = &#39;N&#39;: Right Schur vectors (Z) are not computed;
            = &#39;I&#39;: Z is initialized to the unit matrix and the matrix Z
                   of right Schur vectors of (H,T) is returned;
            = &#39;V&#39;: Z must contain an orthogonal matrix Z1 on entry and
                   the product Z1*Z is returned.

    N       (input) INTEGER
            The order of the matrices H, T, Q, and Z.  N &gt;= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            ILO and IHI mark the rows and columns of H which are in
            Hessenberg form.  It is assumed that A is already upper
            triangular in rows and columns 1:ILO-1 and IHI+1:N.
            If N &gt; 0, 1 &lt;= ILO &lt;= IHI &lt;= N; if N = 0, ILO=1 and IHI=0.

    H       (input/output) DOUBLE PRECISION array, dimension (LDH, N)
            On entry, the N-by-N upper Hessenberg matrix H.
            On exit, if JOB = &#39;S&#39;, H contains the upper quasi-triangular
            matrix S from the generalized Schur factorization;
            2-by-2 diagonal blocks (corresponding to complex conjugate
            pairs of eigenvalues) are returned in standard form, with
            H(i,i) = H(i+1,i+1) and H(i+1,i)*H(i,i+1) &lt; 0.
            If JOB = &#39;E&#39;, the diagonal blocks of H match those of S, but
            the rest of H is unspecified.

    LDH     (input) INTEGER
            The leading dimension of the array H.  LDH &gt;= max( 1, N ).

    T       (input/output) DOUBLE PRECISION array, dimension (LDT, N)
            On entry, the N-by-N upper triangular matrix T.
            On exit, if JOB = &#39;S&#39;, T contains the upper triangular
            matrix P from the generalized Schur factorization;
            2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S
            are reduced to positive diagonal form, i.e., if H(j+1,j) is
            non-zero, then T(j+1,j) = T(j,j+1) = 0, T(j,j) &gt; 0, and
            T(j+1,j+1) &gt; 0.
            If JOB = &#39;E&#39;, the diagonal blocks of T match those of P, but
            the rest of T is unspecified.

    LDT     (input) INTEGER
            The leading dimension of the array T.  LDT &gt;= max( 1, N ).

    ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
            The real parts of each scalar alpha defining an eigenvalue
            of GNEP.

    ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
            The imaginary parts of each scalar alpha defining an
            eigenvalue of GNEP.
            If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
            positive, then the j-th and (j+1)-st eigenvalues are a
            complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j).

    BETA    (output) DOUBLE PRECISION array, dimension (N)
            The scalars beta that define the eigenvalues of GNEP.
            Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
            beta = BETA(j) represent the j-th eigenvalue of the matrix
            pair (A,B), in one of the forms lambda = alpha/beta or
            mu = beta/alpha.  Since either lambda or mu may overflow,
            they should not, in general, be computed.

    Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
            On entry, if COMPZ = &#39;V&#39;, the orthogonal matrix Q1 used in
            the reduction of (A,B) to generalized Hessenberg form.
            On exit, if COMPZ = &#39;I&#39;, the orthogonal matrix of left Schur
            vectors of (H,T), and if COMPZ = &#39;V&#39;, the orthogonal matrix
            of left Schur vectors of (A,B).
            Not referenced if COMPZ = &#39;N&#39;.

    LDQ     (input) INTEGER
            The leading dimension of the array Q.  LDQ &gt;= 1.
            If COMPQ=&#39;V&#39; or &#39;I&#39;, then LDQ &gt;= N.

    Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
            On entry, if COMPZ = &#39;V&#39;, the orthogonal matrix Z1 used in
            the reduction of (A,B) to generalized Hessenberg form.
            On exit, if COMPZ = &#39;I&#39;, the orthogonal matrix of
            right Schur vectors of (H,T), and if COMPZ = &#39;V&#39;, the
            orthogonal matrix of right Schur vectors of (A,B).
            Not referenced if COMPZ = &#39;N&#39;.

    LDZ     (input) INTEGER
            The leading dimension of the array Z.  LDZ &gt;= 1.
            If COMPZ=&#39;V&#39; or &#39;I&#39;, then LDZ &gt;= N.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO &gt;= 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK &gt;= max(1,N).

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0: successful exit
            &lt; 0: if INFO = -i, the i-th argument had an illegal value
            = 1,...,N: the QZ iteration did not converge.  (H,T) is not
                       in Schur form, but ALPHAR(i), ALPHAI(i), and
                       BETA(i), i=INFO+1,...,N should be correct.
            = N+1,...,2*N: the shift calculation failed.  (H,T) is not
                       in Schur form, but ALPHAR(i), ALPHAI(i), and
                       BETA(i), i=INFO-N+1,...,N should be correct.

    Further Details
    ===============

    Iteration counters:

    JITER  -- counts iterations.
    IITER  -- counts iterations run since ILAST was last
              changed.  This is therefore reset only when a 1-by-1 or
              2-by-2 block deflates off the bottom.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha</td></tr>
<tr><td>beta[size(A, 1)]</td><td>Denominator of eigenvalue</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dormhr<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dormhr" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dormhr"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dormhr</h2>
<p>
<span class="ModelicaDescription">overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix as returned by dgehrd</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DORMHR overwrites the general real M-by-N matrix C with

                    SIDE = &#39;L&#39;     SIDE = &#39;R&#39;
    TRANS = &#39;N&#39;:      Q * C          C * Q
    TRANS = &#39;T&#39;:      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix of order nq, with nq = m if
    SIDE = &#39;L&#39; and nq = n if SIDE = &#39;R&#39;. Q is defined as the product of
    IHI-ILO elementary reflectors, as returned by DGEHRD:

    Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = &#39;L&#39;: apply Q or Q**T from the Left;
            = &#39;R&#39;: apply Q or Q**T from the Right.

    TRANS   (input) CHARACTER*1
            = &#39;N&#39;:  No transpose, apply Q;
            = &#39;T&#39;:  Transpose, apply Q**T.

    M       (input) INTEGER
            The number of rows of the matrix C. M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N &gt;= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            ILO and IHI must have the same values as in the previous call
            of DGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            If SIDE = &#39;L&#39;, then 1 &lt;= ILO &lt;= IHI &lt;= M, if M &gt; 0, and
            ILO = 1 and IHI = 0, if M = 0;
            if SIDE = &#39;R&#39;, then 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0, and
            ILO = 1 and IHI = 0, if N = 0.

    A       (input) DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = &#39;L&#39;
                                 (LDA,N) if SIDE = &#39;R&#39;
            The vectors which define the elementary reflectors, as
            returned by DGEHRD.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            LDA &gt;= max(1,M) if SIDE = &#39;L&#39;; LDA &gt;= max(1,N) if SIDE = &#39;R&#39;.

    TAU     (input) DOUBLE PRECISION array, dimension
                                 (M-1) if SIDE = &#39;L&#39;
                                 (N-1) if SIDE = &#39;R&#39;
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEHRD.

    C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = &#39;L&#39;, LWORK &gt;= max(1,N);
            if SIDE = &#39;R&#39;, LWORK &gt;= max(1,M).
            For optimum performance LWORK &gt;= N*NB if SIDE = &#39;L&#39;, and
            LWORK &gt;= M*NB if SIDE = &#39;R&#39;, where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>C[:, :]</td><td>&nbsp;</td></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>tau[if side == &quot;L&quot; then size(C, 2) - 1 else size(C, 1) - 1]</td><td>&nbsp;</td></tr>
<tr><td>side</td><td>&nbsp;</td></tr>
<tr><td>trans</td><td>&nbsp;</td></tr>
<tr><td>ilo</td><td>lowest index where the original matrix had been Hessenbergform</td></tr>
<tr><td>ihi</td><td>highest index where the original matrix had been Hessenbergform</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Cout[size(C, 1), size(C, 2)]</td><td>contains the Hessenberg form in the upper triangle and the first subdiagonal and below the first subdiagonal it contains the elementary reflectors which represents (with array tau) as a product the orthogonal matrix Q</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dormqr<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dormqr" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dormqr"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dormqr</h2>
<p>
<span class="ModelicaDescription">overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix of a QR factorization as returned by dgeqrf</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DORMQR overwrites the general real M-by-N matrix C with

                    SIDE = &#39;L&#39;     SIDE = &#39;R&#39;
    TRANS = &#39;N&#39;:      Q * C          C * Q
    TRANS = &#39;T&#39;:      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(1) H(2) . . . H(k)

    as returned by DGEQRF. Q is of order M if SIDE = &#39;L&#39; and of order N
    if SIDE = &#39;R&#39;.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = &#39;L&#39;: apply Q or Q**T from the Left;
            = &#39;R&#39;: apply Q or Q**T from the Right.

    TRANS   (input) CHARACTER*1
            = &#39;N&#39;:  No transpose, apply Q;
            = &#39;T&#39;:  Transpose, apply Q**T.

    M       (input) INTEGER
            The number of rows of the matrix C. M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N &gt;= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = &#39;L&#39;, M &gt;= K &gt;= 0;
            if SIDE = &#39;R&#39;, N &gt;= K &gt;= 0.

    A       (input) DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = &#39;L&#39;, LDA &gt;= max(1,M);
            if SIDE = &#39;R&#39;, LDA &gt;= max(1,N).

    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.

    C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = &#39;L&#39;, LWORK &gt;= max(1,N);
            if SIDE = &#39;R&#39;, LWORK &gt;= max(1,M).
            For optimum performance LWORK &gt;= N*NB if SIDE = &#39;L&#39;, and
            LWORK &gt;= M*NB if SIDE = &#39;R&#39;, where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>C[:, :]</td><td>&nbsp;</td></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>tau[:]</td><td>&nbsp;</td></tr>
<tr><td>side</td><td>&nbsp;</td></tr>
<tr><td>trans</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Cout[size(C, 1), size(C, 2)]</td><td>contains Q*C or Q**T*C or C*Q**T or C*Q</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrevc<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dtrevc" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dtrevc"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dtrevc</h2>
<p>
<span class="ModelicaDescription">Compute the right and/or left eigenvectors of a real upper quasi-triangular matrix T</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DTREVC computes some or all of the right and/or left eigenvectors of
    a real upper quasi-triangular matrix T.
    Matrices of this type are produced by the Schur factorization of
    a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.

    The right eigenvector x and the left eigenvector y of T corresponding
    to an eigenvalue w are defined by:

       T*x = w*x,     (y**H)*T = w*(y**H)

    where y**H denotes the conjugate transpose of y.
    The eigenvalues are not input to this routine, but are read directly
    from the diagonal blocks of T.

    This routine returns the matrices X and/or Y of right and left
    eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
    input matrix.  If Q is the orthogonal factor that reduces a matrix
    A to Schur form T, then Q*X and Q*Y are the matrices of right and
    left eigenvectors of A.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = &#39;R&#39;:  compute right eigenvectors only;
            = &#39;L&#39;:  compute left eigenvectors only;
            = &#39;B&#39;:  compute both right and left eigenvectors.

    HOWMNY  (input) CHARACTER*1
            = &#39;A&#39;:  compute all right and/or left eigenvectors;
            = &#39;B&#39;:  compute all right and/or left eigenvectors,
                    backtransformed by the matrices in VR and/or VL;
            = &#39;S&#39;:  compute selected right and/or left eigenvectors,
                    as indicated by the logical array SELECT.

    SELECT  (input/output) LOGICAL array, dimension (N)
            If HOWMNY = &#39;S&#39;, SELECT specifies the eigenvectors to be
            computed.
            If w(j) is a real eigenvalue, the corresponding real
            eigenvector is computed if SELECT(j) is .TRUE..
            If w(j) and w(j+1) are the real and imaginary parts of a
            complex eigenvalue, the corresponding complex eigenvector is
            computed if either SELECT(j) or SELECT(j+1) is .TRUE., and
            on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to
            .FALSE..
            Not referenced if HOWMNY = &#39;A&#39; or &#39;B&#39;.

    N       (input) INTEGER
            The order of the matrix T. N &gt;= 0.

    T       (input) DOUBLE PRECISION array, dimension (LDT,N)
            The upper quasi-triangular matrix T in Schur canonical form.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT &gt;= max(1,N).

    VL      (input/output) DOUBLE PRECISION array, dimension (LDVL,MM)
            On entry, if SIDE = &#39;L&#39; or &#39;B&#39; and HOWMNY = &#39;B&#39;, VL must
            contain an N-by-N matrix Q (usually the orthogonal matrix Q
            of Schur vectors returned by DHSEQR).
            On exit, if SIDE = &#39;L&#39; or &#39;B&#39;, VL contains:
            if HOWMNY = &#39;A&#39;, the matrix Y of left eigenvectors of T;
            if HOWMNY = &#39;B&#39;, the matrix Q*Y;
            if HOWMNY = &#39;S&#39;, the left eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VL, in the same order as their
                             eigenvalues.
            A complex eigenvector corresponding to a complex eigenvalue
            is stored in two consecutive columns, the first holding the
            real part, and the second the imaginary part.
            Not referenced if SIDE = &#39;R&#39;.

    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL &gt;= 1, and if
            SIDE = &#39;L&#39; or &#39;B&#39;, LDVL &gt;= N.

    VR      (input/output) DOUBLE PRECISION array, dimension (LDVR,MM)
            On entry, if SIDE = &#39;R&#39; or &#39;B&#39; and HOWMNY = &#39;B&#39;, VR must
            contain an N-by-N matrix Q (usually the orthogonal matrix Q
            of Schur vectors returned by DHSEQR).
            On exit, if SIDE = &#39;R&#39; or &#39;B&#39;, VR contains:
            if HOWMNY = &#39;A&#39;, the matrix X of right eigenvectors of T;
            if HOWMNY = &#39;B&#39;, the matrix Q*X;
            if HOWMNY = &#39;S&#39;, the right eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VR, in the same order as their
                             eigenvalues.
            A complex eigenvector corresponding to a complex eigenvalue
            is stored in two consecutive columns, the first holding the
            real part and the second the imaginary part.
            Not referenced if SIDE = &#39;L&#39;.

    LDVR    (input) INTEGER
            The leading dimension of the array VR.  LDVR &gt;= 1, and if
            SIDE = &#39;R&#39; or &#39;B&#39;, LDVR &gt;= N.

    MM      (input) INTEGER
            The number of columns in the arrays VL and/or VR. MM &gt;= M.

    M       (output) INTEGER
            The number of columns in the arrays VL and/or VR actually
            used to store the eigenvectors.
            If HOWMNY = &#39;A&#39; or &#39;B&#39;, M is set to N.
            Each selected real eigenvector occupies one column and each
            selected complex eigenvector occupies two columns.

    WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value

    Further Details
    ===============

    The algorithm used in this program is basically backward (forward)
    substitution, with scaling to make the the code robust against
    possible overflow.

    Each eigenvector is normalized so that the element of largest
    magnitude has magnitude 1; here the magnitude of a complex number
    (x,y) is taken to be |x| + |y|.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>T[:, size(T, 1)]</td><td>Upper quasi triangular matrix</td></tr>
<tr><td>side</td><td>Specify which eigenvectors</td></tr>
<tr><td>howmny</td><td>Specify how many eigenvectors</td></tr>
<tr><td>Q[size(T, 1), size(T, 1)]</td><td>Orthogonal matrix Q of Schur vectors returned by DHSEQR</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>lEigenVectors[size(T, 1), size(T, 1)]</td><td>left eigenvectors of matrix T</td></tr>
<tr><td>rEigenVectors[size(T, 1), size(T, 1)]</td><td>right eigenvectors of matrix T</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dpotrf<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dpotrf" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dpotrf"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dpotrf</h2>
<p>
<span class="ModelicaDescription">Computes the Cholesky factorization of a real symmetric positive definite matrix A</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DPOTRF computes the Cholesky factorization of a real symmetric
    positive definite matrix A.

    The factorization has the form
       A = U**T * U,  if UPLO = &#39;U&#39;, or
       A = L  * L**T,  if UPLO = &#39;L&#39;,
    where U is an upper triangular matrix and L is lower triangular.

    This is the block version of the algorithm, calling Level 3 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = &#39;U&#39;:  Upper triangle of A is stored;
            = &#39;L&#39;:  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = &#39;U&#39;, the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = &#39;L&#39;, the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.

            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**T*U or A = L*L**T.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Real symmetric positive definite matrix A</td></tr>
<tr><td>upper</td><td>True if the upper triangle of A is provided</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Acholesky[size(A, 1), size(A, 1)]</td><td>Cholesky factor</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrsm<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dtrsm" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dtrsm"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dtrsm</h2>
<p>
<span class="ModelicaDescription">Solve one of the matrix equations op( A )*X = alpha*B, or X*op( A ) = alpha*B, where A is triangular matrix. BLAS routine</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DTRSM solves one of the matrix equations

       op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,

    where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

       op( A ) = A   or   op( A ) = A&#39;.

    The matrix X is overwritten on B.

    Arguments
    ==========

    SIDE   - CHARACTER*1.
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:

                SIDE = &#39;L&#39; or &#39;l&#39;   op( A )*X = alpha*B.

                SIDE = &#39;R&#39; or &#39;r&#39;   X*op( A ) = alpha*B.

             Unchanged on exit.

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:

                UPLO = &#39;U&#39; or &#39;u&#39;   A is an upper triangular matrix.

                UPLO = &#39;L&#39; or &#39;l&#39;   A is a lower triangular matrix.

             Unchanged on exit.

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = &#39;N&#39; or &#39;n&#39;   op( A ) = A.

                TRANSA = &#39;T&#39; or &#39;t&#39;   op( A ) = A&#39;.

                TRANSA = &#39;C&#39; or &#39;c&#39;   op( A ) = A&#39;.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:

                DIAG = &#39;U&#39; or &#39;u&#39;   A is assumed to be unit triangular.

                DIAG = &#39;N&#39; or &#39;n&#39;   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = &#39;L&#39; or &#39;l&#39;  and is  n  when  SIDE = &#39;R&#39; or &#39;r&#39;.
             Before entry  with  UPLO = &#39;U&#39; or &#39;u&#39;,  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = &#39;L&#39; or &#39;l&#39;,  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = &#39;U&#39; or &#39;u&#39;,  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = &#39;L&#39; or &#39;l&#39;  then
             LDA  must be at least  max( 1, m ),  when  SIDE = &#39;R&#39; or &#39;r&#39;
             then LDA must be at least max( 1, n ).
             Unchanged on exit.

    B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Level 3 Blas routine.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Input matrix A</td></tr>
<tr><td>B[:, :]</td><td>Input matrix B</td></tr>
<tr><td>alpha</td><td>Factor alpha</td></tr>
<tr><td>right</td><td>True if A is right multiplication</td></tr>
<tr><td>upper</td><td>True if A is upper triangular</td></tr>
<tr><td>trans</td><td>True if op(A) means transposed(A)</td></tr>
<tr><td>unitTriangular</td><td>True if A is unit triangular, i.e., all diagonal elements of A are equal to 1</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(B, 1), size(B, 2)]</td><td>Matrix Bout=alpha*op( A )*B, or B := alpha*B*op( A )</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dorghr<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.LAPACK.dgeevI.png" alt="Modelica.Math.Matrices.LAPACK.dorghr" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.LAPACK.dorghr"></a><a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</a>.dorghr</h2>
<p>
<span class="ModelicaDescription">Generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    DORGHR generates a real orthogonal matrix Q which is defined as the
    product of IHI-ILO elementary reflectors of order N, as returned by
    DGEHRD:

    Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix Q. N &gt;= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            ILO and IHI must have the same values as in the previous call
            of DGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by DGEHRD.
            On exit, the N-by-N orthogonal matrix Q.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,N).

    TAU     (input) DOUBLE PRECISION array, dimension (N-1)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEHRD.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK &gt;= IHI-ILO.
            For optimum performance LWORK &gt;= (IHI-ILO)*NB, where NB is
            the optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Square matrix with the elementary reflectors</td></tr>
<tr><td>ilo</td><td>lowest index where the original matrix had been Hessenbergform - ilo must have the same value as in the previous call of DGEHRD</td></tr>
<tr><td>ihi</td><td>highest index where the original matrix had been Hessenbergform - ihi must have the same value as in the previous call of DGEHRD</td></tr>
<tr><td>tau[max(0, size(A, 1) - 1)]</td><td>scalar factors of the elementary reflectors</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Aout[size(A, 1), size(A, 2)]</td><td>Orthogonal matrix as a result of elementary reflectors</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<address>
<a href="http://www.3ds.com/">Automatically generated</a> Fri Oct 02 11:08:25 2015.
</address>
</body>
</html>
