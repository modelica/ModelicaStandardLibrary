<HTML>
<HEAD><META name="HTML-Generator" content="Dymola"><TITLE>Modelica</TITLE></HEAD>
<BODY><P>
<H2><A NAME="Modelica.Blocks.Sources"></A><A HREF="Modelica_Blocks.html#Modelica.Blocks"
>Modelica.Blocks</A>.Sources</H2>
<B>Signal source blocks generating Real, Integer and Boolean signals</B>
<P>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Clock"
><IMG SRC="Modelica.Blocks.Sources.ClockI.png" ALT="Modelica.Blocks.Sources.Clock" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Constant"
><IMG SRC="Modelica.Blocks.Sources.ConstantI.png" ALT="Modelica.Blocks.Sources.Constant" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Step"
><IMG SRC="Modelica.Blocks.Sources.StepI.png" ALT="Modelica.Blocks.Sources.Step" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Ramp"
><IMG SRC="Modelica.Blocks.Sources.RampI.png" ALT="Modelica.Blocks.Sources.Ramp" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Sine"
><IMG SRC="Modelica.Blocks.Sources.SineI.png" ALT="Modelica.Blocks.Sources.Sine" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.ExpSine"
><IMG SRC="Modelica.Blocks.Sources.ExpSineI.png" ALT="Modelica.Blocks.Sources.ExpSine" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Exponentials"
><IMG SRC="Modelica.Blocks.Sources.ExponentialsI.png" ALT="Modelica.Blocks.Sources.Exponentials" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Pulse"
><IMG SRC="Modelica.Blocks.Sources.PulseI.png" ALT="Modelica.Blocks.Sources.Pulse" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.SawTooth"
><IMG SRC="Modelica.Blocks.Sources.SawToothI.png" ALT="Modelica.Blocks.Sources.SawTooth" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Trapezoid"
><IMG SRC="Modelica.Blocks.Sources.TrapezoidI.png" ALT="Modelica.Blocks.Sources.Trapezoid" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.KinematicPTP"
><IMG SRC="Modelica.Blocks.Sources.KinematicPTPI.png" ALT="Modelica.Blocks.Sources.KinematicPTP" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.TimeTable"
><IMG SRC="Modelica.Blocks.Sources.TimeTableI.png" ALT="Modelica.Blocks.Sources.TimeTable" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.BooleanConstant"
><IMG SRC="Modelica.Blocks.Sources.BooleanConstantI.png" ALT="Modelica.Blocks.Sources.BooleanConstant" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.BooleanStep"
><IMG SRC="Modelica.Blocks.Sources.BooleanStepI.png" ALT="Modelica.Blocks.Sources.BooleanStep" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.BooleanPulse"
><IMG SRC="Modelica.Blocks.Sources.BooleanPulseI.png" ALT="Modelica.Blocks.Sources.BooleanPulse" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.SampleTrigger"
><IMG SRC="Modelica.Blocks.Sources.SampleTriggerI.png" ALT="Modelica.Blocks.Sources.SampleTrigger" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.IntegerConstant"
><IMG SRC="Modelica.Blocks.Sources.IntegerConstantI.png" ALT="Modelica.Blocks.Sources.IntegerConstant" WIDTH=80  HEIGHT=80 ></A>
<A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.IntegerStep"
><IMG SRC="Modelica.Blocks.Sources.IntegerStepI.png" ALT="Modelica.Blocks.Sources.IntegerStep" WIDTH=80  HEIGHT=80 ></A>
<P><P>
<H3>Information</H3>
<PRE></pre>
<p>
This package contains <b>source</b> components, i.e., blocks which
have only output signals. These blocks are used as signal generators.
</p>

<p>The following <b>sources</b> are provided to generate <b>Real</b> signals:</p>

<pre>
  <b>Clock</b>             Generate actual time.
  <b>Constant</b>          Generate constant signals.
  <b>Step</b>              Generate step signals.
  <b>Ramp</b>              Generate ramp signals.
  <b>Sine</b>              Generate sine signals.
  <b>ExpSine</b>           Generate exponentially damped sine signals.
  <b>Exponentials</b>      Generate a rising and falling exponential signal.
  <b>Pulse</b>             Generate pulse signals.
  <b>SawTooth</b>          Generate sawtooth signals.
  <b>Trapezoid</b>         Generate trapezoidal signals.
  <b>KinematicPTP</b>      Generate an acceleration signal to move as fast as
                    possible along a distance within given kinematic constraints.
  <b>TimeTable</b>         Generate a (possibly discontinuous) signal by
                    linear interpolation in a table.
</pre>

<p>The following <b>sources</b> are provided to generate <b>Boolean</b> signals:</p>

<pre>
  <b>BooleanConstant</b>   Generate constant signals.
  <b>BooleanStep</b>       Generate step signals.
  <b>BooleanPulse</b>      Generate pulse signals.
  <b>SampleTrigger</b>     Generate sample triggers.
</pre>

<p>The following <b>sources</b> are provided to generate <b>Integer</b> signals:</p>

<pre>
  <b>IntegerConstant</b>   Generate constant signals.
  <b>IntegerStep</b>       Generate step signals.
</pre>

<p>
All sources are <b>vectorized</b>. This means that the output
is a vector of signals. The number of outputs is in correspondance
to the lenght of the parameter vectors defining the signals. Examples:
</p>

<pre>
    // output.signal[1] = 2*sin(2*pi*2.1);
    // output.signal[2] = 3*sin(2*pi*2.3);
    Modelica.Blocks.Sources.Sine s1(amplitude={2,3}, freqHz={2.1,2.2});

    // output.signal[1] = 3*sin(2*pi*2.1);
    // output.signal[2] = 3*sin(2*pi*2.3);
    Modelica.Blocks.Sources.Sine s2(amplitude={3}, freqHz={2.1,2.3});
</pre>

<p>
The first instance s1 consists of two sinusoidal output signals
with the given amplitudes and frequencies. The second instance s2
consists also of two sinusoidal output signals. Since the
amplitudes are the same for all output signals of s2, this value
has to be provided only once. This approached is used for all
parameters of signal sources: Whenever only a scalar value is
provided for one parameter, then this value is used for all output
signals.
</p>

<p>
All Real source signals (with the exception of the Constant source)
have at least the following two parameters:
</p>

<pre>
   <b>offset</b>       Value which is added to all signal values.
   <b>startTime</b>    Start time of signal. For time < startTime,
                the output is set to offset.
</pre>

<p>
The <b>offset</b> parameter is especially useful in order to shift
the corresponding source, such that at initial time the system
is stationary. To determine the corresponding value of offset,
usually requires a trimming calculation.
</p>

<dl>
<dt><b>Main Author:</b>
<dd><a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a><br>
    Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    email: <A HREF="mailto:Martin.Otter@dlr.de">Martin.Otter@dlr.de</A><br>
</dl>
<br>

<p><b>Release Notes:</b></p>
<ul>
<li><i>October 21, 2002</i>
       by <a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a>
       and <a href="http://www.robotic.dlr.de/Christian.Schweiger/">Christian Schweiger</a>:<br>
       Integer sources added. Step, TimeTable and BooleanStep slightly changed
       (see <a href="../Documentation/ChangeNotes.html">Change Notes</a>).</li>

<li><i>November 8, 1999</i>
       by <a href="http://www.eas.iis.fhg.de/~clauss/">Christoph Clau&szlig;</a>,
       <a href="http://www.eas.iis.fhg.de/~schneider/">Andr&eacute; Schneider</a> and
       <a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a>:<br>
       New sources: Exponentials, TimeTable. Trapezoid slightly enhanced
       (nperiod=-1 is an infinite number of periods).</li>

<li><i>October 31, 1999</i>
       by <a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a>,
       <a href="http://www.eas.iis.fhg.de/~clauss/">Christoph Clau&szlig;</a> and
       <a href="http://www.eas.iis.fhg.de/~schneider/">Andr&eacute; Schneider</a>:
       All sources vectorized. New sources: ExpSine, Trapezoid,
       BooleanConstant, BooleanStep, BooleanPulse, SampleTrigger.
       Improved documentation, especially detailed description of
       signals in diagram layer.</li>

<li><i>June 29, 1999</i>
       by <a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
<br>


<p><b>Copyright &copy; 1999-2002, Modelica Association, DLR and Fraunhofer-Gesellschaft.</b></p>

<p><i>
The Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b> in the documentation of package
Modelica in file "Modelica/package.mo".
</i></p>
<pre>
</PRE><P>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.IntegerStepI.png" ALT="Modelica.Blocks.Sources.IntegerStep" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.IntegerStep"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.IntegerStep</H2>
<B>Generate step signals of type Integer</B><p>
<IMG SRC="Modelica.Blocks.Sources.IntegerStepD.png" ALT="Modelica.Blocks.Sources.IntegerStep">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>height[:]</TD><TD>{1}</TD><TD>Heights of steps</TD></TR>
<TR><TD>offset[:]</TD><TD>{0}</TD><TD>offset of output signal</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> IntegerStep <font color="darkgreen">&quot;Generate step signals of type Integer&quot;</font> 
  <font color="blue">parameter </font>Integer height[:]={1} <font color="darkgreen">&quot;Heights of steps&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.IntegerSignalSource"
>Interfaces.IntegerSignalSource</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(height, 1); <font color="red">size</font>(
        offset, 1); <font color="red">size</font>(startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">parameter </font>Integer p_height[nout]=(<font color="blue">if </font><font color="red">size</font>(height, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      height[1]<font color="blue"> else </font>height);
  <font color="blue">parameter </font>Integer p_offset[nout]=(<font color="blue">if </font><font color="red">size</font>(offset, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      offset[1]<font color="blue"> else </font>offset);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    outPort.signal[i] = p_offset[i] + (<font color="blue">if </font>time &lt; p_startTime[i]<font color="blue"> then </font>0<font color="blue"> else </font>
      p_height[i]);
  <font color="blue">end for</font>;
<font color="blue">end </font>IntegerStep;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.BooleanStepI.png" ALT="Modelica.Blocks.Sources.BooleanStep" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.BooleanStep"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.BooleanStep</H2>
<B>Generate step signals of type Boolean</B><p>
<IMG SRC="Modelica.Blocks.Sources.BooleanStepD.png" ALT="Modelica.Blocks.Sources.BooleanStep">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Time instants of steps [s]</TD></TR>
<TR><TD>startValue[size(startTime, 1)]</TD><TD>fill(false, size(startTime, 1))</TD><TD>Output before startTime</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> BooleanStep <font color="darkgreen">&quot;Generate step signals of type Boolean&quot;</font> 
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Time instants of steps&quot;</font>;
  <font color="blue">parameter </font>Boolean startValue[<font color="red">size</font>(startTime, 1)]=<font color="red">fill</font>(false, <font color="red">size</font>(startTime, 
      1)) <font color="darkgreen">&quot;Output before startTime&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanSignalSource"
>Interfaces.BooleanSignalSource</A>(<font color="blue">final </font>nout=<font color="red">size</font>(startTime, 1));
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    outPort.signal[i] = <font color="blue">if </font>time &gt;= startTime[i]<font color="blue"> then </font><font color="blue">not </font>startValue[i]<font color="blue"> else </font>
      startValue[i];
  <font color="blue">end for</font>;
<font color="blue">end </font>BooleanStep;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.SineI.png" ALT="Modelica.Blocks.Sources.Sine" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.Sine"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.Sine</H2>
<B>Generate sine signals</B><p>
<IMG SRC="Modelica.Blocks.Sources.SineD.png" ALT="Modelica.Blocks.Sources.Sine">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>amplitude[:]</TD><TD>{1}</TD><TD>Amplitudes of sine waves</TD></TR>
<TR><TD>freqHz[:]</TD><TD>{1}</TD><TD>Frequencies of sine waves [Hz]</TD></TR>
<TR><TD>phase[:]</TD><TD>{0}</TD><TD>Phases of sine waves [rad]</TD></TR>
<TR><TD>offset[:]</TD><TD>{0}</TD><TD>Offsets of output signals</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> Sine <font color="darkgreen">&quot;Generate sine signals&quot;</font> 
  <font color="blue">parameter </font>Real amplitude[:]={1} <font color="darkgreen">&quot;Amplitudes of sine waves&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>SI.Frequency</A> freqHz[:]={1} <font color="darkgreen">&quot;Frequencies of sine waves&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phase[:]={0} <font color="darkgreen">&quot;Phases of sine waves&quot;</font>;
  <font color="blue">parameter </font>Real offset[:]={0} <font color="darkgreen">&quot;Offsets of output signals&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Output = offset for time &lt; startTime&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(amplitude, 1); <font color="red">size</font>(freqHz, 1); <font color="red">size</font>(
        phase, 1); <font color="red">size</font>(offset, 1); <font color="red">size</font>(startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">constant </font>Real pi=Modelica.Constants.pi;
  <font color="blue">parameter </font>Real p_amplitude[nout]=(<font color="blue">if </font><font color="red">size</font>(amplitude, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      amplitude[1]<font color="blue"> else </font>amplitude);
  <font color="blue">parameter </font>Real p_freqHz[nout]=(<font color="blue">if </font><font color="red">size</font>(freqHz, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*freqHz
      [1]<font color="blue"> else </font>freqHz);
  <font color="blue">parameter </font>Real p_phase[nout]=(<font color="blue">if </font><font color="red">size</font>(phase, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*phase[1]<font color="blue">
       else </font>phase);
  <font color="blue">parameter </font>Real p_offset[nout]=(<font color="blue">if </font><font color="red">size</font>(offset, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*offset
      [1]<font color="blue"> else </font>offset);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    outPort.signal[i] = p_offset[i] + (<font color="blue">if </font>time &lt; p_startTime[i]<font color="blue"> then </font>0<font color="blue"> else </font>
      p_amplitude[i]*<font color="red">Modelica.Math.sin</font>(2*pi*p_freqHz[i]*(time - p_startTime[i])
       + p_phase[i]));
  <font color="blue">end for</font>;
<font color="blue">end </font>Sine;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.ClockI.png" ALT="Modelica.Blocks.Sources.Clock" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.Clock"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.Clock</H2>
<B>Generate actual time signals </B><p>
<IMG SRC="Modelica.Blocks.Sources.ClockD.png" ALT="Modelica.Blocks.Sources.Clock">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>offset[:]</TD><TD>{0}</TD><TD>Offsets of output signals</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> Clock <font color="darkgreen">&quot;Generate actual time signals &quot;</font> 
  <font color="blue">parameter </font>Real offset[:]={0} <font color="darkgreen">&quot;Offsets of output signals&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Output = offset for time &lt; startTime&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(offset, 1); <font color="red">size</font>(startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">parameter </font>Real p_offset[nout]=(<font color="blue">if </font><font color="red">size</font>(offset, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*offset
      [1]<font color="blue"> else </font>offset);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
  <font color="darkgreen"></font>
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    outPort.signal[i] = p_offset[i] + (<font color="blue">if </font>time &lt; p_startTime[i]<font color="blue"> then </font>0<font color="blue"> else </font>
      time - p_startTime[i]);
  <font color="blue">end for</font>;
<font color="blue">end </font>Clock;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.ConstantI.png" ALT="Modelica.Blocks.Sources.Constant" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.Constant"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.Constant</H2>
<B>Generate constant signals of type Real</B><p>
<IMG SRC="Modelica.Blocks.Sources.ConstantD.png" ALT="Modelica.Blocks.Sources.Constant">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>k[:]</TD><TD>{1}</TD><TD>Constant output values</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> Constant <font color="darkgreen">&quot;Generate constant signals of type Real&quot;</font> 
  <font color="blue">parameter </font>Real k[:]={1} <font color="darkgreen">&quot;Constant output values&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=<font color="red">size</font>(k, 1));
  <font color="darkgreen"></font>
<font color="blue">equation </font>
  outPort.signal = k;
<font color="blue">end </font>Constant;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.StepI.png" ALT="Modelica.Blocks.Sources.Step" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.Step"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.Step</H2>
<B>Generate step signals of type Real</B><p>
<IMG SRC="Modelica.Blocks.Sources.StepD.png" ALT="Modelica.Blocks.Sources.Step">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>height[:]</TD><TD>{1}</TD><TD>Heights of steps</TD></TR>
<TR><TD>offset[:]</TD><TD>{0}</TD><TD>offset of output signal</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> Step <font color="darkgreen">&quot;Generate step signals of type Real&quot;</font> 
  <font color="blue">parameter </font>Real height[:]={1} <font color="darkgreen">&quot;Heights of steps&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SignalSource"
>Interfaces.SignalSource</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(height, 1); <font color="red">size</font>(offset, 1); <font color="red">
        size</font>(startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">parameter </font>Real p_height[nout]=(<font color="blue">if </font><font color="red">size</font>(height, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*height
      [1]<font color="blue"> else </font>height);
  <font color="blue">parameter </font>Real p_offset[nout]=(<font color="blue">if </font><font color="red">size</font>(offset, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*offset
      [1]<font color="blue"> else </font>offset);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    outPort.signal[i] = p_offset[i] + (<font color="blue">if </font>time &lt; p_startTime[i]<font color="blue"> then </font>0<font color="blue"> else </font>
      p_height[i]);
  <font color="blue">end for</font>;
<font color="blue">end </font>Step;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.RampI.png" ALT="Modelica.Blocks.Sources.Ramp" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.Ramp"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.Ramp</H2>
<B>Generate ramp signals</B><p>
<IMG SRC="Modelica.Blocks.Sources.RampD.png" ALT="Modelica.Blocks.Sources.Ramp">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>height[:]</TD><TD>{1}</TD><TD>Heights of ramps</TD></TR>
<TR><TD>duration[:]</TD><TD>{2}</TD><TD>Durations of ramps</TD></TR>
<TR><TD>offset[:]</TD><TD>{0}</TD><TD>Offsets of output signals</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> Ramp <font color="darkgreen">&quot;Generate ramp signals&quot;</font> 
  <font color="blue">parameter </font>Real height[:]={1} <font color="darkgreen">&quot;Heights of ramps&quot;</font>;
  <font color="blue">parameter </font>Real duration[:](min=Modelica.Constants.small) = {2} <font color="darkgreen">
    &quot;Durations of ramps&quot;</font>;
  <font color="blue">parameter </font>Real offset[:]={0} <font color="darkgreen">&quot;Offsets of output signals&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Output = offset for time &lt; startTime&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(height, 1); <font color="red">size</font>(duration, 1); <font color="red">size</font>(
        offset, 1); <font color="red">size</font>(startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">parameter </font>Real p_height[nout]=(<font color="blue">if </font><font color="red">size</font>(height, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*height
      [1]<font color="blue"> else </font>height);
  <font color="blue">parameter </font>Real p_duration[nout]=(<font color="blue">if </font><font color="red">size</font>(duration, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      duration[1]<font color="blue"> else </font>duration);
  <font color="blue">parameter </font>Real p_offset[nout]=(<font color="blue">if </font><font color="red">size</font>(offset, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*offset
      [1]<font color="blue"> else </font>offset);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
  <font color="darkgreen"></font>
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    outPort.signal[i] = p_offset[i] + (<font color="blue">if </font>time &lt; p_startTime[i]<font color="blue"> then </font>0<font color="blue"> else </font><font color="blue">if </font>
      time &lt; (p_startTime[i] + p_duration[i])<font color="blue"> then </font>(time - p_startTime[i])*
      p_height[i]/p_duration[i]<font color="blue"> else </font>p_height[i]);
  <font color="blue">end for</font>;
<font color="blue">end </font>Ramp;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.ExpSineI.png" ALT="Modelica.Blocks.Sources.ExpSine" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.ExpSine"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.ExpSine</H2>
<B>Generate exponentially damped sine signals</B><p>
<IMG SRC="Modelica.Blocks.Sources.ExpSineD.png" ALT="Modelica.Blocks.Sources.ExpSine">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>amplitude[:]</TD><TD>{1}</TD><TD>Amplitudes of sine waves</TD></TR>
<TR><TD>freqHz[:]</TD><TD>{2}</TD><TD>Frequencies of sine waves [Hz]</TD></TR>
<TR><TD>phase[:]</TD><TD>{0}</TD><TD>Phases of sine waves [rad]</TD></TR>
<TR><TD>damping[:]</TD><TD>{1}</TD><TD>Damping coefficients of sine waves [s-1]</TD></TR>
<TR><TD>offset[:]</TD><TD>{0}</TD><TD>Offsets of output signals</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> ExpSine <font color="darkgreen">&quot;Generate exponentially damped sine signals&quot;</font> 
  <font color="blue">parameter </font>Real amplitude[:]={1} <font color="darkgreen">&quot;Amplitudes of sine waves&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>SI.Frequency</A> freqHz[:]={2} <font color="darkgreen">&quot;Frequencies of sine waves&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phase[:]={0} <font color="darkgreen">&quot;Phases of sine waves&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Damping"
>SI.Damping</A> damping[:]={1} <font color="darkgreen">&quot;Damping coefficients of sine waves&quot;</font>;
  <font color="blue">parameter </font>Real offset[:]={0} <font color="darkgreen">&quot;Offsets of output signals&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Output = offset for time &lt; startTime&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(amplitude, 1); <font color="red">size</font>(freqHz, 1); <font color="red">size</font>(
        phase, 1); <font color="red">size</font>(damping, 1); <font color="red">size</font>(offset, 1); <font color="red">size</font>(startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">constant </font>Real pi=Modelica.Constants.pi;
  <font color="blue">parameter </font>Real p_amplitude[nout]=(<font color="blue">if </font><font color="red">size</font>(amplitude, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      amplitude[1]<font color="blue"> else </font>amplitude);
  <font color="blue">parameter </font>Real p_freqHz[nout]=(<font color="blue">if </font><font color="red">size</font>(freqHz, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*freqHz
      [1]<font color="blue"> else </font>freqHz);
  <font color="blue">parameter </font>Real p_phase[nout]=(<font color="blue">if </font><font color="red">size</font>(phase, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*phase[1]<font color="blue">
       else </font>phase);
  <font color="blue">parameter </font>Real p_damping[nout]=(<font color="blue">if </font><font color="red">size</font>(damping, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      damping[1]<font color="blue"> else </font>damping);
  <font color="blue">parameter </font>Real p_offset[nout]=(<font color="blue">if </font><font color="red">size</font>(offset, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*offset
      [1]<font color="blue"> else </font>offset);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    outPort.signal[i] = p_offset[i] + (<font color="blue">if </font>time &lt; p_startTime[i]<font color="blue"> then </font>0<font color="blue"> else </font>
      p_amplitude[i]*<font color="red">Modelica.Math.exp</font>(-(time - p_startTime[i])*p_damping[i])*<font color="red">
      Modelica.Math.sin</font>(2*pi*p_freqHz[i]*(time - p_startTime[i]) + p_phase[i]))
      ;
  <font color="blue">end for</font>;
<font color="blue">end </font>ExpSine;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.ExponentialsI.png" ALT="Modelica.Blocks.Sources.Exponentials" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.Exponentials"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.Exponentials</H2>
<B>Generate a rising and falling exponential signal</B><p>
<IMG SRC="Modelica.Blocks.Sources.ExponentialsD.png" ALT="Modelica.Blocks.Sources.Exponentials">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>outMax[:]</TD><TD>{1}</TD><TD>Height of output for infinite riseTime</TD></TR>
<TR><TD>riseTime[:]</TD><TD>{0.5}</TD><TD>Rise time [s]</TD></TR>
<TR><TD>riseTimeConst[:]</TD><TD>{0.1}</TD><TD>Rise time constant [s]</TD></TR>
<TR><TD>fallTimeConst[:]</TD><TD>riseTimeConst</TD><TD>Fall time constant [s]</TD></TR>
<TR><TD>offset[:]</TD><TD>{0}</TD><TD>Offsets of output signals</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> Exponentials <font color="darkgreen">&quot;Generate a rising and falling exponential signal&quot;</font>
   
  <font color="blue">parameter </font>Real outMax[:]={1} <font color="darkgreen">&quot;Height of output for infinite riseTime&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> riseTime[:](min=0) = {0.5} <font color="darkgreen">&quot;Rise time&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> riseTimeConst[:](min=Modelica.Constants.small) = {0.1} <font color="darkgreen">
    &quot;Rise time constant&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> fallTimeConst[:](min=Modelica.Constants.small) = riseTimeConst <font color="darkgreen">
    &quot;Fall time constant&quot;</font>;
  <font color="blue">parameter </font>Real offset[:]={0} <font color="darkgreen">&quot;Offsets of output signals&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Output = offset for time &lt; startTime&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(outMax, 1); <font color="red">size</font>(riseTime, 1); <font color="red">size</font>(
        riseTimeConst, 1); <font color="red">size</font>(fallTimeConst, 1); <font color="red">size</font>(offset, 1); <font color="red">size</font>(
        startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">parameter </font>Real p_outMax[nout]=(<font color="blue">if </font><font color="red">size</font>(outMax, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*outMax
      [1]<font color="blue"> else </font>outMax);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_riseTime[nout]=(<font color="blue">if </font><font color="red">size</font>(riseTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      riseTime[1]<font color="blue"> else </font>riseTime);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_riseTimeConst[nout]=(<font color="blue">if </font><font color="red">size</font>(riseTimeConst, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(
      nout)*riseTimeConst[1]<font color="blue"> else </font>riseTimeConst);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_fallTimeConst[nout]=(<font color="blue">if </font><font color="red">size</font>(fallTimeConst, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(
      nout)*fallTimeConst[1]<font color="blue"> else </font>fallTimeConst);
  <font color="blue">parameter </font>Real p_offset[nout]=(<font color="blue">if </font><font color="red">size</font>(offset, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*offset
      [1]<font color="blue"> else </font>offset);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
  Real y_riseTime[nout];
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    y_riseTime[i] = p_outMax[i]*(1 - <font color="red">Modelica.Math.exp</font>(-p_riseTime[i]/
      p_riseTimeConst[i]));
    outPort.signal[i] = p_offset[i] + (<font color="blue">if </font>(time &lt; p_startTime[i])<font color="blue"> then </font>0<font color="blue"> else </font><font color="blue">
      if </font>(time &lt; (p_startTime[i] + p_riseTime[i]))<font color="blue"> then </font>p_outMax[i]*(1 - <font color="red">
      Modelica.Math.exp</font>(-(time - p_startTime[i])/p_riseTimeConst[i]))<font color="blue"> else </font>
      y_riseTime[i]*<font color="red">Modelica.Math.exp</font>(-(time - p_startTime[i] - p_riseTime[i])/
      p_fallTimeConst[i]));
  <font color="blue">end for</font>;
  <font color="darkgreen"></font>
<font color="blue">end </font>Exponentials;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.PulseI.png" ALT="Modelica.Blocks.Sources.Pulse" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.Pulse"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.Pulse</H2>
<B>Generate pulse signals of type Real</B><p>
<IMG SRC="Modelica.Blocks.Sources.PulseD.png" ALT="Modelica.Blocks.Sources.Pulse">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>amplitude[:]</TD><TD>{1}</TD><TD>Amplitudes of pulses</TD></TR>
<TR><TD>width[:]</TD><TD>{50}</TD><TD>Widths of pulses in % of periods</TD></TR>
<TR><TD>period[:]</TD><TD>{1}</TD><TD>Times for one period [s]</TD></TR>
<TR><TD>offset[:]</TD><TD>{0}</TD><TD>Offsets of output signals</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> Pulse <font color="darkgreen">&quot;Generate pulse signals of type Real&quot;</font> 
  <font color="blue">parameter </font>Real amplitude[:]={1} <font color="darkgreen">&quot;Amplitudes of pulses&quot;</font>;
  <font color="blue">parameter </font>Real width[:](
    <font color="blue">final </font>min=Modelica.Constants.small, 
    <font color="blue">final </font>max=100) = {50} <font color="darkgreen">&quot;Widths of pulses in % of periods&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> period[:](<font color="blue">final </font>min=Modelica.Constants.small) = {1} <font color="darkgreen">
    &quot;Times for one period&quot;</font>;
  <font color="blue">parameter </font>Real offset[:]={0} <font color="darkgreen">&quot;Offsets of output signals&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Output = offset for time &lt; startTime&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(amplitude, 1); <font color="red">size</font>(width, 1); <font color="red">size</font>(
        period, 1); <font color="red">size</font>(offset, 1); <font color="red">size</font>(startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">parameter </font>Real p_amplitude[nout]=(<font color="blue">if </font><font color="red">size</font>(amplitude, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      amplitude[1]<font color="blue"> else </font>amplitude);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_period[nout]=(<font color="blue">if </font><font color="red">size</font>(period, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*period[1]<font color="blue">
       else </font>period);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_width[nout]=<font color="red">diagonal</font>(p_period)*(<font color="blue">if </font><font color="red">size</font>(width, 1) == 1<font color="blue"> then </font><font color="red">ones</font>
      (nout)*width[1]<font color="blue"> else </font>width)/100 <font color="darkgreen">&quot;Width of one pulse&quot;</font>;
  <font color="blue">parameter </font>Real p_offset[nout]=(<font color="blue">if </font><font color="red">size</font>(offset, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*offset
      [1]<font color="blue"> else </font>offset);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> T0[nout](<font color="blue">final </font>start=p_startTime) <font color="darkgreen">&quot;Start time of current period&quot;</font>;
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    <font color="blue">when </font><font color="red">sample</font>(p_startTime[i], p_period[i])<font color="blue"> then</font>
      T0[i] = time;
    <font color="blue">end when</font>;
    outPort.signal[i] = p_offset[i] + (<font color="blue">if </font>time &lt; p_startTime[i]<font color="blue"> or </font>time &gt;= T0[i
      ] + p_width[i]<font color="blue"> then </font>0<font color="blue"> else </font>p_amplitude[i]);
  <font color="blue">end for</font>;
<font color="blue">end </font>Pulse;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.SawToothI.png" ALT="Modelica.Blocks.Sources.SawTooth" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.SawTooth"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.SawTooth</H2>
<B>Generate saw tooth signals</B><p>
<IMG SRC="Modelica.Blocks.Sources.SawToothD.png" ALT="Modelica.Blocks.Sources.SawTooth">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>amplitude[:]</TD><TD>{1}</TD><TD>Amplitudes of saw tooths</TD></TR>
<TR><TD>period[:]</TD><TD>{1}</TD><TD>Times for one period [s]</TD></TR>
<TR><TD>offset[:]</TD><TD>{0}</TD><TD>Offsets of output signals</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> SawTooth <font color="darkgreen">&quot;Generate saw tooth signals&quot;</font> 
  <font color="blue">parameter </font>Real amplitude[:]={1} <font color="darkgreen">&quot;Amplitudes of saw tooths&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> period[:](<font color="blue">final </font>min=Modelica.Constants.small) = {1} <font color="darkgreen">
    &quot;Times for one period&quot;</font>;
  <font color="blue">parameter </font>Real offset[:]={0} <font color="darkgreen">&quot;Offsets of output signals&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Output = offset for time &lt; startTime&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(amplitude, 1); <font color="red">size</font>(period, 1); <font color="red">size</font>(
        offset, 1); <font color="red">size</font>(startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">parameter </font>Real p_amplitude[nout]=(<font color="blue">if </font><font color="red">size</font>(amplitude, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      amplitude[1]<font color="blue"> else </font>amplitude);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_period[nout]=(<font color="blue">if </font><font color="red">size</font>(period, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*period[1]<font color="blue">
       else </font>period);
  <font color="blue">parameter </font>Real p_offset[nout]=(<font color="blue">if </font><font color="red">size</font>(offset, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*offset
      [1]<font color="blue"> else </font>offset);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> T0[nout](<font color="blue">final </font>start=p_startTime) <font color="darkgreen">&quot;Start time of current period&quot;</font>;
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    <font color="blue">when </font><font color="red">sample</font>(p_startTime[i], p_period[i])<font color="blue"> then</font>
      T0[i] = time;
    <font color="blue">end when</font>;
    outPort.signal[i] = p_offset[i] + (<font color="blue">if </font>time &lt; p_startTime[i]<font color="blue"> then </font>0<font color="blue"> else </font>(
      p_amplitude[i]/p_period[i])*(time - T0[i]));
  <font color="blue">end for</font>;
<font color="blue">end </font>SawTooth;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.TrapezoidI.png" ALT="Modelica.Blocks.Sources.Trapezoid" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.Trapezoid"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.Trapezoid</H2>
<B>Generate trapezoidal signals of type Real</B><p>
<IMG SRC="Modelica.Blocks.Sources.TrapezoidD.png" ALT="Modelica.Blocks.Sources.Trapezoid">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>amplitude[:]</TD><TD>{1}</TD><TD>Amplitudes of trapezoids</TD></TR>
<TR><TD>rising[:]</TD><TD>{0}</TD><TD>Rising durations of trapezoids [s]</TD></TR>
<TR><TD>width[:]</TD><TD>{0.5}</TD><TD>Width durations of trapezoids [s]</TD></TR>
<TR><TD>falling[:]</TD><TD>{0}</TD><TD>Falling durations of trapezoids [s]</TD></TR>
<TR><TD>period[:]</TD><TD>{1}</TD><TD>Time for one period [s]</TD></TR>
<TR><TD>nperiod[:]</TD><TD>{-1}</TD><TD>Number of periods (&lt; 0 means infinite number of periods)</TD></TR>
<TR><TD>offset[:]</TD><TD>{0}</TD><TD>Offsets of output signals</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> Trapezoid <font color="darkgreen">&quot;Generate trapezoidal signals of type Real&quot;</font> 
  <font color="blue">parameter </font>Real amplitude[:]={1} <font color="darkgreen">&quot;Amplitudes of trapezoids&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> rising[:](<font color="blue">final </font>min=0) = {0} <font color="darkgreen">&quot;Rising durations of trapezoids&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> width[:](<font color="blue">final </font>min=0) = {0.5} <font color="darkgreen">&quot;Width durations of trapezoids&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> falling[:](<font color="blue">final </font>min=0) = {0} <font color="darkgreen">&quot;Falling durations of trapezoids&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> period[:](<font color="blue">final </font>min=Modelica.Constants.small) = {1} <font color="darkgreen">
    &quot;Time for one period&quot;</font>;
  <font color="blue">parameter </font>Integer nperiod[:]={-1} <font color="darkgreen">
    &quot;Number of periods (&lt; 0 means infinite number of periods)&quot;</font>;
  <font color="blue">parameter </font>Real offset[:]={0} <font color="darkgreen">&quot;Offsets of output signals&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Output = offset for time &lt; startTime&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(amplitude, 1); <font color="red">size</font>(rising, 1); <font color="red">size</font>(
        width, 1); <font color="red">size</font>(falling, 1); <font color="red">size</font>(period, 1); <font color="red">size</font>(nperiod, 1); <font color="red">size</font>(
        offset, 1); <font color="red">size</font>(startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">parameter </font>Real p_amplitude[nout]=(<font color="blue">if </font><font color="red">size</font>(amplitude, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      amplitude[1]<font color="blue"> else </font>amplitude);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> T_rising[nout]=(<font color="blue">if </font><font color="red">size</font>(rising, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*rising[1]<font color="blue">
       else </font>rising) <font color="darkgreen">&quot;End time of rising phase within one period&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> T_width[nout]=T_rising + (<font color="blue">if </font><font color="red">size</font>(width, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      width[1]<font color="blue"> else </font>width) <font color="darkgreen">&quot;End time of width phase within one period&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> T_falling[nout]=T_width + (<font color="blue">if </font><font color="red">size</font>(falling, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout
      )*falling[1]<font color="blue"> else </font>falling) <font color="darkgreen">&quot;End time of falling phase within one period&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_period[nout]=(<font color="blue">if </font><font color="red">size</font>(period, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*period[1]<font color="blue">
       else </font>period) <font color="darkgreen">&quot;Duration of one period&quot;</font>;
  <font color="blue">parameter </font>Real p_offset[nout]=(<font color="blue">if </font><font color="red">size</font>(offset, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*offset
      [1]<font color="blue"> else </font>offset);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> T0[nout](<font color="blue">final </font>start=p_startTime) <font color="darkgreen">&quot;Start time of current period&quot;</font>;
  Integer counter[nout](start=(<font color="blue">if </font><font color="red">size</font>(nperiod, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*nperiod
        [1]<font color="blue"> else </font>nperiod)) <font color="darkgreen">&quot;Period counter&quot;</font>;
  Integer counter2[nout](start=(<font color="blue">if </font><font color="red">size</font>(nperiod, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
        nperiod[1]<font color="blue"> else </font>nperiod));
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    <font color="blue">when </font><font color="red">pre</font>(counter2[i]) &lt;&gt; 0<font color="blue"> and </font><font color="red">sample</font>(p_startTime[i], p_period[i])<font color="blue"> then</font>
      T0[i] = time;
      counter2[i] = <font color="red">pre</font>(counter[i]);
      counter[i] = <font color="red">pre</font>(counter[i]) - (<font color="blue">if </font><font color="red">pre</font>(counter[i]) &gt; 0<font color="blue"> then </font>1<font color="blue"> else </font>0);
    <font color="blue">end when</font>;
    outPort.signal[i] = p_offset[i] + (<font color="blue">if </font>(time &lt; p_startTime[i]<font color="blue"> or </font>counter2[i]
       == 0<font color="blue"> or </font>time &gt;= T0[i] + T_falling[i])<font color="blue"> then </font>0<font color="blue"> else </font><font color="blue">if </font>(time &lt; T0[i] + 
      T_rising[i])<font color="blue"> then </font>(time - T0[i])*p_amplitude[i]/T_rising[i]<font color="blue"> else </font><font color="blue">if </font>(time
       &lt; T0[i] + T_width[i])<font color="blue"> then </font>p_amplitude[i]<font color="blue"> else </font>(T0[i] + T_falling[i] - 
      time)*p_amplitude[i]/(T_falling[i] - T_width[i]));
  <font color="blue">end for</font>;
<font color="blue">end </font>Trapezoid;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.KinematicPTPI.png" ALT="Modelica.Blocks.Sources.KinematicPTP" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.KinematicPTP"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.KinematicPTP</H2>
<B>Move as fast as possible along a distance within given kinematic constraints</B><p>
<IMG SRC="Modelica.Blocks.Sources.KinematicPTPD.png" ALT="Modelica.Blocks.Sources.KinematicPTP">
<H3>Information</H3>
<PRE></pre>
<p>
The goal is to move as <b>fast</b> as possible along a distance
<b>deltaq</b>
under given <b>kinematical constraints</b>. The distance can be a positional or
angular range. In robotics such a movement is called <b>PTP</b> (Point-To-Point).
This source block generates the <b>acceleration</b> qdd of this signal
as output. After integrating the output two times, the position q is
obtained. The signal is constructed in such a way that it is not possible
to move faster, given the <b>maximally</b> allowed <b>velocity</b> qd_max and
the <b>maximally</b> allowed <b>acceleration</b> qdd_max.
</p>

<p>
If several distances are given (vector deltaq has more than 1 element),
an acceleration output vector is constructed such that all signals
are in the same periods in the acceleration, constant velocity
and deceleration phase. This means that only one of the signals
is at its limits whereas the others are sychnronized in such a way
that the end point is reached at the same time instant.
</p>

<p>
This element is useful to generate a reference signal for a controller
which controls a drive train or in combination with model
Modelica.Mechanics.Rotational.<b>Accelerate</b> to drive
a flange according to a given acceleration.
</p>

<p><b>Release Notes:</b></p>
<ul>
<li><i>June 27, 2001</i>
       by Bernhard Bachmann.<br>
       Bug fixed that element is also correct if startTime is not zero.</li>

<li><i>Nov. 3, 1999</i>
       by <a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a>:<br>
       Vectorized and moved from Rotational to Blocks.Sources.</li>

<li><i>June 29, 1999</i>
       by <a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a>:<br>
       realized.</li>
</ul>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>deltaq[:]</TD><TD>{1}</TD><TD>Distance to move</TD></TR>
<TR><TD>qd_max[:]</TD><TD>{1}</TD><TD>Maximum velocities der(q)</TD></TR>
<TR><TD>qdd_max[:]</TD><TD>{1}</TD><TD>Maximum accelerations der(qd)</TD></TR>
<TR><TD>startTime</TD><TD>0</TD><TD>Time instant at which movement starts [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> KinematicPTP <font color="darkgreen">
  &quot;Move as fast as possible along a distance within given kinematic constraints&quot;</font>
   
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Real deltaq[:]={1} <font color="darkgreen">&quot;Distance to move&quot;</font>;
  <font color="blue">parameter </font>Real qd_max[:](<font color="blue">final </font>min=Modelica.Constants.small) = {1} <font color="darkgreen">
    &quot;Maximum velocities der(q)&quot;</font>;
  <font color="blue">parameter </font>Real qdd_max[:](<font color="blue">final </font>min=Modelica.Constants.small) = {1} <font color="darkgreen">
    &quot;Maximum accelerations der(qd)&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime=0 <font color="darkgreen">&quot;Time instant at which movement starts&quot;</font>;
  <font color="darkgreen"></font>
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(deltaq, 1); <font color="red">size</font>(qd_max, 1); <font color="red">size</font>(
        qdd_max, 1)]));
  <font color="darkgreen"></font>
<font color="blue">protected </font>
  <font color="blue">parameter </font>Real p_deltaq[nout]=(<font color="blue">if </font><font color="red">size</font>(deltaq, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*deltaq
      [1]<font color="blue"> else </font>deltaq);
  <font color="blue">parameter </font>Real p_qd_max[nout]=(<font color="blue">if </font><font color="red">size</font>(qd_max, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*qd_max
      [1]<font color="blue"> else </font>qd_max);
  <font color="blue">parameter </font>Real p_qdd_max[nout]=(<font color="blue">if </font><font color="red">size</font>(qdd_max, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      qdd_max[1]<font color="blue"> else </font>qdd_max);
  Real sd_max;
  Real sdd_max;
  Real sdd;
  Real aux1[nout];
  Real aux2[nout];
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> Ta1;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> Ta2;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> Tv;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> Te;
  Boolean noWphase;
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    aux1[i] = p_deltaq[i]/p_qd_max[i];
    aux2[i] = p_deltaq[i]/p_qdd_max[i];
  <font color="blue">end for</font>;
  sd_max = 1/<font color="red">max</font>(<font color="red">abs</font>(aux1));
  sdd_max = 1/<font color="red">max</font>(<font color="red">abs</font>(aux2));
  <font color="darkgreen"></font>
  Ta1 = <font color="red">sqrt</font>(1/sdd_max);
  Ta2 = sd_max/sdd_max;
  noWphase = Ta2 &gt;= Ta1;
  Tv = <font color="blue">if </font>noWphase<font color="blue"> then </font>Ta1<font color="blue"> else </font>1/sd_max;
  Te = <font color="blue">if </font>noWphase<font color="blue"> then </font>Ta1 + Ta1<font color="blue"> else </font>Tv + Ta2;
  <font color="darkgreen"></font>
  <font color="darkgreen">// path-acceleration</font>
  sdd = <font color="blue">if </font>time &lt; startTime<font color="blue"> then </font>0<font color="blue"> else </font>((<font color="blue">if </font>noWphase<font color="blue"> then </font>(<font color="blue">if </font>time &lt; Ta1 + 
    startTime<font color="blue"> then </font>sdd_max<font color="blue"> else </font>(<font color="blue">if </font>time &lt; Te + startTime<font color="blue"> then </font>-sdd_max<font color="blue"> else </font>0)
    )<font color="blue"> else </font>(<font color="blue">if </font>time &lt; Ta2 + startTime<font color="blue"> then </font>sdd_max<font color="blue"> else </font>(<font color="blue">if </font>time &lt; Tv + 
    startTime<font color="blue"> then </font>0<font color="blue"> else </font>(<font color="blue">if </font>time &lt; Te + startTime<font color="blue"> then </font>-sdd_max<font color="blue"> else </font>0)))));
  <font color="darkgreen"></font>
  <font color="darkgreen">// acceleration</font>
  outPort.signal = p_deltaq*sdd;
<font color="blue">end </font>KinematicPTP;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.TimeTableI.png" ALT="Modelica.Blocks.Sources.TimeTable" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.TimeTable"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.TimeTable</H2>
<B>Generate a (possibly discontinuous) signal by linear interpolation in a table</B><p>
<IMG SRC="Modelica.Blocks.Sources.TimeTableD.png" ALT="Modelica.Blocks.Sources.TimeTable">
<H3>Information</H3>
<PRE></pre>
<p>
This block generates an output signal by <b>linear interpolation</b> in
a table. The time points and function values are stored in a matrix
<b>table[i,j]</b>, where the first column table[:,1] contains the
time points and the second column contains the data to be interpolated.
The table interpolation has the following proporties:
</p>

<ul>
<li>The time points need to be <b>monotonically increasing</b>. </li>
<li><b>Discontinuities</b> are allowed, by providing the same
    time point twice in the table. </li>
<li>Values <b>outside</b> of the table range, are computed by
    <b>extrapolation</b> through the last or first two points of the
    table.</li>
<li>If the table has only <b>one row</b>, no interpolation is performed and
    the function value is just returned independantly of the
    actual time instant.</li>
<li>Via parameters <b>startTime</b> and <b>offset</b> the curve defined
    by the table can be shifted both in time and in the ordinate value.
<li>The table is implemented in a numerically sound way by
    generating <b>time events</b> at interval boundaries,
    in order to not integrate over a discontinuous or not differentiable
    points.
</li>
</ul>

<p>
Example:
</p>

<pre>
   table = [0  0
            1  0
            1  1
            2  4
            3  9
            4 16]

If, e.g., time = 1.0, the output y =  0.0 (before event), 1.0 (after event)
    e.g., time = 1.5, the output y =  2.5,
    e.g., time = 2.0, the output y =  4.0,
    e.g., time = 5.0, the output y = 23.0 (i.e. extrapolation).
</pre>


<p><b>Release Notes:</b></p>
<ul>
<li><i>Oct. 21, 2002</i>
       by <a href="http://www.robotic.dlr.de/Christian.Schweiger/">Christian Schweiger</a>:<br>
       Corrected interface from
<pre>
    parameter Real table[:, :]=[0, 0; 1, 1; 2, 4];
</pre>
       to
<pre>
    parameter Real table[:, <b>2</b>]=[0, 0; 1, 1; 2, 4];
</pre>
       </li>
<li><i>Nov. 7, 1999</i>
       by <a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a>:<br>
       Realized.</li>
</ul>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>table[:, 2]</TD><TD>[0, 0; 1, 1; 2, 4]</TD><TD>Table matrix (time = first column)</TD></TR>
<TR><TD>offset[1]</TD><TD>{0}</TD><TD>Offset of output signal</TD></TR>
<TR><TD>startTime[1]</TD><TD>{0}</TD><TD>Output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> TimeTable <font color="darkgreen">
  &quot;Generate a (possibly discontinuous) signal by linear interpolation in a table&quot;</font>
   
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Real table[:, 2]=[0, 0; 1, 1; 2, 4] <font color="darkgreen">
    &quot;Table matrix (time = first column)&quot;</font>;
  <font color="blue">parameter </font>Real offset[1]={0} <font color="darkgreen">&quot;Offset of output signal&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[1]={0} <font color="darkgreen">&quot;Output = offset for time &lt; startTime&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO"
>Interfaces.MO</A>(<font color="blue">final </font>nout=1);
<font color="blue">protected </font>
  Real a <font color="darkgreen">&quot;Interpolation coefficients a of actual interval (y=a*x+b)&quot;</font>;
  Real b <font color="darkgreen">&quot;Interpolation coefficients b of actual interval (y=a*x+b)&quot;</font>;
  Integer last(start=1) <font color="darkgreen">&quot;Last used lower grid index&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> nextEvent(start=0) <font color="darkgreen">&quot;Next event instant&quot;</font>;
  <font color="blue">function</font> getInterpolationCoefficients <font color="darkgreen">
    &quot;Determine interpolation coefficients and next time event&quot;</font> 
    <font color="blue">input </font>Real table[:, 2] <font color="darkgreen">&quot;Table for interpolation&quot;</font>;
    <font color="blue">input </font>Real offset <font color="darkgreen">&quot;y-offset&quot;</font>;
    <font color="blue">input </font>Real startTime <font color="darkgreen">&quot;time-offset&quot;</font>;
    <font color="blue">input </font>Real t <font color="darkgreen">&quot;Actual time instant&quot;</font>;
    <font color="blue">input </font>Integer last <font color="darkgreen">&quot;Last used lower grid index&quot;</font>;
    <font color="blue">input </font>Real TimeEps <font color="darkgreen">&quot;Relative epsilon to check for identical time instants&quot;</font>;
    <font color="blue">output </font>Real a <font color="darkgreen">&quot;Interpolation coefficients a (y=a*x + b)&quot;</font>;
    <font color="blue">output </font>Real b <font color="darkgreen">&quot;Interpolation coefficients b (y=a*x + b)&quot;</font>;
    <font color="blue">output </font>Real nextEvent <font color="darkgreen">&quot;Next event instant&quot;</font>;
    <font color="blue">output </font>Integer next <font color="darkgreen">&quot;New lower grid index&quot;</font>;
  <font color="blue">protected </font>
    Integer columns=2 <font color="darkgreen">&quot;Column to be interpolated&quot;</font>;
    Integer ncol=2 <font color="darkgreen">&quot;Number of columns to be interpolated&quot;</font>;
    Integer nrow=<font color="red">size</font>(table, 1) <font color="darkgreen">&quot;Number of table rows&quot;</font>;
    Integer next0;
    Real tp;
    Real dt;
  <font color="blue">algorithm </font>
    next := last;
    nextEvent := t - TimeEps*<font color="red">abs</font>(t);
    <font color="darkgreen">// in case there are no more time events</font>
    tp := t + TimeEps*<font color="red">abs</font>(t) - startTime;
    <font color="darkgreen"></font>
    <font color="blue">if </font>tp &lt; 0.0<font color="blue"> then</font>
      <font color="darkgreen">// First event not yet reached</font>
      nextEvent := startTime;
      a := 0;
      b := offset;
    <font color="blue">elseif </font>nrow &lt; 2<font color="blue"> then</font>
      <font color="darkgreen">// Special action if table has only one row</font>
      a := 0;
      b := offset + table[1, columns];
    <font color="blue">else</font>
      <font color="darkgreen"></font>
      <font color="darkgreen">// Find next time event instant. Note, that two consecutive time instants</font>
      <font color="darkgreen">// in the table may be identical due to a discontinuous point.</font>
      <font color="blue">while </font>next &lt; nrow<font color="blue"> and </font>tp &gt;= table[next, 1]<font color="blue"> loop</font>
        next := next + 1;
      <font color="blue">end while</font>;
      <font color="darkgreen"></font>
      <font color="darkgreen">// Define next time event, if last table entry not reached</font>
      <font color="blue">if </font>next &lt; nrow<font color="blue"> then</font>
        nextEvent := startTime + table[next, 1];
      <font color="blue">end if</font>;
      <font color="darkgreen"></font>
      <font color="darkgreen">// Determine interpolation coefficients</font>
      next0 := next - 1;
      dt := table[next, 1] - table[next0, 1];
      <font color="blue">if </font>dt &lt;= TimeEps*<font color="red">abs</font>(table[next, 1])<font color="blue"> then</font>
        <font color="darkgreen">// Interpolation interval is not big enough, use &quot;next&quot; value</font>
        a := 0;
        b := offset + table[next, columns];
      <font color="blue">else</font>
        a := (table[next, columns] - table[next0, columns])/dt;
        b := offset + table[next0, columns] - a*table[next0, 1];
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;
    <font color="darkgreen">// Take into account startTime &quot;a*(time - startTime) + b&quot;</font>
    b := b - a*startTime;
  <font color="blue">end </font>getInterpolationCoefficients;
<font color="blue">algorithm </font>
  <font color="blue">when </font>{time &gt;= <font color="red">pre</font>(nextEvent),<font color="red">initial</font>()}<font color="blue"> then</font>
    (a,b,nextEvent,last) := <font color="red">getInterpolationCoefficients</font>(table, <font color="red">scalar</font>(offset)
      , <font color="red">scalar</font>(startTime), time, last, 100*Modelica.Constants.eps);
  <font color="blue">end when</font>;
<font color="blue">equation </font>
  outPort.signal[1] = a*time + b;
<font color="blue">end </font>TimeTable;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.BooleanConstantI.png" ALT="Modelica.Blocks.Sources.BooleanConstant" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.BooleanConstant"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.BooleanConstant</H2>
<B>Generate constant signals of type Boolean</B><p>
<IMG SRC="Modelica.Blocks.Sources.BooleanConstantD.png" ALT="Modelica.Blocks.Sources.BooleanConstant">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>k[:]</TD><TD>{true}</TD><TD>Constant output values</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> BooleanConstant <font color="darkgreen">&quot;Generate constant signals of type Boolean&quot;</font> 
  <font color="blue">parameter </font>Boolean k[:]={true} <font color="darkgreen">&quot;Constant output values&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanSignalSource"
>Interfaces.BooleanSignalSource</A>(<font color="blue">final </font>nout=<font color="red">size</font>(k, 1));
  <font color="darkgreen"></font>
<font color="blue">equation </font>
  outPort.signal = k;
<font color="blue">end </font>BooleanConstant;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.BooleanPulseI.png" ALT="Modelica.Blocks.Sources.BooleanPulse" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.BooleanPulse"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.BooleanPulse</H2>
<B>Generate pulse signals of type Boolean</B><p>
<IMG SRC="Modelica.Blocks.Sources.BooleanPulseD.png" ALT="Modelica.Blocks.Sources.BooleanPulse">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>width[:]</TD><TD>{50}</TD><TD>Widths of pulses in % of period</TD></TR>
<TR><TD>period[:]</TD><TD>{1}</TD><TD>Times for one period [s]</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Iime instants of first pulse [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> BooleanPulse <font color="darkgreen">&quot;Generate pulse signals of type Boolean&quot;</font> 
  <font color="blue">parameter </font>Real width[:](
    <font color="blue">final </font>min=Modelica.Constants.small, 
    <font color="blue">final </font>max=100) = {50} <font color="darkgreen">&quot;Widths of pulses in % of period&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> period[:](<font color="blue">final </font>min=Modelica.Constants.small) = {1} <font color="darkgreen">
    &quot;Times for one period&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Iime instants of first pulse&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanSignalSource"
>Interfaces.BooleanSignalSource</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(width, 1); <font color="red">size</font>(period
        , 1); <font color="red">size</font>(startTime, 1)]));
<font color="blue">protected </font>
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_period[nout]=(<font color="blue">if </font><font color="red">size</font>(period, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*period[1]<font color="blue">
       else </font>period);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> Twidth[nout]=<font color="red">diagonal</font>(p_period)*(<font color="blue">if </font><font color="red">size</font>(width, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(
      nout)*width[1]<font color="blue"> else </font>width)/100 <font color="darkgreen">&quot;width of one pulse&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> T0[nout](<font color="blue">final </font>start=p_startTime) <font color="darkgreen">&quot;Start time of current period&quot;</font>;
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    <font color="blue">when </font><font color="red">sample</font>(p_startTime[i], p_period[i])<font color="blue"> then</font>
      T0[i] = time;
    <font color="blue">end when</font>;
    outPort.signal[i] = time &gt;= T0[i]<font color="blue"> and </font>time &lt; T0[i] + Twidth[i];
  <font color="blue">end for</font>;
<font color="blue">end </font>BooleanPulse;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.SampleTriggerI.png" ALT="Modelica.Blocks.Sources.SampleTrigger" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.SampleTrigger"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.SampleTrigger</H2>
<B>Generate sample trigger signals</B><p>
<IMG SRC="Modelica.Blocks.Sources.SampleTriggerD.png" ALT="Modelica.Blocks.Sources.SampleTrigger">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>period[:]</TD><TD>{0.01}</TD><TD>Sample periods [s]</TD></TR>
<TR><TD>startTime[:]</TD><TD>{0}</TD><TD>Time instants of first sample triggers [s]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> SampleTrigger <font color="darkgreen">&quot;Generate sample trigger signals&quot;</font> 
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> period[:](<font color="blue">final </font>min=Modelica.Constants.small) = {0.01} <font color="darkgreen">
    &quot;Sample periods&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> startTime[:]={0} <font color="darkgreen">&quot;Time instants of first sample triggers&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanSignalSource"
>Interfaces.BooleanSignalSource</A>(<font color="blue">final </font>nout=<font color="red">max</font>([<font color="red">size</font>(period, 1); <font color="red">size</font>(
        startTime, 1)]));
  <font color="darkgreen"></font>
<font color="blue">protected </font>
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_period[nout]=(<font color="blue">if </font><font color="red">size</font>(period, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*period[1]<font color="blue">
       else </font>period);
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>SI.Time</A> p_startTime[nout]=(<font color="blue">if </font><font color="red">size</font>(startTime, 1) == 1<font color="blue"> then </font><font color="red">ones</font>(nout)*
      startTime[1]<font color="blue"> else </font>startTime);
<font color="blue">equation </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nout<font color="blue"> loop</font>
    outPort.signal[i] = <font color="red">sample</font>(p_startTime[i], p_period[i]);
  <font color="blue">end for</font>;
<font color="blue">end </font>SampleTrigger;
</PRE>
<HR>
<H2><IMG SRC="Modelica.Blocks.Sources.IntegerConstantI.png" ALT="Modelica.Blocks.Sources.IntegerConstant" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Blocks.Sources.IntegerConstant"></A><A HREF="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources"
>Modelica.Blocks.Sources</A>.IntegerConstant</H2>
<B>Generate constant signals of type Integer</B><p>
<IMG SRC="Modelica.Blocks.Sources.IntegerConstantD.png" ALT="Modelica.Blocks.Sources.IntegerConstant">
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>k[:]</TD><TD>{1}</TD><TD>Constant output values</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">block</font> IntegerConstant <font color="darkgreen">&quot;Generate constant signals of type Integer&quot;</font> 
  <font color="blue">parameter </font>Integer k[:]={1} <font color="darkgreen">&quot;Constant output values&quot;</font>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.IntegerMO"
>Interfaces.IntegerMO</A>(<font color="blue">final </font>nout=<font color="red">size</font>(k, 1));
  <font color="darkgreen"></font>
<font color="blue">equation </font>
  outPort.signal = k;
<font color="blue">end </font>IntegerConstant;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.dynasim.se/">Dymola</a> Wed Dec 11 11:13:23 2002
.
</address></BODY>
</HTML>
