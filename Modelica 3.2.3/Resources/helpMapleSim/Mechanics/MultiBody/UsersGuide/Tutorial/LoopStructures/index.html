<html><head><title>Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures</title></head>
<style>
body { font-family: Droid Serif,serif; font-size: 16px; line-height: 24px;  }
p, dt, pre, blockquote, ol, ul, table, hr { margin-top: 24px; margin-bottom: 0 }
img { margin-top: 24px }
img.icon, embed.icon { float: right; margin: 0 0 24px 24px; border: 0 }
h1, h2, h3, h4, h5, th { font-family: Droid Sans,sans-serif }
h1 { font-size: 26px; line-height: 26px; margin: 18px 0 0 0 }h2 { font-size: 21px; line-height: 24px; margin: 26px 0 -2px 0 }h3 { font-size: 18px; line-height: 24px; margin: 27px 0 -3px 0 }h4 { font-size: 16px; line-height: 24px; margin: 28px 0 -4px 0; font-style: italic }h1 .subtitle, h2 .subtitle { font-size: 16px; font-style: italic }
h1 br, h2 br { margin-bottom: 10px }
p.interface { background-color: #EEE; padding: 20px; border: 1px solid #CCE; border-radius: 14px }
code, pre, p.interface { font-family: Droid Sans Mono,monospace; font-size: 14px; line-height: 20px }
li, dd, li p, dd p, li dt, dd dt, li pre, dd pre, li blockquote, dd blockquote, li table, dd table { margin-top: 11px; margin-bottom: 11px }
dt + dt, dd, ul ul { margin-top: 0 }
blockquote pre, blockquote blockquote { margin-top: 0; margin-bottom: 0 }
ul ul li { margin-top:5px; margin-bottom:6px }
td, th { vertical-align: top; font-size: 14px; line-height: 20px }
th { background-color: #EEE }
td p, th p { margin-top: 10px }
td code, th code { font-size: 13px }
hr { border: 0; border-bottom: 1px dotted darkred; clear: right }
</style>
<body>
<a name="LoopStructures"><h1><embed class="icon" src="../../../../../images/icon0002.svg" width="203" height="203" />
Package <a href="../../../../../index.html">Modelica</a>.&#8203;<a href="../../../../index.html">Mechanics</a>.&#8203;<a href="../../../index.html">MultiBody</a>.&#8203;<a href="../../index.html">UsersGuide</a>.&#8203;<a href="../index.html">Tutorial</a>.&#8203;LoopStructures<br><span class="subtitle">Loop structures</span></h1></a>
<h3>Information</h3>
<p>

<p>
The MultiBody library has the feature that all components
can be connected together in a nearly arbitrary fashion.
Therefore, kinematic loop structures pose in principal
no problems. In this section several examples are given,
the special treatment of planar loops is discussed and it is explained
how a kinematic loop structure can be modeled such that the
occurring non-linear algebraic equation systems are solved
analytically. There are the following sub-chapters:
</p>
<ol>
<li><a href="index.html#Introduction">Introduction</a>
</li>
<li><a href="index.html#PlanarLoops">Planar loops</a>.
</li>
<li><a href="index.html#AnalyticLoopHandling">Analytic loop handling</a>.
</li>
</ol>
<p>Extends from <code><a href="../../../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<h3>Package Contents</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Name</th><th>Description</th></tr><tr><td><a href="#AnalyticLoopHandling"><code>AnalyticLoopHandling</code></a></td><td>Analytic loop handling</td></tr>
<tr><td><a href="#Introduction"><code>Introduction</code></a></td><td>Introduction</td></tr>
<tr><td><a href="#PlanarLoops"><code>PlanarLoops</code></a></td><td>Planar loops</td></tr>
</table>
<hr><a name="Introduction"><h2><embed class="icon" src="../../../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../../../index.html">Modelica</a>.&#8203;<a href="../../../../index.html">Mechanics</a>.&#8203;<a href="../../../index.html">MultiBody</a>.&#8203;<a href="../../index.html">UsersGuide</a>.&#8203;<a href="../index.html">Tutorial</a>.&#8203;<a href="index.html">LoopStructures</a>.&#8203;Introduction<br><span class="subtitle">Introduction</span></h2></a>
<h3>Information</h3>
<p>

<p>
In principal, no special action is needed, if
loop structures occur (contrary to the ModelicaAdditions.MultiBody library).
An example is presented in the figure below. It is available as
<a href="../../../Examples/Loops/index.html#Fourbar1">
MultiBody.Examples.Loops.Fourbar1</a>
</p>

<blockquote>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/Fourbar1a.png">
</blockquote>

<p>
This mechanism consists of&nbsp;6 revolute joints and&nbsp;1 prismatic joint and forms a
kinematical loop.
It has one degree of freedom. In the next figure the default animation
is shown. Note, that the axes of the revolute joints are represented by the
red cylinders and that the axis of the prismatic joint is represented by the
red box on the lower right side.
</p>

<blockquote>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/Fourbar1b.png" width=300>
</blockquote>

<p>
Whenever loop structures occur, non-linear algebraic
equations are present on "position level". It is then usually not possible by
structural analysis to select states during translation (which is possible for
non-loop structures). In the example above, a non-linear
algebraic loop of 54 equations can be detected and reduced to a system of&nbsp;6 coupled
algebraic equations. Note, that this is performed without using any
"cut-joints" as it is usually done in multi-body programs, but by just
appropriate symbolic equation manipulation. Via the dynamic dummy derivative
method the generalized coordinates on position and velocity level from one of
the&nbsp;7 joints are dynamically selected as states during simulation. Whenever,
these two states are no longer appropriate, states from one of the other
joints are selected during simulation.
</p>
<p>
The efficiency of loop structures can usually be
enhanced, if states are statically fixed at translation time. For this
mechanism, the generalized coordinates of joint j1 (i.e., the
rotation angle of the revolute joint and its derivative;
the joint is visualized as a red cylinder at the x-axis in the animation figure above)
can always be used as states.
In the abovementioned example, this is already stated by setting parameter
"stateSelect&nbsp;=&nbsp;<strong>StateSelect.always</strong>"
in the "Advanced" menu of that joint.
When setting this flag for joint j1 in that way in
the four bar mechanism, a non-linear algebraic loop of 40
equations can be detected and reduced to a system of&nbsp;5 coupled non-linear algebraic
equations.
</p>
<p>
In many mechanisms it is possible to solve the non-linear algebraic
equations analytically. For a certain class of systems this can
be performed also with the MultiBody library. This technique
is described in section
"<a href="index.html#AnalyticLoopHandling">Analytic loop handling</a>".
</p>
<p>Extends from <code><a href="../../../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr><a name="PlanarLoops"><h2><embed class="icon" src="../../../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../../../index.html">Modelica</a>.&#8203;<a href="../../../../index.html">Mechanics</a>.&#8203;<a href="../../../index.html">MultiBody</a>.&#8203;<a href="../../index.html">UsersGuide</a>.&#8203;<a href="../index.html">Tutorial</a>.&#8203;<a href="index.html">LoopStructures</a>.&#8203;PlanarLoops<br><span class="subtitle">Planar loops</span></h2></a>
<h3>Information</h3>
<p>

<p>
In the figure below, the model of a V6 engine is
shown that has a simple combustion model. It is available as
<a href="../../../Examples/Loops/index.html#EngineV6">
MultiBody.Examples.Loops.EngineV6</a>.
</p>

<p>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_1.png">
</p>

<p>
The Modelica schematic of one cylinder
is given in the figure below. Connecting 6 instances of this
cylinder appropriately together results in the engine schematic displayed
above.
</p>

<p>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_2.png">
</p>

<p>
In the next figure the animation of the engine is
shown. Every cylinder consists essentially of 1 prismatic and 2 revolute
joints that form a planar loop, since the axes of the two revolute joints are
parallel to each other and the axis of the prismatic joint is orthogonal to
the revolute joint axes. All 6 cylinders together form a coupled set of 6
loops that have together 1 degree of freedom.
</p>

<p>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_3.png" width="303" height="136">
</p>

<p>
All planar loops, and especially the engine, result in
a DAE (= Differential-Algebraic Equation system)
that does not have a unique solution. The reason is that, e.g., the cut
forces in direction of the axes of the revolute joints cannot be uniquely
computed. Any value fulfills the DAE equations. This is a structural property
that is determined by the symbolic algorithms. Since they detect that the DAE is
structurally singular, a further processing is not possible. Without
additional information it is also impossible that the symbolic algorithms
could be enhanced because if the axes of rotations of the revolute joints are
only slightly changed such that they are no longer parallel to each other, the
planar loop can no longer move and has 0 degrees of freedom. Algorithms based
on pure structural information cannot distinguish these two cases.
</p>
<p>
The usual remedy is to remove superfluous constraints,
e.g., along the axis of rotation of <strong>one</strong> revolute joint. Since this is
not easy for an inexperienced modeler, the special joint:
<a href="../../../Joints/index.html#RevolutePlanarLoopConstraint">
RevolutePlanarLoopConstraint</a> is provided that removes these constraints.
Exactly one revolute joint in a every planar loop must be replaced by this
joint type. In the engine example, this special joint is used for
the revolute joint B2 in the cylinder model above. The icon of the joint is
slightly different to other revolute joints to visualize this case.
</p>
<p>
If a modeler is not aware of the problems with planar
loops and models them without special consideration, a Modelica
translator displays an error
message and points out that a planar loop may be the reason and suggests to
use the RevolutePlanarLoopConstraint joint.
This error message is due to an annotation in
the Frame connector.
</p>
<pre>
  <strong>connector</strong> Frame
     ...
     <strong>flow</strong> SI.Force f[3] <strong>annotation</strong>(unassignedMessage="..");
  <strong>end</strong> Frame;
</pre>
<p>
If no assignment can be found for some
forces in a connector, the "unassignedMessage" is displayed. In most cases the
reason for this is a planar loop or two joints that constrain the same motion.
Both cases are discussed in the error message.
</p>
<p>
Note, that the non-linear algebraic equations occurring
in planar loops can be solved analytically in most cases and therefore it is
highly recommended to use the techniques discussed in section
"<a href="index.html#AnalyticLoopHandling">Analytic loop handling</a>"
for such systems.
</p>
<p>Extends from <code><a href="../../../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr><a name="AnalyticLoopHandling"><h2><embed class="icon" src="../../../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../../../index.html">Modelica</a>.&#8203;<a href="../../../../index.html">Mechanics</a>.&#8203;<a href="../../../index.html">MultiBody</a>.&#8203;<a href="../../index.html">UsersGuide</a>.&#8203;<a href="../index.html">Tutorial</a>.&#8203;<a href="index.html">LoopStructures</a>.&#8203;AnalyticLoopHandling<br><span class="subtitle">Analytic loop handling</span></h2></a>
<h3>Information</h3>
<p>

<p>
It is well known that the non-linear
algebraic equations of most mechanical loops in technical devices can be
solved analytically. It is, however, difficult to perform this fully
automatically and therefore none of the commercial, general purpose multi-body
programs, such as MSC ADAMS, LMS DADS, SIMPACK, have this feature.
These programs solve loop structures with pure numerical methods. Multi-body
programs that are designed for real-time simulation of the dynamics of
specific vehicles, such as ve-DYNA, usually contain manual implementations
of a particular multi-body system (the vehicle) where the occurring loops are
either analytically solved, if this is possible, or are treated by table
look-up where the tables are constructed in a pre-processing phase. Without
these features the required real-time capability would be difficult to
achieve.
</p>
<p>
In a series of papers and dissertations
Prof. Hiller and his group in Duisburg, Germany,
have developed systematic methods to handle mechanical
loops analytically, see also
<a href="../../index.html#Literature">MultiBody.UsersGuide.Literature</a>.
The "characteristic pair of joints" method
basically cuts a loop at two joints and uses geometric
invariants to reduce the number of algebraic
equations, often down to one equation that can be solved analytically. Also
several multi-body codes have been developed that are based on this method,
e.g., MOBILE. Besides the very desired feature to solve non-linear
algebraic equations analytically, i.e., efficiently and in a robust way, there
are several drawbacks: It is difficult to apply this method automatically.
Even if this would be possible in a good way, there is always the problem that
it cannot be guaranteed that the statically selected states lead to no
singularity during simulation. Therefore, the "characteristic pair of joints"
method is usually manually applied which requires know-how and experience.
</p>
<p>
In the MultiBody library, the "characteristic pair of
joints" method is supported in a restricted form such that it can be applied
also by non-specialists. The idea is to provide aggregations of joints in package
<a href="../../../Joints/Assemblies/index.html">
MultiBody.Joints.Assemblies</a>
as one object that either have <strong>6</strong> degrees of freedom or
<strong>3</strong> degrees of freedom (for usage in planar loops).
</p>
<p>
As an example, a variant of the four bar mechanism is given in
the figure below.
</p>

<blockquote>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/FourbarAnalytic2.png">
</blockquote>

<p>
Here, the mechanism is modeled with six revolute
joints and one prismatic joint.
In the figure below, the five revolute joints
and the prismatic joint are collected together in an assembly object
called "jointSSP" from
<a href="../../../Joints/Assemblies/index.html#JointSSP">
MultiBody.Joints.Assemblies.JointSSP</a>.
</p>

<blockquote>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/FourbarAnalytic1.png">
</blockquote>

<p>
The JointSSP joint aggregation has a frame at the
outer spherical joint (frame_a) and a frame at
the prismatic joint (frame_b). JointSSP, as all other objects from the
Joints.Assemblies package, has the property, that the <strong>generalized
coordinates, and all other frames
defined in the assembly, can be calculated given the movement of frame_a and
of frame_b</strong>. This is performed by <strong>analytically</strong> solving non-linear
systems of equations.
<!-- (details are given in section xxx). -->
From a
structural point of view, the equations in an assembly object are written in
the form
</p>
<blockquote>
  <strong>q</strong> = <strong>
  f</strong><sub>1</sub>(<strong>r</strong><sup>a</sup>, <strong>R</strong><sup>a</sup>, <strong>r</strong><sup>b</sup>,
  <strong>R</strong><sup>b</sup>)
</blockquote>
<p>
where <strong>r</strong><sup>a</sup>, <strong>R</strong><sup>a</sup>,
<strong>r</strong><sup>b</sup>, <strong>R</strong><sup>b</sup> are the variables defining the
position and orientation of the frame_a and frame_b, respectively, and
<strong>q</strong> are the generalized positional coordinates inside the
assembly, e.g., the angle of a revolute joint. Given angle
<span style="font-family:Symbol">j</span> of revolute joint j1 from the four
bar mechanism, frame_a and frame_b of the assembly object can be computed by a
forward recursion
</p>
<blockquote>
(<strong>r</strong><sup>a</sup>,
<strong>R</strong><sup>a</sup>, <strong>r</strong><sup>b</sup>, <strong>R</strong><sup>b</sup>) = <strong>f</strong>(<span style="font-family:Symbol">j)</span>
</blockquote>
<p>
Since this is a structural property, the
symbolic algorithms can automatically select <span style="font-family:Symbol">
j</span> and its derivative as states and then all positional variables can be
computed in a forwards sequence. It is now understandable that a Modelica
translator can
transform the equations of the four bar mechanism to a recursive sequence of
statements that has no non-linear algebraic loops anymore (remember,
the previous "straightforward" solution with 6 revolute joints and 1
prismatic joint has a nonlinear system of equations of order 5).
</p>
<p>
The aggregated joint
objects consist of a combination of either a revolute or prismatic joint and
of a rod that has either two spherical joints at its two ends or a spherical
and a universal joint, respectively. For all combinations, analytic solutions
can be determined. For planar loops, combinations of 1, 2 or 3 revolute joints
with parallel axes and of 2 or 1 prismatic joint with axes that are orthogonal
to the revolute joints can be treated analytically. The currently supported
combinations are listed in the table below.
</p>
<div align="left">
    <table border="1" cellspacing="0" cellpadding="0">
      <tr>
        <td colspan="2"> <strong>3-dimensional Loops:</strong></td>
      </tr>
      <tr>
        <td>JointSSR</td>
        <td>Spherical - Spherical - Revolute</td>
      </tr>
      <tr>
        <td>JointSSP</td>
        <td>Spherical - Spherical - Prismatic</td>
      </tr>
      <tr>
        <td>JointUSR</td>
        <td>Universal - Spherical - Revolute</td>
      </tr>
      <tr>
        <td>JointUSP</td>
        <td>Universal - Spherical - Prismatic</td>
      </tr>
      <tr>
        <td>JointUPS</td>
        <td>Universal - Prismatic - Spherical</td>
      </tr>
      <tr>
        <td colspan="2"><strong>Planar Loops:</strong></td>
      </tr>
      <tr>
        <td>JointRRR</td>
        <td>Revolute - Revolute - Revolute</td>
      </tr>
      <tr>
        <td>JointRRP</td>
        <td>Revolute - Revolute - Prismatic</td>
      </tr>
</table>
</div>
<p>
On first view this seems to be quite restrictive. However, mechanical devices are usually built up with rods connected by spherical joints on each end,
and additionally with revolute and prismatic joints.
Therefore, the combinations of the above table occur frequently.
The universal joint is usually not present in actual devices but is used
(a) if two JointXXX components can be connected such that a revolute
and a universal joint together form a spherical joint
and (b) if the orientation of the connecting rod between two
spherical joints is needed, e.g., since a body shall be attached.
In this case one of the spherical joints might be replaced by a
universal joint. This approximation is fine as long as the mass
and inertia of the rod is not significant.
</p>
<p>
Let us discuss item (a) in more detail: The
MacPherson suspension in the next figure has three frame connectors.
</p>

<blockquote>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/MacPherson1.png">
</blockquote>

<p>
The lower left one (frameChassis) is fixed to the vehicle chassis. The
upper left one (frameSteering) is driven by the steering mechanism, i.e. the
movement of both frames are given. The frame connector on the right (frameWheel)
drives the wheel. The three frames are connected by a mechanism consisting
essentially of two rods with spherical joints on both ends. These are built up
by a jointUPS and a jointSSR assemblies.
As can be seen, the universal joint from the jointUPS
assembly is connected to the revolute joint of the jointSSR assembly.
Therefore, we have 3 revolute joints connected together at one point and if
the axes of rotations are chosen appropriately, this describes a spherical
joint. In other words, the two connected assemblies define the desired two
rods with spherical joints on each ends.
</p>
<p>
The movement of the chassis, frameChassis, is computed
outside of the suspension model. When the generalized coordinates of revolute joint
"jointArm" (lower left part in figure) are used as states, then frame_a and
frame_b of the jointUPS joint can be calculated. After the non-linear loop
with jointUPS is (analytically) solved, all frames on this assembly are
known, especially,
the one connected to frame_b of the jointSSR assembly. Since frame_a of
jointSSR is connected to frameSteering which is computed from the steering
mechanism, again the two required frame movements of the jointSSR assembly are
calculated. This in turn means that also all other frames on the jointSSR
assembly can be computed, especially, the one connected to frameWheel that drives
the wheel. From this analysis it is clear that a tool is able to solve these
coupled loops analytically.
</p>
<p>
Another example is the model of the V6 engine,
see next figure for an animation view and the original definition
of one cylinder with elementary joints.
</p>

<blockquote>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_3.png" width="303" height="136">
</blockquote>

<blockquote>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_2.png">
</blockquote>

<p>
Here, it is sufficient to rewrite the basic cylinder model
by replacing the joints with a JointRRP object that has two
revolute and one prismatic joint, as can be seen in next figure.
</p>

<blockquote>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_4.png">
</blockquote>

<p>
Since 6
cylinders are connected together, 6 coupled loops with 6 JointRRP objects are
present. This model is available as
<a href="../../../Examples/Loops/index.html#EngineV6_analytic">
MultiBody.Examples.Loops.EngineV6_analytic</a>.
</p>
<p>
The composition diagram of the connected 6 cylinders is
shown in the next figure
</p>

<blockquote>
<img src="../../../../../../Images/Mechanics/MultiBody/UsersGuide/Tutorial/LoopStructures/EngineV6_1.png">
</blockquote>
<p>
It can be seen that the revolute joint
of the crank shaft (joint "bearing" in left part of figure) might be
selected as degree of freedom. Then, the&nbsp;4 connector frames of all cylinders
can be computed. As a result, the computations of the cylinders are decoupled
from each other. Within one cylinder
the position of frame_a and frame_b of the jointRRP assembly
can be computed and therefore the generalized coordinates of the two revolute
and the prismatic joint in the jointRRP object can be determined. Considering this
analysis, it is not surprising that a Modelica translator
is able to transform the DAE
equations into a sequential evaluation without any non-linear loop.
Compare this nice result with the model using only elementary joints
that leads to a DAE with 6 algebraic loops and 5 non-linear equations per
loop. Additionally, a linear system of equations of order 43 is present.
The simulation time is about 5 times faster with the analytic loop handling.
</p>
<p>Extends from <code><a href="../../../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr style="border-color:#999" />
<p style="font-size:80%;color:#999;margin-top:12px">Generated 2018-10-22 14:46:06 EDT by <i>MapleSim</i>.</p>
</body></html>
