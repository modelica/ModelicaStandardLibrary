
<html>
<head>
  <meta charset="UTF-8">
  <link rel=stylesheet type=text/css href="resources/documentation.css">
  <script src="resources/jquery.min.js"></script>
  <script src="resources/scripts.js"></script>
</head>
<body>
<div class="wrapper">
<nav>
  <ul class="cf">
    <li><a href="https://www.wolfram.com/system-modeler/">SystemModeler</a></li>
  <li><a href="Modelica.html">Modelica</a></li>
  <li><a href="Modelica.Utilities.html">Utilities</a></li>
  <li><a href="Modelica.Utilities.Strings.html">Strings</a></li>
  <li><a href="Modelica.Utilities.Strings.scanToken.html">scanToken</a></li>
  </ul>
</nav>
<header>
  <table><tr><td>
    <h1>scanToken</h1>
    <p>Scan for the next token and return it</p>
  </td><td>
    <div><img width="60" height="60" src="resources/icons/Modelica.Utilities.Strings.scanToken_60x60.png"></div>
  </td></tr></table>
</header>
<section id="information">
<h1>Information</h1>
<div class="hideable">
<p class="aside">This information is part of the Modelica Standard Library maintained by the Modelica Association.</p>
<h4>Syntax</h4>
<blockquote><pre>
(token, nextIndex) = Strings.<strong>scanToken</strong>(string, startIndex, unsigned=false);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>scanToken</strong> scans the string starting at index
"startIndex" and returns the next token, as well as the
index directly after the token. The returned token is a record
that holds the type of the token and the value of the token:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td>token.tokenType</td>
      <td>Type of the token, see below</td></tr>
  <tr><td>token.real</td>
      <td>Real value if tokenType == TokenType.RealToken</td></tr>
  <tr><td>token.integer</td>
      <td>Integer value if tokenType == TokenType.IntegerToken</td></tr>
  <tr><td>token.boolean</td>
      <td>Boolean value if tokenType == TokenType.BooleanToken</td></tr>
  <tr><td>token.string</td>
      <td>String value if tokenType == TokenType.StringToken/IdentifierToken/DelimiterToken</td></tr>
</table>
<p>
Variable token.tokenType is an enumeration (emulated as a package
with constants) that can have the following values:
</p>
<pre>
   import T = Modelica.Utilities.Types.TokenType;
</pre>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td>T.RealToken</td>
      <td>Modelica Real literal (e.g., 1.23e-4)</td></tr>
  <tr><td>T.IntegerToken</td>
      <td>Modelica Integer literal (e.g., 123)</td></tr>
  <tr><td>T.BooleanToken</td>
      <td>Modelica Boolean literal (e.g., false)</td></tr>
  <tr><td>T.StringToken</td>
      <td>Modelica String literal (e.g., "string 123")</td></tr>
  <tr><td>T.IdentifierToken</td>
      <td>Modelica identifier (e.g., "force_a")</td></tr>
  <tr><td>T.DelimiterToken</td>
      <td>any character without white space that does not appear<br>
          as first character in the tokens above (e.g., "&amp;")</td></tr>
  <tr><td>T.NoToken</td>
      <td>White space, line comments and no other token<br>
          until the end of the string</td></tr>
</table>
<p>
Modelica line comments ("// ... end-of-line/end-of-string")
as well as white space is ignored.
If "unsigned=true", a Real or Integer literal
is not allowed to start with a "+" or "-" sign.
</p>
<h4>Example</h4>
<blockquote><pre>
  import Modelica.Utilities.Strings;
  import T = Modelica.Utilities.Types.TokenType;
  (token, index) := Strings.scanToken(string);
  <strong>if</strong> token.tokenType == T.RealToken <strong>then</strong>
     realValue := token.real;
  <strong>elseif</strong> token.tokenType == T.IntegerToken <strong>then</strong>
     integerValue := token.integer;
  <strong>elseif</strong> token.tokenType == T.BooleanToken <strong>then</strong>
     booleanValue := token.boolean;
  <strong>elseif</strong> token.tokenType == T.Identifier <strong>then</strong>
     name := token.string;
  <strong>else</strong>
     Strings.syntaxError(string,index,"Expected Real, Integer, Boolean or identifier token");
  <strong>end if</strong>;
</pre></blockquote>
</div>
</section>
<section id="syntax" >
  <h1>Syntax </h1>
  <div class="hideable">(token, nextIndex) = scanToken(string, startIndex, unsigned)
  </div>
</section>
<section id="input" >
  <h1>Inputs <span class="count">(3)</span></h1>
  <div class="hideable">
    <table class="shared-styles style-1">
    <colgroup><col class="col-1" /><col class="col-2" /></colgroup>
    <tbody>
    <tr>
      <th>string</th>
      <td>
        <p><span>Type:</span> String</p>
        <p><span>Description:</span> String to be scanned</p>
      </td>
    </tr>
    <tr>
      <th>startIndex</th>
      <td>
        <p><span>Default Value:</span> 1</p>
        <p><span>Type:</span> Integer</p>
        <p><span>Description:</span> Start scanning of string at character startIndex</p>
      </td>
    </tr>
    <tr>
      <th>unsigned</th>
      <td>
        <p><span>Default Value:</span> false</p>
        <p><span>Type:</span> Boolean</p>
        <p><span>Description:</span> = true, if Real and Integer tokens shall not start with a sign</p>
      </td>
    </tr>
    </tbody>
    </table>
  </div>
</section>
<section id="output" >
  <h1>Outputs <span class="count">(2)</span></h1>
  <div class="hideable">
    <table class="shared-styles style-1">
    <colgroup><col class="col-1" /><col class="col-2" /></colgroup>
    <tbody>
    <tr>
      <th>token</th>
      <td>
        <p><span>Type:</span> <a href="Modelica.Utilities.Types.TokenValue.html">TokenValue</a></p>
        <p><span>Description:</span> Scanned token</p>
      </td>
    </tr>
    <tr>
      <th>nextIndex</th>
      <td>
        <p><span>Type:</span> Integer</p>
        <p><span>Description:</span> Index of character after the found token; = 0, if NoToken</p>
      </td>
    </tr>
    </tbody>
    </table>
  </div>
</section>
</div>
</body>
</html>