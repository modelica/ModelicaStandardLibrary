
<html>
<head>
  <meta charset="UTF-8">
  <link rel=stylesheet type=text/css href="resources/documentation.css">
  <script src="resources/jquery.min.js"></script>
  <script src="resources/scripts.js"></script>
</head>
<body>
<div class="wrapper">
<nav>
  <ul class="cf">
    <li><a href="https://www.wolfram.com/system-modeler/">SystemModeler</a></li>
  <li><a href="Modelica.html">Modelica</a></li>
  <li><a href="Modelica.Math.html">Math</a></li>
  <li><a href="Modelica.Math.Matrices.html">Matrices</a></li>
  <li><a href="Modelica.Math.Matrices.LAPACK.html">LAPACK</a></li>
  <li><a href="Modelica.Math.Matrices.LAPACK.dormqr.html">dormqr</a></li>
  </ul>
</nav>
<header>
  <table><tr><td>
    <h1>dormqr</h1>
    <p>overwrites the general real M-by-N matrix C with Q * C or C * Q or Q' * C or C * Q', where Q is an orthogonal matrix of a QR factorization as returned by dgeqrf</p>
  </td><td>
    <div><img width="60" height="60" src="resources/icons/Modelica.Math.Matrices.LAPACK.dormqr_60x60.png"></div>
  </td></tr></table>
</header>
<section id="information">
<h1>Information</h1>
<div class="hideable">
<p class="aside">This information is part of the Modelica Standard Library maintained by the Modelica Association.</p>
<pre>Lapack documentation
    Purpose
    =======

    DORMQR overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(1) H(2) . . . H(k)

    as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
    if SIDE = 'R'.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    A       (input) DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).

    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.

    C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value</pre>
</div>
</section>
<section id="syntax" >
  <h1>Syntax </h1>
  <div class="hideable">(Cout, info) = dormqr(C, A, tau, side, trans)
  </div>
</section>
<section id="input" >
  <h1>Inputs <span class="count">(5)</span></h1>
  <div class="hideable">
    <table class="shared-styles style-1">
    <colgroup><col class="col-1" /><col class="col-2" /></colgroup>
    <tbody>
    <tr>
      <th>C</th>
      <td>
        <p><span>Type:</span> Real[:,:]</p>
      </td>
    </tr>
    <tr>
      <th>A</th>
      <td>
        <p><span>Type:</span> Real[:,:]</p>
      </td>
    </tr>
    <tr>
      <th>tau</th>
      <td>
        <p><span>Type:</span> Real[:]</p>
      </td>
    </tr>
    <tr>
      <th>side</th>
      <td>
        <p><span>Default Value:</span> "L"</p>
        <p><span>Type:</span> String</p>
      </td>
    </tr>
    <tr>
      <th>trans</th>
      <td>
        <p><span>Default Value:</span> "N"</p>
        <p><span>Type:</span> String</p>
      </td>
    </tr>
    </tbody>
    </table>
  </div>
</section>
<section id="output" >
  <h1>Outputs <span class="count">(2)</span></h1>
  <div class="hideable">
    <table class="shared-styles style-1">
    <colgroup><col class="col-1" /><col class="col-2" /></colgroup>
    <tbody>
    <tr>
      <th>Cout</th>
      <td>
        <p><span>Default Value:</span> C</p>
        <p><span>Type:</span> Real[size(C, 1),size(C, 2)]</p>
        <p><span>Description:</span> contains Q*C or Q**T*C or C*Q**T or C*Q</p>
      </td>
    </tr>
    <tr>
      <th>info</th>
      <td>
        <p><span>Type:</span> Integer</p>
      </td>
    </tr>
    </tbody>
    </table>
  </div>
</section>
</div>
</body>
</html>