
<html>
<head>
  <meta charset="UTF-8">
  <link rel=stylesheet type=text/css href="resources/documentation.css">
  <script src="resources/jquery.min.js"></script>
  <script src="resources/scripts.js"></script>
</head>
<body>
<div class="wrapper">
<nav>
  <ul class="cf">
    <li><a href="https://www.wolfram.com/system-modeler/">SystemModeler</a></li>
  <li><a href="Modelica.html">Modelica</a></li>
  <li><a href="Modelica.StateGraph.html">StateGraph</a></li>
  <li><a href="Modelica.StateGraph.UsersGuide.html">UsersGuide</a></li>
  <li><a href="Modelica.StateGraph.UsersGuide.OverView.html">OverView</a></li>
  </ul>
</nav>
<header>
  <table><tr><td>
    <h1>OverView</h1>
    <p>Overview of library</p>
  </td><td>
    <div><img width="60" height="60" src="resources/icons/Modelica.StateGraph.UsersGuide.OverView_60x60.png"></div>
  </td></tr></table>
</header>
<section id="information">
<h1>Information</h1>
<div class="hideable">
<p class="aside">This information is part of the Modelica Standard Library maintained by the Modelica Association.</p>
<p>
In this section, an overview of the most important features
of this library is given.
</p>
<h4>Steps and Transitions</h4>
<p>
A <strong>StateGraph</strong> is an enhanced finite state machine.
It is based on the JGrafchart method and
takes advantage of Modelica features for
the "action" language. JGrafchart is a further development of
Grafcet to include elements of StateCharts that are not present
in Grafcet/Sequential Function Charts. Therefore, the StateGraph
library has a similar modeling power as StateCharts but avoids
some deficiencies of StateCharts.
</p>
<p>
The basic elements of StateGraphs are <strong>steps</strong> and <strong>transitions</strong>:
</p>

<p>
<img src="modelica:///Modelica.StateGraph.UsersGuide.OverView/resources/Modelica.StateGraph.UsersGuide.OverView_info_001.png">
</p>

<p>
<strong>Steps</strong> represent the possible states a StateGraph can have.
If a step is active the Boolean variable <strong>active</strong> of
the step is <strong>true</strong>. If it is deactivated,
<strong>active</strong> = <strong>false</strong>. At the initial time, all "usual"
steps are deactivated. The <strong>InitialStep</strong> objects are steps
that are activated at the initial time. They are characterized
by a double box (see figure above).
</p>
<p>
<strong>Transitions</strong> are used to change the state of a StateGraph.
When the step connected to the input of a transition is active,
the step connected to the output of this transition is deactivated
and the transition condition becomes true, then the
transition fires. This means that the step connected to the input to the
transition is deactivated and the step connected to the output
of the transition is activated.
</p>
<p>
The transition <strong>condition</strong> is defined via the parameter menu
of the transition object. Clicking on object "transition1" in
the above figure, results in the following menu:
</p>

<p>
<img src="modelica:///Modelica.StateGraph.UsersGuide.OverView/resources/Modelica.StateGraph.UsersGuide.OverView_info_002.png">
</p>

<p>
In the input field "<strong>condition</strong>", any type of time varying
Boolean expression can be given (in Modelica notation, this is
a modification of the time varying variable <strong>condition</strong>).
Whenever this condition is true, the transition can fire.
Additionally, it is possible to activate a timer, via
<strong>enableTimer</strong> (see menu above) and provide a
<strong>waitTime</strong>. In this case the firing of the transition
is delayed according to the provided waitTime. The transition
condition and the waitTime are displayed in the transition icon.
</p>
<p>
In the above example, the simulation starts at <strong>initialStep</strong>.
After 1 second, <strong>transition1</strong> fires and <strong>step1</strong> becomes
active. After another second <strong>transition2</strong> fires and
<strong>initialStep</strong> becomes again active. After a further
second <strong>step1</strong> becomes again active, and so on.
</p>
<p>
In JGrafcharts, Grafcet and Sequential Function Charts, the
network of steps and transitions is drawn from top to bottom.
In StateGraphs, no particular direction is defined, since
steps and transitions are blocks with input and output connectors
that can be arbitrarily placed and connected. Usually, it is
most practical to define the network from left to right,
as in the example above, since then it is easy to read the
labels on the icons.
</p>
<h4>Conditions and Actions</h4>
<p>
With the block <strong>TransitionWithSignal</strong>, the firing condition
can be provided as Boolean input signal, instead as entry in the
menu of the transition. An example is given in the next
figure:
</p>

<p>
<img src="modelica:///Modelica.StateGraph.UsersGuide.OverView/resources/Modelica.StateGraph.UsersGuide.OverView_info_003.png">
</p>

<p>
Component "step" is an instance of "StepWithSignal" that is
a usual step where the active flag is available as Boolean
output signal. To this output, component "Timer" from
library "Modelica.Blocks.Logical" is connected. It measures the
time from the time instant where the Boolean input (i.e., the
active flag of the step) became true up to the current
time instant. The timer is connected to a comparison
component. The output is true, once the timer reaches
1 second. This signal is used as condition input of the
transition. As a result, "transition2" fires, once step
"step" has been active for 1 second.
Of course, any other
Modelica block with a Boolean output signal can be
connected to the condition input of such a transition block
as well.
</p>
<p>
Conditions of a transition can either be computed by
a network of logical blocks from the Logical library as
in the figure above, or via the "SetBoolean" component
any type of logical expression can be defined in textual
form, as shown in the next figure:
</p>

<p>
<img src="modelica:///Modelica.StateGraph.UsersGuide.OverView/resources/Modelica.StateGraph.UsersGuide.OverView_info_004.png">
</p>

<p>
With the block "<strong>SetBoolean</strong>", a time varying expression
can be provided as modification to the output signal <strong>y</strong>
(see block with icon text "timer.y > 1" in the figure above).
The output signal can be in turn connected to the condition
input of a TransitionWithSignal block.
</p>
<p>
The "<strong>SetBoolean</strong>" block can also be used to
compute a Boolean signal depending on the active step.
In the figure above, the output of the block with the
icon text "step.active" is
true, when "step" is active, otherwise it is false
(note, the icon text of "SetBoolean" displays the modification
of the output signal "y").
This signal can then be used to compute desired <strong>actions</strong>
in the physical systems model. For example, if a <strong>valve</strong>
shall be open, when the StateGraph is in "step1" or
in "step4", a "SetBoolean" block may be connected to the
valve model using the following condition:
</p>
<pre>
    valve = step1.active <strong>or</strong> step2.active
</pre>
<p>
Via the Modelica operators <strong>edge</strong>(..) and <strong>change</strong>(..),
conditions depending on rising and falling edges of
Boolean expressions can be used when needed.
</p>
<p>
In JGrafcharts, Grafcet, Sequential Function Charts and StateCharts,
<strong>actions</strong> are formulated <strong>within a step</strong>. Such actions are
distinguished as <strong>entry</strong>, <strong>normal</strong>, <strong>exit</strong> and
<strong>abort</strong> actions. For example, a valve might be opened by
an entry action of a step and might be closed by an exit
action of the same step. In StateGraphs, this is (fortunately)
<strong>not possible</strong>
due to Modelica's "single assignment rule" that requires that every
variable is defined by exactly one equation. Instead, the
approach explained above is used. For example, via the
"SetBoolean" component, the valve variable is set to true
when the StateGraph is in particular steps.
</p>
<p>
This feature of a StateGraph is <strong>very useful</strong>, since it allows
a Modelica translator to <strong>guarantee</strong> that a given StateGraph
has always <strong>deterministic</strong> behaviour without conflicts.
In the other methodologies this is much more cumbersome. For example,
if two steps are executed in parallel and both step actions
modify the same variable, the result is either non-deterministic
or non-obvious rules have to be defined which action
takes priority. In a StateGraph, such a situation is detected by
the translator resulting in an error, since there are two equations
to compute one variable. Additional benefits of the StateGraph
approach are:
</p>
<ul>
<li> A JGrafchart or a StateChart need to potentially access
     variables in a step that are defined in
     higher hierarchical levels of a model. Therefore, mostly <strong>global
     variables</strong> are used in the whole network, even if the
     network is structured hierarchically. In StateGraphs this
     is not necessary, since the physical systems outside
     of a StateGraph might access the step or transition state
     via a hierarchical name. This means that <strong>no global variables</strong>
     are needed, because the local variables in the StateGraph
     are accessed from local variables outside of the StateGraph.
     </li>
<li> It is simpler for a user to understand the information that
     is provided in the non-graphical definition, since every
     variable is defined at exactly one place. In the other
     methodologies, the setting and re-setting of the same
     variable is cluttered within the whole network.
    </li>
</ul>
<p>
To emphasize this important difference between these methodologies,
consider the case that a state machine has the following
hierarchy:
</p>
<pre>
   stateMachine.superstate1.superstate2.step1
</pre>
<p>
Within "step1" a StateChart would, e.g., access variable
"stateMachine.openValve", say as "entry action: openValve = true".
This typical usage has the severe drawback that it is not possible
to use the hierarchical state "superstate1" as component in another
context, because "step1" references a particular name outside of this
component.
</p>
<p>
In a StateGraph, there would be typically a "SetBoolean" component
in the "stateMachine" component stating:
</p>
<pre>
    openValve = superstate1.superstate2.step1.active;
</pre>
<p>
As a result, the "superstate1" component can be used in
another context, because it does not depend on the environment
where it is used.
</p>
<h4>Execution Model</h4>
<p>
The execution model of a StateGraph follows from its
Modelica implementation: Given the states of all steps, i.e.,
whether a step is active or not active, the equations of all
steps, transitions, transition conditions, actions etc. are
sorted resulting in an execution sequence to compute
essentially the new values of the steps. If conflicts occur,
e.g., if there are more equations as variables, of if there
are algebraic loops between Boolean variables, an exception
is raised. Once all equations have been processed, the
<strong>active</strong> variable of all steps are updated to the newly
calculated values. Afterwards, the equations are again
evaluated. The iteration stops, once no step changes
its state anymore, i.e., once no transition fires anymore.
Then, simulation continuous until a new event is triggered,
(when a relation changes its value).
</p>
<p>
With the Modelica "sampled(..)" operator, a StateGraph might also
be executed within a discrete controller that is called
at regular time instants. In a future version of the StateGraph
library, this might be more directly supported.
</p>
<h4>Parallel and Alternative Execution</h4>
<p>
Parallel activities can be defined by
component <strong>Parallel</strong> and alternative activities
can be defined by component <strong>Alternative</strong>.
An example for both components is given in the next figure.
</p>

<p>
<img src="modelica:///Modelica.StateGraph.UsersGuide.OverView/resources/Modelica.StateGraph.UsersGuide.OverView_info_005.png">
</p>

<p>
Here, the branch from "step2" to "step5" is executed in parallel
to "step1". A transition connected to the output of a parallel
branch component can only fire if the final steps
in all parallel branches are active simultaneously.
The figure above is a screen-shot from the animation of the
StateGraph: Whenever a step is active or a transition can fire,
the corresponding component is marked in <strong>green</strong> color.
</p>
<p>
The three branches within "step2" to "step5" are
executed alternatively, depending which transition condition
of "transition3", "transition4", "transition4a" fires first.
Since all three transitions fire after 1 second, they are all
candidates for the active branch. If two or more transitions
would fire at the same time instant, a priority selection
is made: The alternative and parallel components have a
vector of connectors. Every branch has to be connected to
exactly one entry of the connector vector. The entry with
the lowest number has the highest priority.
</p>
<p>
Parallel, Alternative and Step components have vectors of
connectors. The dimensions of these vectors are set in the
corresponding parameter menu. E.g. in a "Parallel" component:
</p>

<p>
<img src="modelica:///Modelica.StateGraph.UsersGuide.OverView/resources/Modelica.StateGraph.UsersGuide.OverView_info_006.png">
</p>

<p>
Currently in Dymola the following menu pops up, when a branch
is connected to a vector of components in order to define
the vector index to which the component shall be connected:
</p>

<p>
<img src="modelica:///Modelica.StateGraph.UsersGuide.OverView/resources/Modelica.StateGraph.UsersGuide.OverView_info_007.png">
</p>

<h4>CompositeSteps, Suspend and Resume Port</h4>
<p>
A StateGraph can be hierarchically structured by using a <strong>CompositeStep</strong>.
This is a component that inherits from <strong>PartialCompositeStep</strong>.
An example is given in the next figure (from Examples.ControlledTanks):
</p>

<p>
<img src="modelica:///Modelica.StateGraph.UsersGuide.OverView/resources/Modelica.StateGraph.UsersGuide.OverView_info_008.png">
</p>

<p>
The CompositeStep component contains a local StateGraph that is
entered by one or more input transitions and that is left
by one or more output transitions. Also, other needed signals
may enter a CompositeStep. The CompositeStep has similar properties
as a "usual" step: The CompositeStep is <strong>active</strong> once at least
one step within the CompositeStep is active. Variable <strong>active</strong>
defines the state of the CompositeStep.
</p>
<p>
Additionally, a CompositeStep has a <strong>suspend</strong> port. Whenever the
transition connected to this port fires, the CompositeStep is left
at once. When leaving the CompositeStep via the suspend port, the internal
state of the CompositeStep is saved, i.e., the active flags of all
steps within the CompositeStep. The CompositeStep might be entered via
its <strong>resume</strong> port. In this case the internal state from the
suspend transition is reconstructed and the CompositeStep continues
the execution that it had before the suspend transition fired
(this corresponds to the history ports of StateCharts or JGrafcharts).
</p>
<p>
A CompositeStep may contain other CompositeSteps. At every level,
a CompositeStep and all of its content can be left via its suspend ports
(actually, there
is a vector of suspend connectors, i.e., a CompositeStep might
be aborted due to different transitions).
</p>
</div>
</section>
</div>
</body>
</html>