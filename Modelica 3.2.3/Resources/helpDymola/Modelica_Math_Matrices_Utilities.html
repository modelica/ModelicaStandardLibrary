<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Modelica.Math.Matrices.Utilities</title>
<meta name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="&quot;Utility functions that should not be directly utilized by the user&quot;">
<style type="text/css">
*       { font-size: 100%; font-family: Arial, sans-serif; }
.modelica, .modelica * { font-size: 90%; font-family: Courier, monospace; white-space: pre; } /* For the Modelica code (in exported html). */
h4      { font-size: 100%; font-weight: bold; color: green; } 
h3      { font-size: 110%; font-weight: bold; color: green; }
h2      { font-size: 130%; font-weight: bold; color: green; }
address { font-weight: normal; }
td      { padding: 2px; border: 1px solid #808080; vertical-align: top; }
th      { padding: 2px; border: 1px solid #808080; vertical-align: top; font-weight: bold; }
table   { border: 1px solid #808080; border-collapse: collapse; }
pre, code {font-family: "Courier New", monospace;}
pre {white-space: pre; overflow-x : hidden;}
.ModelicaDescription {font-weight: bold;} /* For the description string of the class. */
.ModelicaBaseClass {} /* For the list of base-classes at the of the description. */
.ModelicaKeyword { color: blue; font-weight: normal; font-style: normal; } /* Keywords in Modelica. */
.ModelicaComment { color: #006400;  font-weight: normal; font-style: normal;} /* All three variants of comments in Modelica.  */
.ModelicaString { color: #006400;  font-weight: normal; font-style: normal;} /* String constants. */
.ModelicaClass { color: red; font-weight: normal; font-style: normal;} /* Formatting the names of referenced classes (for base-class and components). */
.ModelicaFunction { color: red; font-weight: normal; font-style: normal;} /* Formatting for called functions. */
.ModelicaTablePackageContent { } /* The table of contents for each package. */
.ModelicaTableCrossReference { } /* The optional cross-reference table. */
.ModelicaTableInputs {} /* The table of inputs for a function. */
.ModelicaTableOutputs {} /* The table of outputs for a function. */
.ModelicaTableParameters {} /* The table of parameters for a model/block. */
.ModelicaTableConnectors {} /* The table of connectors for a model/block. */
.ModelicaTableContents {} /* The table of contents for a connector. */
.ModelicaStartAttribute { font-weight: bold; } /* The formatting used for start-attribute in the table of parameters, to separate them from parameter values. */
.ModelicaParameterTab { background-color: #c0c0c0; font-weight: bold; } /* The tab-heading in the table of parameters */
.ModelicaParameterGroup { background-color: #e0e0e0; } /* The group-heading in the table of parameters */
</style>
</head>
<body>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE Utilities<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica.Math.Matrices.Utilities"></a><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</a>.Utilities</h2>
<p>
<span class="ModelicaDescription">Utility functions that should not be directly utilized by the user</span><br>
</p>
<h3>Information</h3>

<p>
This package contains utility functions that are utilized by higher level matrix functions.
These functions are usually not useful for an end-user.
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons_UtilitiesPackage.html#Modelica.Icons.UtilitiesPackage"
>Modelica.Icons.UtilitiesPackage</a> (Icon for utility packages).</span></p>
<h3>Package Content</h3>
<table summary="Package Content" class="ModelicaTablePackageContent">
<tr>
<th>Name</th>
<th>Description</th>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.Utilities.continuousRiccatiIterative" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.continuousRiccatiIterative"
>continuousRiccatiIterative</a>
</td>
<td>Newton&#39;s method with exact line search for iterative solving continuous algebraic Riccati equation</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.Utilities.discreteRiccatiIterative" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.discreteRiccatiIterative"
>discreteRiccatiIterative</a>
</td>
<td>Newton&#39;s method with exact line search for solving discrete algebraic Riccati equation</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.Utilities.householderReflection" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.householderReflection"
>householderReflection</a>
</td>
<td>Reflect each of the vectors a_i of matrix  A=[a_1, a_2, ..., a_n] on a plane with orthogonal vector u</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.Utilities.householderSimilarityTransformation" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.householderSimilarityTransformation"
>householderSimilarityTransformation</a>
</td>
<td>Perform the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u&#39;</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.Utilities.toUpperHessenberg" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.toUpperHessenberg"
>toUpperHessenberg</a>
</td>
<td>Transform a real square matrix A to upper Hessenberg form H by orthogonal similarity transformation:  Q&#39; * A * Q = H</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.Utilities.eigenvaluesHessenberg" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.eigenvaluesHessenberg"
>eigenvaluesHessenberg</a>
</td>
<td>Compute eigenvalues of an upper Hessenberg form matrix</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.Utilities.reorderRSF" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.reorderRSF"
>reorderRSF</a>
</td>
<td>Reorders a real Schur form to clusters of stable and unstable eigenvalues</td>
</tr>
<tr>
<td><img src="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" alt="Modelica.Math.Matrices.Utilities.findLocal_tk" width="20" height="20" align="top">&nbsp;<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.findLocal_tk"
>findLocal_tk</a>
</td>
<td>Find a local minimizer tk to define the length of the step tk*Nk in continuousRiccatiIterative and discreteRiccatiIterative</td>
</tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE continuousRiccatiIterative<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" alt="Modelica.Math.Matrices.Utilities.continuousRiccatiIterative" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.Utilities.continuousRiccatiIterative"></a><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</a>.continuousRiccatiIterative</h2>
<p>
<span class="ModelicaDescription">Newton&#39;s method with exact line search for iterative solving continuous algebraic Riccati equation</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
           X = Matrices.Utilities.<strong>continuousRiccatiIterative</strong>(A, B, R, Q, X0);
      (X, r) = Matrices.Utilities.<strong>continuousRiccatiIterative</strong>(A, B, R, Q, X0, maxSteps, eps);
</pre></blockquote>
<h4>Description</h4>
<p>
This function provides a Newton-like method for solving continuous algebraic Riccati equations (care). It utilizes Exact Line Search to improve the sometimes erratic
convergence of Newton's method. Exact line search in this case means, that at each iteration <code>i</code> a Newton step <code><strong>delta</strong>_i</code>
</p>
<blockquote><pre>
  <strong>X</strong>_i+1 = <strong>X</strong>_i + <strong>delta</strong>_i
</pre></blockquote>
<p>
is taken in the direction to minimize the Frobenius norm of the residual
</p>
<blockquote><pre>
    r = || <strong>X</strong>_i+1*<strong>A</strong> +<strong>A</strong>'*<strong>X</strong>_i+1 - <strong>X</strong>_i+1*<strong>G</strong>*<strong>X</strong>_i+1 + <strong>Q</strong> ||.
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
        -1
  G = <strong>B</strong>*<strong>R</strong> *<strong>B</strong>'
</pre></blockquote>
<p>

The inputs "maxSteps" and "eps" specify the termination of the iteration. The iteration is terminated if either
maxSteps iteration steps have been performed or the relative change <strong>delta</strong>_i/<strong>X</strong>_i became smaller than eps.
</p>
<p>

With an appropriate initial value <strong>X</strong>0 a sufficiently accurate solution might be reach within a few iteration steps. Although a Lyapunov equation
of order <code>n</code> (n is the order of the Riccati equation) is to be solved at each iteration step, the algorithm might be faster
than a direct method like <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousRiccati"
>Matrices.continuousRiccati</a>, since direct methods have to solve the 2*n-order Hamiltonian
system equation.<br>

The algorithm is taken from [1] and [2].
</p>
<h4>References</h4>
<pre>
  [1] Benner, P., Byers, R.
      An Exact Line Search Method for Solving Generalized Continuous-Time Algebraic Riccati Equations
      IEEE Transactions On Automatic Control, Vol. 43, No. 1, pp. 101-107, 1998.
  [2] Datta, B.N.
      Numerical Methods for Linear Control Systems
      Elsevier Academic Press, 2004.
</pre>

<h4>Example</h4>
<blockquote><pre>
     A=[0.0,         1.0,         0.0,         0.0;
        0.0,        -1.890,       3.900e-01,  -5.530;
        0.0,        -3.400e-02,  -2.980,       2.430;
        3.400e-02,  -1.100e-03,  -9.900e-01,  -2.100e-01];

     B=[ 0.0,         0.0;
         3.600e-01,  -1.60;
        -9.500e-01,  -3.200e-02;
         3.000e-02,   0.0];

     R=[1, 0; 0, 1];

     Q=[2.313,       2.727,       6.880e-01,   2.300e-02;
        2.727,       4.271,       1.148,       3.230e-01;
        6.880e-01,   1.148,       3.130e-01,   1.020e-01;
        2.300e-02,   3.230e-01,   1.020e-01,   8.300e-02];

    X0=identity(4);

    (X,r) = Matrices.Utilities.continuousRiccatiIterative(A, B, R, Q, X0);

  //  X = [1.3239,  0.9015,  0.5466, -1.7672;
           0.9015,  0.9607,  0.4334, -1.1989;
           0.5466,  0.4334,  0.4605, -1.3633;
          -1.7672, -1.1989, -1.3633,  4.4612]
  // r =  2.48809423389491E-015

    (,r) = Matrices.Utilities.continuousRiccatiIterative(A, B, R, Q, X0,4);

   // r =  0.0004;

<br>
</pre></blockquote>
<h4>See also</h4>
<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.discreteRiccatiIterative"
>Matrices.Utilities.discreteRiccatiIterative</a><br>
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousRiccati"
>Matrices.continuousRiccati</a>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Matrix A of Riccati equation X*A + A&#39;*X -X*G*X +Q = 0</td></tr>
<tr><td>B[size(A, 1), :]</td><td>Matrix B in G = B*inv(R)*B&#39;</td></tr>
<tr><td>R[size(B, 2), size(B, 2)]</td><td>Matrix R in G = B*inv(R)*B&#39;</td></tr>
<tr><td>Q[size(A, 1), size(A, 2)]</td><td>Matrix Q of Riccati equation X*A + A&#39;*X -X*G*X +Q = 0</td></tr>
<tr><td>X0[size(A, 1), size(A, 2)]</td><td>Initial approximate solution for X*A + A&#39;*X -X*G*X +Q = 0</td></tr>
<tr><td>maxSteps</td><td>Maximal number of iteration steps</td></tr>
<tr><td>eps</td><td>Tolerance for stop criterion</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(X0, 1), size(X0, 2)]</td><td>Solution X of Riccati equation X*A + A&#39;*X -X*G*X +Q = 0</td></tr>
<tr><td>r</td><td>Norm of X*A + A&#39;*X - X*G*X + Q, zero for exact solution</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE discreteRiccatiIterative<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" alt="Modelica.Math.Matrices.Utilities.discreteRiccatiIterative" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.Utilities.discreteRiccatiIterative"></a><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</a>.discreteRiccatiIterative</h2>
<p>
<span class="ModelicaDescription">Newton&#39;s method with exact line search for solving discrete algebraic Riccati equation</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
           X = Matrices.Utilities.<strong>discreteRiccatiIterative</strong>(A, B, R, Q, X0);
      (X, r) = Matrices.Utilities.<strong>discreteRiccatiIterative</strong>(A, B, R, Q, X0, maxSteps, eps);
</pre></blockquote>
<h4>Description</h4>
<p>
This function provides a Newton-like method for solving discrete-time algebraic Riccati equations. It uses Exact Line Search to improve the sometimes erratic
convergence of Newton's method. Exact line search in this case means, that at each iteration <code>i</code> a Newton step <code><strong>delta</strong>_i</code>
</p>
<blockquote><pre>
  <strong>X</strong>_i+1 = <strong>X</strong>_i + <strong>delta</strong>_i
</pre></blockquote>
<p>
is taken in the direction to minimize the Frobenius norm of the residual
</p>
<blockquote><pre>
  r = || <strong>A</strong>'<strong>X</strong>_i+1*<strong>A</strong> - <strong>X</strong>_i+1 - <strong>A</strong>'<strong>X</strong>_i+1*<strong>G</strong>_i*<strong>X</strong>_i+1*<strong>A</strong> + <strong>Q</strong> ||
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
                       -1
  G_i = <strong>B</strong>*(<strong>R</strong> + <strong>B</strong>'*<strong>X</strong>_i*<strong>B</strong>) *<strong>B</strong>'
</pre></blockquote>
<p>

Output <code>r</code> is the norm of the residual of the last iteration.<br>
</p>
<p>
The inputs "maxSteps" and "eps" specify the termination of the iteration. The iteration is terminated if either
maxSteps iteration steps have been performed or the relative change <strong>delta</strong>_i/<strong>X</strong>_i became smaller than eps.
</p>
<p>

With an appropriate initial value <strong>X</strong>0 a sufficiently accurate solution might be reach with a few iteration steps. Although a Lyapunov equation of
order <code>n</code> (n is the order of the Riccati equation) is to be solved at each iteration step, the algorithm might be faster
than a direct method like <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteRiccati"
>Matrices.discreteRiccati</a>, since direct methods have to solve the 2*n-order Hamiltonian
system equation.

The algorithm is taken from [1] and [2].
</p>
<h4>References</h4>
<pre>
  [1] Benner, P., Byers, R.
      An Exact Line Search Method for Solving Generalized Continuous-Time Algebraic Riccati Equations
      IEEE Transactions On Automatic Control, Vol. 43, No. 1, pp. 101-107, 1998.
  [2] Datta, B.N.
      Numerical Methods for Linear Control Systems
      Elsevier Academic Press, 2004.
</pre>

<h4>Example</h4>
<blockquote><pre>
     A  = [0.9970,    0.0000,    0.0000,    0.0000;
           1.0000,    0.0000,    0.0000,    0.0000;
           0.0000,    1.0000,    0.0000,    0.0000;
           0.0000,    0.0000,    1.0000,    0.0000];

     B  = [0.0150;
           0.0000;
           0.0000;
           0.0000];

     R = [0.2500];

     Q = [0, 0, 0, 0;
          0, 0, 0, 0;
          0, 0, 0, 0;
          0, 0, 0, 1];

    X0=identity(4);

    (X,r) = Matrices.Utilities.discreteRiccatiIterative(A, B, R, Q, X0);

  //  X = [30.625, 0.0, 0.0, 0.0;
            0.0,   1.0, 0.0, 0.0;
            0.0,   0.0, 1.0, 0.0;
            0.0,   0.0, 0.0, 1.0];

  // r =   3.10862446895044E-015
</pre></blockquote>
<h4>See also</h4>
<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.continuousRiccatiIterative"
>Matrices.Utilities.continuousRiccatiIterative</a><br>
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteRiccati"
>Matrices.discreteRiccati</a>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Matrix A of discrete Riccati equation</td></tr>
<tr><td>B[size(A, 1), :]</td><td>Matrix B of discrete Riccati equation</td></tr>
<tr><td>R[size(B, 2), size(B, 2)]</td><td>Matrix R of discrete Riccati equation</td></tr>
<tr><td>Q[size(A, 1), size(A, 2)]</td><td>Matrix Q of discrete Riccati equation</td></tr>
<tr><td>X0[size(A, 1), size(A, 2)]</td><td>Initial approximate solution discrete Riccati equation</td></tr>
<tr><td>maxSteps</td><td>Maximal number of iteration steps</td></tr>
<tr><td>eps</td><td>Tolerance for stop criterion</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(X0, 1), size(X0, 2)]</td><td>&nbsp;</td></tr>
<tr><td>r</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE householderReflection<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" alt="Modelica.Math.Matrices.Utilities.householderReflection" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.Utilities.householderReflection"></a><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</a>.householderReflection</h2>
<p>
<span class="ModelicaDescription">Reflect each of the vectors a_i of matrix  A=[a_1, a_2, ..., a_n] on a plane with orthogonal vector u</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
Matrices.<strong>householderReflection</strong>(A,u);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the Householder reflection (transformation)
</p>
<blockquote>
 <strong>Ar</strong> = <strong>Q</strong>*<strong>A</strong>
</blockquote>
with
<blockquote>
 <strong>Q</strong> = <strong>I</strong> -2*<strong>u</strong>*<strong>u</strong>'/(<strong>u</strong>'*<strong>u</strong>)
</blockquote>
<p>
where <strong>u</strong> is Householder vector, i.e., the normal vector of the reflection plane.
</p>
<p>
Householder reflection is widely used in numerical linear algebra, e.g., to perform QR decompositions.
</p>
<h4>Example</h4>
<blockquote><pre>
// First step of QR decomposition
  import   Modelica.Math.Vectors.Utilities;

  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real Ar[3,3];
  Real u[:];

  u=Utilities.householderVector(A[:,1],{1,0,0});
  // u= {0.763, 0.646, 0}

  Ar=householderReflection(A,u);
 // Ar = [-6.0828,   -5.2608,   -4.4388;
 //        0.0,      -1.1508,   -2.3016;
 //        0.0,       2.0,       0.0]

</pre></blockquote>

<h4>See also</h4>
<p>
<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.householderSimilarityTransformation"
>Matrices.Utilities.housholderSimilarityTransformation</a>,<br>
<a href="Modelica_Math_Vectors_Utilities.html#Modelica.Math.Vectors.Utilities.householderReflection"
>Vectors.Utilities.householderReflection</a>,<br>
<a href="Modelica_Math_Vectors_Utilities.html#Modelica.Math.Vectors.Utilities.householderVector"
>Vectors.Utilities.householderVector</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Rectangular matrix</td></tr>
<tr><td>u[size(A, 1)]</td><td>Householder vector</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>RA[size(A, 1), size(A, 2)]</td><td>Reflexion of A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE householderSimilarityTransformation<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" alt="Modelica.Math.Matrices.Utilities.householderSimilarityTransformation" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.Utilities.householderSimilarityTransformation"></a><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</a>.householderSimilarityTransformation</h2>
<p>
<span class="ModelicaDescription">Perform the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u&#39;</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
  As = Matrices.<strong>householderSimilarityTransformation</strong>(A,u);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the Householder similarity transformation
</p>
<blockquote>
 <strong>As</strong> = <strong>S</strong>*<strong>A</strong>*<strong>S</strong>
</blockquote>
with
<blockquote>
 <strong>S</strong> = <strong>I</strong> -2*<strong>u</strong>*<strong>u</strong>'/(<strong>u</strong>'*<strong>u</strong>).
</blockquote>
<p>
This transformation is widely used for transforming non-symmetric matrices to a Hessenberg form.
</p>
<h4>Example</h4>
<blockquote><pre>
// First step of Hessenberg decomposition
  import   Modelica.Math.Vectors.Utilities;

  Real A[4,4] = [1,2,3,4;
                 3,4,5,6;
                 9,8,7,6;
                 1,2,0,0];
  Real Ar[4,4];
  Real u[4]={0,0,0,0};

  u[2:4]=Utilities.householderVector(A[2:4,1],{1,0,0});
  // u= = {0, 0.8107, 0.5819, 0.0647}

  Ar=householderSimilarityTransformation(A,u);
 //  Ar = [1.0,     -3.8787,    -1.2193,    3.531;
          -9.5394, 11.3407,      6.4336,   -5.9243;
           0.0,     3.1307,      0.7525,   -3.3670;
           0.0,     0.8021,     -1.1656,   -1.0932]
</pre></blockquote>

<h4>See also</h4>
<p>
<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.householderReflection"
>Matrices.Utilities.householderReflection</a>,<br>
<a href="Modelica_Math_Vectors_Utilities.html#Modelica.Math.Vectors.Utilities.householderReflection"
>Vectors.Utilities.householderReflection</a>,<br>
<a href="Modelica_Math_Vectors_Utilities.html#Modelica.Math.Vectors.Utilities.householderVector"
>Vectors.Utilities.householderVector</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Square matrix A</td></tr>
<tr><td>u[size(A, 1)]</td><td>Householder vector</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>SAS[size(A, 1), size(A, 1)]</td><td>Transformation of matrix A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE toUpperHessenberg<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" alt="Modelica.Math.Matrices.Utilities.toUpperHessenberg" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.Utilities.toUpperHessenberg"></a><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</a>.toUpperHessenberg</h2>
<p>
<span class="ModelicaDescription">Transform a real square matrix A to upper Hessenberg form H by orthogonal similarity transformation:  Q&#39; * A * Q = H</span>
</p>
<h3>Information</h3>

   <h4>Syntax</h4>
<blockquote><pre>
         H = Matrices.Utilities.<strong>toUpperHessenberg</strong>(A);
         (H, V, tau, info) = Matrices.Utilities.<strong>toUpperHessenberg</strong>(A,ilo, ihi);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>toUpperHessenberg</strong> computes a upper Hessenberg form <strong>H</strong> of a matrix <strong>A</strong> by orthogonal similarity transformation:  <strong>Q</strong>' * <strong>A</strong> * <strong>Q</strong> = <strong>H</strong>.
With the optional inputs ilo and ihi, also partial transformation is possible. The function calls LAPACK function DGEHRD.
See <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgehrd"
>Matrices.LAPACK.dgehrd</a> for more information about the additional outputs V, tau, info and inputs ilo, ihi.
</p>

<h4>Example</h4>
<blockquote><pre>
 A  = [1, 2, 3;
       6, 5, 4;
       1, 0, 0];

 H = toUpperHessenberg(A);

  results in:

 H = [1.0,  -2.466,  2.630;
     -6.083, 5.514, -3.081;
      0.0,   0.919, -0.514]

</pre></blockquote>

<h4>See also</h4>
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.hessenberg"
>Matrices.hessenberg</a>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Square matrix A</td></tr>
<tr><td>ilo</td><td>Lowest index where the original matrix had been Hessenbergform</td></tr>
<tr><td>ihi</td><td>Highest index where the original matrix had been Hessenbergform</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>H[size(A, 1), size(A, 2)]</td><td>Upper Hessenberg form</td></tr>
<tr><td>V[size(A, 1), size(A, 2)]</td><td>V=[v1,v2,..vn-1,0] with vi are vectors which define the elementary reflectors</td></tr>
<tr><td>tau[max(0, size(A, 1) - 1)]</td><td>Scalar factors of the elementary reflectors</td></tr>
<tr><td>info</td><td>Information of successful function call</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE eigenvaluesHessenberg<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" alt="Modelica.Math.Matrices.Utilities.eigenvaluesHessenberg" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.Utilities.eigenvaluesHessenberg"></a><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</a>.eigenvaluesHessenberg</h2>
<p>
<span class="ModelicaDescription">Compute eigenvalues of an upper Hessenberg form matrix</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
           ev = Matrices.Utilities.<strong>eigenvaluesHessenberg</strong>(H);
   (ev, info) = Matrices.Utilities.<strong>eigenvaluesHessenberg</strong>(H);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the eigenvalues of a Hessenberg form matrix. Transformation to Hessenberg form is the first step in eigenvalue computation for arbitrary matrices with QR decomposition.
This step can be skipped if the matrix has already Hessenberg form.
</p>

<p>
The function uses the LAPACK-routine dhseqr. Output <code>info</code> is 0 for a successful call of this
function.<br>
See <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dhseqr"
>Matrices.LAPACK.dhseqr</a> for details
</p>

<h4>Example</h4>
<blockquote><pre>
     Real A[3,3] = [1,2,3;
                    9,8,7;
                    0,1,0];

     Real ev[3,2];

     ev := Matrices.Utilities.eigenvaluesHessenberg(A);

  // ev  = [10.7538,    0.0;
            -0.8769,    1.0444;
            -0.8769,   -1.0444]
  // = {10.7538,  -0.8769 +- i*1.0444}
</pre></blockquote>
<br>

<h4>See also</h4>
<p>
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>Matrices.eigenValues</a>,
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.hessenberg"
>Matrices.hessenberg</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>H[:, size(H, 1)]</td><td>Hessenberg matrix H</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>ev[size(H, 1), 2]</td><td>Eigenvalues</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE reorderRSF<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" alt="Modelica.Math.Matrices.Utilities.reorderRSF" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.Utilities.reorderRSF"></a><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</a>.reorderRSF</h2>
<p>
<span class="ModelicaDescription">Reorders a real Schur form to clusters of stable and unstable eigenvalues</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
              To = Matrices.Utilities.<strong>reorderRSF</strong>(T, Q, alphaReal, alphaImag);
(To, Qo, wr, wi) = Matrices.Utilities.<strong>reorderRSF</strong>(T, Q, alphaReal, alphaImag, iscontinuous);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>reorderRSF</strong>() reorders a real Schur form such that the stable eigenvalues of
the system are in the 1-by-1 and 2-by-2 diagonal blocks of the block <strong>upper</strong> triangular matrix.
If the Schur form is referenced to a continuous system the staple eigenvalues are in the left complex half plane.
The stable eigenvalues of a discrete system are inside the complex unit circle.<br>
This function is used for example to solve algebraic Riccati equations
(<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousRiccati"
>continuousRiccati</a>,
<a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteRiccati"
>discreteRiccati</a>). In this context the Schur form
as well as the corresponding eigenvalues and the transformation matrix <strong>Q</strong> are known, why the eigenvalues and the transformation matrix are inputs to <strong>reorderRSF()</strong>.<br>

The Schur vector matrix <strong>Qo</strong> is also reordered according to <strong>To</strong>. The vectors <strong>wr</strong> and <strong>wi</strong> contains the real and imaginary parts of the
reordered eigenvalues respectively.
</p>

<h4>Example</h4>
<blockquote><pre>
  T := [-1,2, 3,4;
         0,2, 6,5;
         0,0,-3,5;
         0,0, 0,6];
  To := Matrices.Utilities.reorderRSF(T,identity(4),{-1, 2, -3, 6},{0, 0, 0, 0}, true);

  // To = [-1.0, -0.384, 3.585, 4.0;
  //        0.0, -3.0,   6.0,   0.64;
  //        0.0,  0.0,   2.0,   7.04;
  //        0.0,  0.0,   0.0,   6.0]
</pre></blockquote>
<p>
See also <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.realSchur"
>Matrices.realSchur</a>
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>T[:, :]</td><td>Real Schur form</td></tr>
<tr><td>Q[:, size(T, 2)]</td><td>Schur vector Matrix</td></tr>
<tr><td>alphaReal[size(T, 1)]</td><td>Real part of eigenvalue=alphaReal+i*alphaImag</td></tr>
<tr><td>alphaImag[size(T, 1)]</td><td>Imaginary part of eigenvalue=alphaReal+i*alphaImag</td></tr>
<tr><td>iscontinuous</td><td>True if the according system is continuous. False for discrete systems</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>To[size(T, 1), size(T, 2)]</td><td>Reordered Schur form</td></tr>
<tr><td>Qo[size(T, 1), size(T, 2)]</td><td>Reordered Schur vector matrix</td></tr>
<tr><td>wr[size(T, 2)]</td><td>Reordered eigenvalues, real part</td></tr>
<tr><td>wi[size(T, 2)]</td><td>Reordered eigenvalues, imaginary part</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE findLocal_tk<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" alt="Modelica.Math.Matrices.Utilities.findLocal_tk" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.Math.Matrices.Utilities.findLocal_tk"></a><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</a>.findLocal_tk</h2>
<p>
<span class="ModelicaDescription">Find a local minimizer tk to define the length of the step tk*Nk in continuousRiccatiIterative and discreteRiccatiIterative</span>
</p>
<h3>Information</h3>

<h4>Syntax</h4>
<blockquote><pre>
           tk = Matrices.Utilities.<strong>findLocal_tk</strong>(Rk, Vk);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <code>findLocal_tk()</code> is an auxiliary function called in iterative solver for algebraic Riccati equation based on Newton's method with
exact line search like <a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.continuousRiccatiIterative"
>continuousRiccatiIterative</a><br>
and <a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.discreteRiccatiIterative"
>discreteRiccatiIterative</a>.<br>
The function computes the local minimum of the function f_k(t_k)
</p>
<blockquote><pre>
  f_k(t_k) = alpha_k*(1-t_k)^2 + 2*beta_k*(1-t)*t^2 + gamma_k*t^4
</pre></blockquote>
<p>
by calculating the zeros of the derivation d f_k/d t_k. It is known that the function f_k(t_k) has a local minimum at some value t_k_min in [0, 2].<br>
With t_k_min the norm of the next residual of the algorithm will be minimized.<br>
See [1] for more information
</p>
<h4>References</h4>
<pre>
  [1] Benner, P., Byers, R.
      An Exact Line Search Method for Solving Generalized Continuous-Time Algebraic Riccati Equations
      IEEE Transactions On Automatic Control, Vol. 43, No. 1, pp. 101-107, 1998.
</pre>

<h4>See also</h4>
<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.continuousRiccatiIterative"
>Matrices.Utilities.continuousRiccatiIterative</a><br>
<a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.discreteRiccatiIterative"
>Matrices.Utilities.discreteRiccatiIterative</a><br>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Rk[:, size(Rk, 1)]</td><td>&nbsp;</td></tr>
<tr><td>Vk[size(Rk, 1), size(Rk, 2)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>tk</td><td>&nbsp;</td></tr>
</table>
<address>
<a href="http://www.3ds.com/">Automatically generated</a> Thu Dec 19 17:20:25 2019.
</address>
</body>
</html>
