<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Modelica.StateGraph.UsersGuide</title>
<meta name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="&quot;User&#39;s Guide of StateGraph Library&quot;">
<style type="text/css">
*       { font-size: 100%; font-family: Arial, sans-serif; }
.modelica, .modelica * { font-size: 90%; font-family: Courier, monospace; white-space: pre; } /* For the Modelica code (in exported html). */
h4      { font-size: 100%; font-weight: bold; color: green; } 
h3      { font-size: 110%; font-weight: bold; color: green; }
h2      { font-size: 130%; font-weight: bold; color: green; }
address { font-weight: normal; }
td      { padding: 2px; border: 1px solid #808080; vertical-align: top; }
th      { padding: 2px; border: 1px solid #808080; vertical-align: top; font-weight: bold; }
table   { border: 1px solid #808080; border-collapse: collapse; }
pre, code {font-family: "Courier New", monospace;}
pre {white-space: pre; overflow-x : hidden;}
.ModelicaDescription {font-weight: bold;} /* For the description string of the class. */
.ModelicaBaseClass {} /* For the list of base-classes at the of the description. */
.ModelicaKeyword { color: blue; font-weight: normal; font-style: normal; } /* Keywords in Modelica. */
.ModelicaComment { color: #006400;  font-weight: normal; font-style: normal;} /* All three variants of comments in Modelica.  */
.ModelicaString { color: #006400;  font-weight: normal; font-style: normal;} /* String constants. */
.ModelicaClass { color: red; font-weight: normal; font-style: normal;} /* Formatting the names of referenced classes (for base-class and components). */
.ModelicaFunction { color: red; font-weight: normal; font-style: normal;} /* Formatting for called functions. */
.ModelicaTablePackageContent { } /* The table of contents for each package. */
.ModelicaTableCrossReference { } /* The optional cross-reference table. */
.ModelicaTableInputs {} /* The table of inputs for a function. */
.ModelicaTableOutputs {} /* The table of outputs for a function. */
.ModelicaTableParameters {} /* The table of parameters for a model/block. */
.ModelicaTableConnectors {} /* The table of connectors for a model/block. */
.ModelicaTableContents {} /* The table of contents for a connector. */
.ModelicaStartAttribute { font-weight: bold; } /* The formatting used for start-attribute in the table of parameters, to separate them from parameter values. */
.ModelicaParameterTab { background-color: #c0c0c0; font-weight: bold; } /* The tab-heading in the table of parameters */
.ModelicaParameterGroup { background-color: #e0e0e0; } /* The group-heading in the table of parameters */
</style>
</head>
<body>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE UsersGuide<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.StateGraph.UsersGuideI.png" alt="Modelica.StateGraph.UsersGuide" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.StateGraph.UsersGuide"></a><a href="Modelica_StateGraph.html#Modelica.StateGraph"
>Modelica.StateGraph</a>.UsersGuide</h2>
<p>
</p>

<p>
Library <strong>StateGraph</strong> is a <strong>free</strong> Modelica package providing
components to model <strong>discrete event</strong> and <strong>reactive</strong>
systems in a convenient
way. This package contains the <strong>User's Guide</strong> for
the library and has the following content:
</p>
<ol>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.OverView"
>Overview of library</a>
     gives an overview of the library.</li>
<li> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.FirstExample"
>A first example</a>
     demonstrates at hand of a first example how to use this library.</li>
<li> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ApplicationExample"
>An
     application example</a> demonstrates varies features at hand of the
     control of a two tank system.</li>
<li> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ComparisonWithStateGraph2"
>Comparison
     with StateGraph2</a> compares Modelica.StateGraph with the much improved version
     Modelica_StateGraph2.</li>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ReleaseNotes"
>Release Notes</a>
    summarizes the differences between different versions of this library.</li>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Literature"
>Literature</a>
    provides references that have been used to design and implement this
    library.</li>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Contact"
>Contact</a>
    provides information about the authors of the library as well as
    acknowledgments.</li>
</ol>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Information"
>Modelica.Icons.Information</a> (Icon for general information packages).</span></p>
<h3>Package Content</h3>
<table summary="Package Content" class="ModelicaTablePackageContent">
<tr>
<th>Name</th>
<th>Description</th>
</tr>
<tr>
<td><img src="Modelica.StateGraph.UsersGuide.OverViewS.png" alt="Modelica.StateGraph.UsersGuide.OverView" width="20" height="20" align="top">&nbsp;<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.OverView"
>OverView</a>
</td>
<td>Overview of library</td>
</tr>
<tr>
<td><img src="Modelica.StateGraph.UsersGuide.OverViewS.png" alt="Modelica.StateGraph.UsersGuide.FirstExample" width="20" height="20" align="top">&nbsp;<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.FirstExample"
>FirstExample</a>
</td>
<td>A first example</td>
</tr>
<tr>
<td><img src="Modelica.StateGraph.UsersGuide.OverViewS.png" alt="Modelica.StateGraph.UsersGuide.ApplicationExample" width="20" height="20" align="top">&nbsp;<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ApplicationExample"
>ApplicationExample</a>
</td>
<td>An application example</td>
</tr>
<tr>
<td><img src="Modelica.StateGraph.UsersGuide.OverViewS.png" alt="Modelica.StateGraph.UsersGuide.ComparisonWithStateGraph2" width="20" height="20" align="top">&nbsp;<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ComparisonWithStateGraph2"
>ComparisonWithStateGraph2</a>
</td>
<td>Comparison with StateGraph2</td>
</tr>
<tr>
<td><img src="Modelica.StateGraph.Usersdfc04877becbb6c9NotesS.png" alt="Modelica.StateGraph.UsersGuide.ReleaseNotes" width="20" height="20" align="top">&nbsp;<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ReleaseNotes"
>ReleaseNotes</a>
</td>
<td>Release notes</td>
</tr>
<tr>
<td><img src="Modelica.StateGraph.Usersa3646156a184519fatureS.png" alt="Modelica.StateGraph.UsersGuide.Literature" width="20" height="20" align="top">&nbsp;<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Literature"
>Literature</a>
</td>
<td>Literature</td>
</tr>
<tr>
<td><img src="Modelica.StateGraph.UsersGuide.ContactS.png" alt="Modelica.StateGraph.UsersGuide.Contact" width="20" height="20" align="top">&nbsp;<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Contact"
>Contact</a>
</td>
<td>Contact</td>
</tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE OverView<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.StateGraph.UsersGuideI.png" alt="Modelica.StateGraph.UsersGuide.OverView" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.StateGraph.UsersGuide.OverView"></a><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide"
>Modelica.StateGraph.UsersGuide</a>.OverView</h2>

<p>
In this section, an overview of the most important features
of this library is given.
</p>
<h4>Steps and Transitions</h4>
<p>
A <strong>StateGraph</strong> is an enhanced finite state machine.
It is based on the JGrafchart method and
takes advantage of Modelica features for
the "action" language. JGrafchart is a further development of
Grafcet to include elements of StateCharts that are not present
in Grafcet/Sequential Function Charts. Therefore, the StateGraph
library has a similar modeling power as StateCharts but avoids
some deficiencies of StateCharts.
</p>
<p>
The basic elements of StateGraphs are <strong>steps</strong> and <strong>transitions</strong>:
</p>

<p>
<img src="../Images/StateGraph/UsersGuide/StepAndTransition1.png">
</p>

<p>
<strong>Steps</strong> represent the possible states a StateGraph can have.
If a step is active the Boolean variable <strong>active</strong> of
the step is <strong>true</strong>. If it is deactivated,
<strong>active</strong> = <strong>false</strong>. At the initial time, all "usual"
steps are deactivated. The <strong>InitialStep</strong> objects are steps
that are activated at the initial time. They are characterized
by a double box (see figure above).
</p>
<p>
<strong>Transitions</strong> are used to change the state of a StateGraph.
When the step connected to the input of a transition is active,
the step connected to the output of this transition is deactivated
and the transition condition becomes true, then the
transition fires. This means that the step connected to the input to the
transition is deactivated and the step connected to the output
of the transition is activated.
</p>
<p>
The transition <strong>condition</strong> is defined via the parameter menu
of the transition object. Clicking on object "transition1" in
the above figure, results in the following menu:
</p>

<p>
<img src="../Images/StateGraph/UsersGuide/StepAndTransition2.png">
</p>

<p>
In the input field "<strong>condition</strong>", any type of time varying
Boolean expression can be given (in Modelica notation, this is
a modification of the time varying variable <strong>condition</strong>).
Whenever this condition is true, the transition can fire.
Additionally, it is possible to activate a timer, via
<strong>enableTimer</strong> (see menu above) and provide a
<strong>waitTime</strong>. In this case the firing of the transition
is delayed according to the provided waitTime. The transition
condition and the waitTime are displayed in the transition icon.
</p>
<p>
In the above example, the simulation starts at <strong>initialStep</strong>.
After 1 second, <strong>transition1</strong> fires and <strong>step1</strong> becomes
active. After another second <strong>transition2</strong> fires and
<strong>initialStep</strong> becomes again active. After a further
second <strong>step1</strong> becomes again active, and so on.
</p>
<p>
In JGrafcharts, Grafcet and Sequential Function Charts, the
network of steps and transitions is drawn from top to bottom.
In StateGraphs, no particular direction is defined, since
steps and transitions are blocks with input and output connectors
that can be arbitrarily placed and connected. Usually, it is
most practical to define the network from left to right,
as in the example above, since then it is easy to read the
labels on the icons.
</p>
<h4>Conditions and Actions</h4>
<p>
With the block <strong>TransitionWithSignal</strong>, the firing condition
can be provided as Boolean input signal, instead as entry in the
menu of the transition. An example is given in the next
figure:
</p>

<p>
<img src="../Images/StateGraph/UsersGuide/StepAndTransition3.png">
</p>

<p>
Component "step" is an instance of "StepWithSignal" that is
a usual step where the active flag is available as Boolean
output signal. To this output, component "Timer" from
library "Modelica.Blocks.Logical" is connected. It measures the
time from the time instant where the Boolean input (i.e., the
active flag of the step) became true up to the current
time instant. The timer is connected to a comparison
component. The output is true, once the timer reaches
1 second. This signal is used as condition input of the
transition. As a result, "transition2" fires, once step
"step" has been active for 1 second.
Of course, any other
Modelica block with a Boolean output signal can be
connected to the condition input of such a transition block
as well.
</p>
<p>
Conditions of a transition can either be computed by
a network of logical blocks from the Logical library as
in the figure above, or via the "SetBoolean" component
any type of logical expression can be defined in textual
form, as shown in the next figure:
</p>

<p>
<img src="../Images/StateGraph/UsersGuide/StepAndTransition4.png">
</p>

<p>
With the block "<strong>SetBoolean</strong>", a time varying expression
can be provided as modification to the output signal <strong>y</strong>
(see block with icon text "timer.y > 1" in the figure above).
The output signal can be in turn connected to the condition
input of a TransitionWithSignal block.
</p>
<p>
The "<strong>SetBoolean</strong>" block can also be used to
compute a Boolean signal depending on the active step.
In the figure above, the output of the block with the
icon text "step.active" is
true, when "step" is active, otherwise it is false
(note, the icon text of "SetBoolean" displays the modification
of the output signal "y").
This signal can then be used to compute desired <strong>actions</strong>
in the physical systems model. For example, if a <strong>valve</strong>
shall be open, when the StateGraph is in "step1" or
in "step4", a "SetBoolean" block may be connected to the
valve model using the following condition:
</p>
<pre>
    valve = step1.active <strong>or</strong> step2.active
</pre>
<p>
Via the Modelica operators <strong>edge</strong>(..) and <strong>change</strong>(..),
conditions depending on rising and falling edges of
Boolean expressions can be used when needed.
</p>
<p>
In JGrafcharts, Grafcet, Sequential Function Charts and StateCharts,
<strong>actions</strong> are formulated <strong>within a step</strong>. Such actions are
distinguished as <strong>entry</strong>, <strong>normal</strong>, <strong>exit</strong> and
<strong>abort</strong> actions. For example, a valve might be opened by
an entry action of a step and might be closed by an exit
action of the same step. In StateGraphs, this is (fortunately)
<strong>not possible</strong>
due to Modelica's "single assignment rule" that requires that every
variable is defined by exactly one equation. Instead, the
approach explained above is used. For example, via the
"SetBoolean" component, the valve variable is set to true
when the StateGraph is in particular steps.
</p>
<p>
This feature of a StateGraph is <strong>very useful</strong>, since it allows
a Modelica translator to <strong>guarantee</strong> that a given StateGraph
has always <strong>deterministic</strong> behaviour without conflicts.
In the other methodologies this is much more cumbersome. For example,
if two steps are executed in parallel and both step actions
modify the same variable, the result is either non-deterministic
or non-obvious rules have to be defined which action
takes priority. In a StateGraph, such a situation is detected by
the translator resulting in an error, since there are two equations
to compute one variable. Additional benefits of the StateGraph
approach are:
</p>
<ul>
<li> A JGrafchart or a StateChart need to potentially access
     variables in a step that are defined in
     higher hierarchical levels of a model. Therefore, mostly <strong>global
     variables</strong> are used in the whole network, even if the
     network is structured hierarchically. In StateGraphs this
     is not necessary, since the physical systems outside
     of a StateGraph might access the step or transition state
     via a hierarchical name. This means that <strong>no global variables</strong>
     are needed, because the local variables in the StateGraph
     are accessed from local variables outside of the StateGraph.
     </li>
<li> It is simpler for a user to understand the information that
     is provided in the non-graphical definition, since every
     variable is defined at exactly one place. In the other
     methodologies, the setting and re-setting of the same
     variable is cluttered within the whole network.
    </li>
</ul>
<p>
To emphasize this important difference between these methodologies,
consider the case that a state machine has the following
hierarchy:
</p>
<pre>
   stateMachine.superstate1.superstate2.step1
</pre>
<p>
Within "step1" a StateChart would, e.g., access variable
"stateMachine.openValve", say as "entry action: openValve = true".
This typical usage has the severe drawback that it is not possible
to use the hierarchical state "superstate1" as component in another
context, because "step1" references a particular name outside of this
component.
</p>
<p>
In a StateGraph, there would be typically a "SetBoolean" component
in the "stateMachine" component stating:
</p>
<pre>
    openValve = superstate1.superstate2.step1.active;
</pre>
<p>
As a result, the "superstate1" component can be used in
another context, because it does not depend on the environment
where it is used.
</p>
<h4>Execution Model</h4>
<p>
The execution model of a StateGraph follows from its
Modelica implementation: Given the states of all steps, i.e.,
whether a step is active or not active, the equations of all
steps, transitions, transition conditions, actions etc. are
sorted resulting in an execution sequence to compute
essentially the new values of the steps. If conflicts occur,
e.g., if there are more equations as variables, of if there
are algebraic loops between Boolean variables, an exception
is raised. Once all equations have been processed, the
<strong>active</strong> variable of all steps are updated to the newly
calculated values. Afterwards, the equations are again
evaluated. The iteration stops, once no step changes
its state anymore, i.e., once no transition fires anymore.
Then, simulation continuous until a new event is triggered,
(when a relation changes its value).
</p>
<p>
With the Modelica "sampled(..)" operator, a StateGraph might also
be executed within a discrete controller that is called
at regular time instants. In a future version of the StateGraph
library, this might be more directly supported.
</p>
<h4>Parallel and Alternative Execution</h4>
<p>
Parallel activities can be defined by
component <strong>Parallel</strong> and alternative activities
can be defined by component <strong>Alternative</strong>.
An example for both components is given in the next figure.
</p>

<p>
<img src="../Images/StateGraph/UsersGuide/Parallel1.png">
</p>

<p>
Here, the branch from "step2" to "step5" is executed in parallel
to "step1". A transition connected to the output of a parallel
branch component can only fire if the final steps
in all parallel branches are active simultaneously.
The figure above is a screen-shot from the animation of the
StateGraph: Whenever a step is active or a transition can fire,
the corresponding component is marked in <strong>green</strong> color.
</p>
<p>
The three branches within "step2" to "step5" are
executed alternatively, depending which transition condition
of "transition3", "transition4", "transition4a" fires first.
Since all three transitions fire after 1 second, they are all
candidates for the active branch. If two or more transitions
would fire at the same time instant, a priority selection
is made: The alternative and parallel components have a
vector of connectors. Every branch has to be connected to
exactly one entry of the connector vector. The entry with
the lowest number has the highest priority.
</p>
<p>
Parallel, Alternative and Step components have vectors of
connectors. The dimensions of these vectors are set in the
corresponding parameter menu. E.g. in a "Parallel" component:
</p>

<p>
<img src="../Images/StateGraph/UsersGuide/Parallel2.png">
</p>

<p>
Currently in Dymola the following menu pops up, when a branch
is connected to a vector of components in order to define
the vector index to which the component shall be connected:
</p>

<p>
<img src="../Images/StateGraph/UsersGuide/Parallel3.png">
</p>

<h4>CompositeSteps, Suspend and Resume Port</h4>
<p>
A StateGraph can be hierarchically structured by using a <strong>CompositeStep</strong>.
This is a component that inherits from <strong>PartialCompositeStep</strong>.
An example is given in the next figure (from Examples.ControlledTanks):
</p>

<p>
<img src="../Images/StateGraph/UsersGuide/CompositeStep1.png">
</p>

<p>
The CompositeStep component contains a local StateGraph that is
entered by one or more input transitions and that is left
by one or more output transitions. Also, other needed signals
may enter a CompositeStep. The CompositeStep has similar properties
as a "usual" step: The CompositeStep is <strong>active</strong> once at least
one step within the CompositeStep is active. Variable <strong>active</strong>
defines the state of the CompositeStep.
</p>
<p>
Additionally, a CompositeStep has a <strong>suspend</strong> port. Whenever the
transition connected to this port fires, the CompositeStep is left
at once. When leaving the CompositeStep via the suspend port, the internal
state of the CompositeStep is saved, i.e., the active flags of all
steps within the CompositeStep. The CompositeStep might be entered via
its <strong>resume</strong> port. In this case the internal state from the
suspend transition is reconstructed and the CompositeStep continues
the execution that it had before the suspend transition fired
(this corresponds to the history ports of StateCharts or JGrafcharts).
</p>
<p>
A CompositeStep may contain other CompositeSteps. At every level,
a CompositeStep and all of its content can be left via its suspend ports
(actually, there
is a vector of suspend connectors, i.e., a CompositeStep might
be aborted due to different transitions).
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Information"
>Modelica.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE FirstExample<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.StateGraph.UsersGuideI.png" alt="Modelica.StateGraph.UsersGuide.FirstExample" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.StateGraph.UsersGuide.FirstExample"></a><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide"
>Modelica.StateGraph.UsersGuide</a>.FirstExample</h2>

<p>
A first example will be given here (not yet done).
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Information"
>Modelica.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE ApplicationExample<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.StateGraph.UsersGuideI.png" alt="Modelica.StateGraph.UsersGuide.ApplicationExample" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.StateGraph.UsersGuide.ApplicationExample"></a><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide"
>Modelica.StateGraph.UsersGuide</a>.ApplicationExample</h2>

<p>
In this section a more realistic, still simple, application example
is given, to demonstrate various features of the StateGraph library.
This example shows the control of a two tank system from the master thesis
of Isolde Dressler
(<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Literature"
>see literature</a>).
</p>
<p>
In the following figure the top level of the model is shown.
This model is available as StateGraph.Examples.ControlledTanks.
</p>

<p>
<img src="../Images/StateGraph/Examples/ControlledTanks1.png">
</p>

<p>
In the right part of the figure, two tanks are shown. At the top part,
a large fluid source is present from which fluid can be filled in
<strong>tank1</strong> when <strong>valve1</strong> is open. Tank1 can be emptied via
<strong>valve2</strong> that is located in the bottom of tank2 and
fills a second <strong>tank2</strong> which in turn is emptied via
<strong>valve3</strong>. The actual levels of the tanks are measured
and are provided as signals <strong>level1</strong> and <strong>level2</strong>
to the <strong>tankController</strong>.
</p>
<p>
The <strong>tankController</strong> is controlled by three buttons,
<strong>start</strong>, <strong>stop</strong> and <strong>shut</strong> (for shutdown)
that are mutually exclusive. This means that whenever one button is
pressed (i.e., its state is <strong>true</strong>) then the other two
buttons are not pressed (i.e., their states are <strong>false</strong>).
When button <strong>start</strong> is pressed, the "normal" operation
to fill and to empty the two tanks is processed:
</p>
<ol>
<li> Valve 1 is opened and tank 1 is filled.</li>
<li> When tank 1 reaches its fill level limit,
     valve 1 is closed.</li>
<li> After a waiting time, valve 2 is
     opened and the fluid flows from tank 1 into tank 2.</li>
<li> When tank 1 is empty, valve 2 is closed.</li>
<li> After a waiting time, valve 3 is opened and
     the fluid flows out of tank 2</li>
<li> When tank 2 is empty, valve 3 is closed</li>
</ol>
<p>
The above "normal" process can be influenced by the following
buttons:
</p>
<ul>
<li> Button <strong>start</strong> starts the above process.
     When this button is pressed after a "stop" or
     "shut" operation, the process operation continues.
     </li>
<li> Button <strong>stop</strong> stops the above process by
     closing all valves. Then, the controller waits for
     further input (either "start" or "shut" operation).</li>
<li> Button <strong>shut</strong> is used to shutdown the process,
     by emptying at once both tanks. When this is achieved,
     the process goes back to its start configuration.
     Clicking on "start", restarts the process.</li>
</ul>
<p>
The implementation of the <strong>tankController</strong> is shown in
the next figure:
</p>

<p>
<img src="../Images/StateGraph/Examples/ControlledTanks2.png">
</p>

<p>
When the "<strong>start</strong>" button is pressed, the stateGraph is
within the CompositeStep "<strong>makeProduct</strong>". During normal
operation this CompositeStep is only left, once tank2 is empty.
Afterwards, the CompositeStep is at once re-entered.
</p>
<p>
When the "<strong>stop</strong>" button is pressed, the "makeProduct"
CompositeStep is at once terminated via the "<strong>suspend</strong>" port
and the stateGraph waits in step "<strong>s2</strong>" for further
commands. When the "<strong>start</strong>" button is pressed, the CompositeStep
is re-entered via its <strong>resume</strong> port and the "normal"
operation continues at the state where it was aborted by the
suspend transition. If the "<strong>shut</strong>" button is pressed,
the stateGraph waits in the "<strong>emptyTanks</strong>" step, until
both tanks are empty and then waits at the initial step
"<strong>s1</strong>" for further input.
</p>
<p>
The opening and closing of valves is <strong>not</strong> directly
defined in the stateGraph. Instead via the "<strong>setValveX</strong>"
components, the Boolean state of the valves are computed.
For example, the output y of "setValve2" is computed as:
</p>
<pre>
  y = makeProduct.fillTank2.active or emptyTanks.active
</pre>
<p>
i.e., valve2 is open, when step "makeProduct.fillTank2 or when
step "emptyTanks" is active. Otherwise, valve2 is closed.
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Information"
>Modelica.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE ComparisonWithStateGraph2<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.StateGraph.UsersGuideI.png" alt="Modelica.StateGraph.UsersGuide.ComparisonWithStateGraph2" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.StateGraph.UsersGuide.ComparisonWithStateGraph2"></a><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide"
>Modelica.StateGraph.UsersGuide</a>.ComparisonWithStateGraph2</h2>

<p>
There is a much improved library available called "Modelica_StateGraph2".
If this library is not yet distributed with your Modelica tool, you can download
it from <a href="https://github.com/modelica/Modelica_StateGraph2">https://github.com/modelica/Modelica_StateGraph2</a>.
Find below a comparison with respect to Modelica.StateGraph.
It is not yet clear whether Modelica_StateGraph2 will be included in a
future version of the Modelica package. Another option is to provide
built-in support for state machines in a future Modelica language version
which would allow an even more powerful treatment of state machines in Modelica.
</p>

<p>
The Modelica_StateGraph2 library (called <u>StateGraph2</u> below)
is based on the experience with the current
Modelica.StateGraph library (called <u>StateGraph1</u> below) and is
a significantly further development of StateGraph1. Furthermore, it is heavily
based on the article (Malmheden et. al. 2008), see Literature below,
but uses a different implementation
technique as described in this article. The StateGraph2
library has the following improvements with respect to the StateGraph1
library:
</p>

<ul>
<li> <strong>3 Basic Components (Step, Transition, Parallel)</strong><br>
     All multiple versions of a component are
     combined in only one version (e.g., one step and not 4 step components).
     This is easier to understand and more convenient to use.
     The "Parallel" component is both used as "composite step" (so only one branch),
     as well as "parallel step" (so several execution branches).<br>&nbsp;</li>

<li> <strong>Conveniently connecting components</strong><br>
     Connecting components of a state machine in Modelica means to provide
     new vector dimensions and to provide a vector index to connect to.
     In StateGraph2, the new "connectorSizing" annotation is used and
     therefore all this is now performed automatically (from a users point
     of view, these actions are hidden; this is not the case in
     StateGraph1 and makes the usage of the StateGraph1 library clumsy).<br>&nbsp;</li>

<li> <strong>Safer state machines</strong><br>
     It is no longer possible to construct a wrong state machine in the sense that properties
     of the graph are violated (e.g., two initial steps, or branching wrongly out of a parallel
     component). Contrary to StateGraph2, in StateGraph1 such wrong graphs do not lead to an
     error but to unexpected simulation results. Still, other desirable properties
     of a state machine,  such as "no deadlock" or "lifeliness" or "every step reachable",
     are not (yet) guaranteed with the current StateGraph2.<br>&nbsp;</li>

<li> <strong>Composite, autonomous, synchronized, preempted subgraphs</strong><br>
     Composite steps and parallel steps are described in a much better and more powerful
     way as in StateGraph1: Either by component "Parallel" or
     by inheriting from "PartialParallel". The first alternative has the advantage that it
     is simple to use (not necessary to construct a new class and instantiating this class, and
     easy variable access since no new hierarchy is constructed), the second alternative
     has the advantage that it introduces a Modelica hierarchy (useful for large subgraphs).
     In both cases, various options are possible, such as
     <ol>
     <li> autonomous subgraphs (branches are executed in parallel autonomously),</li>
     <li> synchronized subgraphs (branches are executed in parallel and are synchronized
           before leaving the subgraph via the outPort),</li>
     <li> subgraphs with preemption and exception (a parallel step can be interrupted via
          the suspend ports and can continue execution via the resume ports).</li>
     </ol>
     This is achieved by enabling/disabling the different ports.<br>&nbsp;</li>
<li> <strong>No infinite looping</strong>:<br>
     As in StateGraph1, there are two types of transitions: immediate transitions (during event
     iteration all immediate transitions fire until no transition condition is true anymore) and
     delayed transitions (a transition fires only after a delay). Contrary to StateGraph1,
     in StateGraph2 every loop must have at least one delayed transition. If this is not the case
     a translation error occurs which states that the model contains an algebraic loop
     between Booleans with the name "checkOneDelayedTransitionPerLoop".<br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This property guarantees that an event
     iteration over a StateGraph2 converges after a
     finite number of iterations, provided the modeller does not introduce an unsafe construct
     in the actions associated with a StateGraph2 (e.g., "i = pre(i) + 1" in the equation section
     outside of a when-clause will give an event iteration that never stops).<br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It is possible to switch off this feature, by setting parameter
     "loopCheck = <strong>false</strong>" in one transition of a loop, instead of using a "delayed transition"
     at this place (in cases where immediate transitions are
     important and the transition conditions are in a form that they cannot fire at the
     same time instant).</li>
</ul>

<h4> Literature </h4>

<p>
The Modelica_StateGraph2 library is described in detail in
(Otter et. al. 2009, see below) and is additionally
based on the following references:
</p>

<dl>
<dt>Andr&eacute;, C. (2003):</dt>
<dd><a href="http://www.i3s.unice.fr/~map/WEBSPORTS/Documents/2003a2005/SSMsemantics.pdf">
     Semantics of S.S.M (Safe State Machine).</a>.
     I3S Laboratory, UMR 6070 University of Nice-Sophia Antipolis / CNRS.<br>&nbsp;</dd>

<dt>&Aring;rz&eacute;n K.-E. (2004):</dt>
<dd> <strong>JGrafchart User Manual. Version 1.5</strong>.
     Department of Automatic Control, Lund Institute of Technology,
     Lund, Sweden, Feb. 13, 2004.<br>&nbsp;</dd>

<dt>Dressler I. (2004):</dt>
<dd> <a href="http://www.control.lth.se/documents/2004/5726.pdf">
     Code Generation From JGrafchart to Modelica.</a>.
     Master thesis, supervisor: Karl-Erik &Aring;rz&eacute;n,
     Department of Automatic Control, Lund Institute of Technology,
     Lund, Sweden, March 30, 2004.<br>&nbsp;</dd>

<dt>Elmqvist H., Mattsson S.E., Otter M. (2001):</dt>
<dd> <strong>Object-Oriented and Hybrid Modeling in Modelica</strong>.
     Journal Europeen des systemes automatises (JESA),
     Volume 35 - n. 1, 2001.<br>&nbsp;</dd>

<dt>Harel, D. (1987):</dt>
<dd> <a href="http://www.inf.ed.ac.uk/teaching/courses/seoc1/2005_2006/resources/statecharts.pdf">
      A Visual Formalism for Complex Systems</a>.
      Science of Computer Programming 8, 231-274. Department of Applied Mathematics,
      The Weizmann Institute of Science, Rehovot, Israel.<br>&nbsp;</dd>

<dt>Malmheden M. (2007):</dt>
<dd> <a href="http://www.control.lth.se/documents/2007/5808.pdf">
      ModeGraph - A Mode-Automata-Based Modelica Library for Embedded Control</a>.
      Master thesis, Department of Automatic Control, Lund University, Sweden.<br>&nbsp;
     </dd>

<dt>Malmheden M., Elmqvist H., Mattsson S.E., Henrisson D., Otter M. (2008):</dt>
<dd> <a href="https://www.modelica.org/events/modelica2008/Proceedings/sessions/session3a3.pdf">
      ModeGraph - A Modelica Library for Embedded Control based on Mode-Automata</a>.
      Modelica'2008 Conference, March 3-4, 2008.<br>&nbsp;
     </dd>

<dt>Maraninchi F., R&eacute;mond, Y. (2002):</dt>
<dd> <a href="http://dx.doi.org/10.1016/S0167-6423(02)00093-X">Mode-Automata:
     A New Domain-Specific Construct for the Development of Safe Critical Systems</a>.<br>&nbsp;
     </dd>

<dt>Mosterman P., Otter M., Elmqvist H. (1998):</dt>
<dd><a href="https://www.modelica.org/publications/papers/scsc98fp.pdf">
     Modeling Petri Nets as Local Constraint Equations for
     Hybrid Systems using Modelica</a>.
     SCSC'98, Reno, Nevada, USA,
     Society for Computer Simulation International, pp. 314-319, 1998.<br>&nbsp;
     </dd>

<dt>Otter M., Malmheden M., Elmqvist H., Mattsson S.E., Johnsson C. (2009):</dt>
<dd> <a href="https://www.modelica.org/events/modelica2009">
     A New Formalism for Modeling of Reactive and Hybrid Systems</a>.
      Modelica'2009 Conference, Como, Italy, Sept. 20-22, 2009.
     </dd>
</dl>


<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Information"
>Modelica.Icons.Information</a> (Icon for general information packages).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE ReleaseNotes<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.StateGraph.Usersdfc04877becbb6c9NotesI.png" alt="Modelica.StateGraph.UsersGuide.ReleaseNotes" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.StateGraph.UsersGuide.ReleaseNotes"></a><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide"
>Modelica.StateGraph.UsersGuide</a>.ReleaseNotes</h2>

<h4>Version 0.87, 2004-06-23</h4>
<ul>
<li> Included in Modelica standard library 2.0 Beta 1 with the new block connectors.
     Changed all the references to the block connectors and the Logical library
     correspondingly.</li>
</ul>
<h4>Version 0.86, 2004-06-20</h4>
<ul>
<li> New components "Alternative" and "Parallel" for alternative and
     parallel execution paths.</li>
<li> A step has now a vector of input and output connectors in order
     that multiple connections to and from a step are possible</li>
<li> Removed components "AlternativeSplit", "AlternativeJoin",
     "ParallelSplit" and "ParallelJoin" since the newly introduced
     components ("Alternative", "Parallel", vector connectors of steps)
     have the same modeling power but are safer and more convenient.</li>
<li> Removed the timer in a step (attach instead Logical.Timer to
     the "active" port of a "StepWithSignal" component). Note, that in
     most cases it is more convenient and more efficient to use the
     built-in timer of a transition.</li>
<li> Component "StepInitial" renamed to "InitialStep".</li>
<li> New component "Timer" within sublibrary Logical.</li>
<li> Updated and improved documentation of the library.</li>
</ul>
<h4>Version 0.85, 2004-06-17</h4>
<ul>
<li> Renamed "MacroStep" to "CompositeStep" and the ports of the MacroStep
     from "abort" to "suspend" and "history" to "resume".</li>
<li> Nested "CompositeStep" components are supported, based on the
     experimental feature of nested inner/outer components
     introduced by Dymola. This means that CompositeSteps can
     be suspended and resumed at every level.</li>
<li> New example "Examples.ShowExceptions" to demonstrate the new
     feature of nested CompositeSteps.</li>
<li> New package "Logical". It contains all components of
     ModelicaAdditions.Blocks.Logical, but with new block connectors
     and nicer icons. Additionally, logical blocks are also added.</li>
<li> Improved icons for several components of the StateGraph library.</li>
</ul>
<h4>Version 0.83, 2004-05-21</h4>
<ul>
<li> The "abort" and "history" connectors are no longer visible in the
     diagram layer of a CompositeStep since it is not allowed to connect
     to them in a CompositeStep.</li>
<li> Made the diagram/icon size of a CompositeStep smaller (from 200/-200 to
     150/-150).</li>
<li> Improved icons for "SetBoolean/SetInteger/SetReal" components.</li>
<li> Renamed "ParameterReal" to "SetRealParameter".</li>
</ul>
<h4>Version 0.82, 2004-05-18</h4>
<p>
Implemented a first version that is provided to other people.
</p>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.ReleaseNotes"
>Modelica.Icons.ReleaseNotes</a> (Icon for release notes in documentation).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE Literature<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.StateGraph.Usersa3646156a184519fatureI.png" alt="Modelica.StateGraph.UsersGuide.Literature" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.StateGraph.UsersGuide.Literature"></a><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide"
>Modelica.StateGraph.UsersGuide</a>.Literature</h2>

<p>
The StateGraph library is based on the following references:
</p>
<dl>
<dt>&Aring;rz&eacute;n K.-E. (2004):</dt>
<dd> <strong>JGrafchart User Manual. Version 1.5</strong>.
     Department of Automatic Control, Lund Institute of Technology,
     Lund, Sweden, Feb. 13<br>&nbsp;</dd>
<dt>Dressler I. (2004):</dt>
<dd> <strong>Code Generation From JGrafchart to Modelica</strong>.
     Master thesis, supervisor: Karl-Erik &Aring;rz&eacute;n,
     Department of Automatic Control, Lund Institute of Technology,
     Lund, Sweden, March 30<br>&nbsp;</dd>
<dt>Elmqvist H., Mattsson S.E., Otter M. (2001):</dt>
<dd> <strong>Object-Oriented and Hybrid Modeling in Modelica</strong>.
     Journal Europeen des systemes automatises (JESA),
     Volume 35 - n. 1.<br>&nbsp;</dd>
<dt>Mosterman P., Otter M., Elmqvist H. (1998):</dt>
<dd> <strong>Modeling Petri Nets as Local Constraint Equations for
     Hybrid Systems using Modelica</strong>.
     SCSC'98, Reno, Nevada, USA,
     Society for Computer Simulation International, pp. 314-319.
     </dd>
</dl>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.References"
>Modelica.Icons.References</a> (Icon for external references).</span></p>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE Contact<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica.StateGraph.UsersGuide.ContactI.png" alt="Modelica.StateGraph.UsersGuide.Contact" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica.StateGraph.UsersGuide.Contact"></a><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide"
>Modelica.StateGraph.UsersGuide</a>.Contact</h2>

<h4>Main author</h4>

<p>
<a href="http://www.robotic.dlr.de/Martin.Otter/"><strong>Martin Otter</strong></a><br>
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e.V. (DLR)<br>
Institut f&uuml;r Systemdynamik und Regelungstechnik (DLR-SR)<br>
Forschungszentrum Oberpfaffenhofen<br>
D-82234 Wessling<br>
Germany<br>
email: <a href="mailto:Martin.Otter@dlr.de">Martin.Otter@dlr.de</a>
</p>

<h4>Acknowledgements</h4>

<ul>
<li> The development of this library was strongly motivated by the
     master thesis of Isolde Dressler
     (<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Literature"
>see literature</a>),
     in which
     a compiler from JGrafchart to Modelica was designed and
     implemented. This project was supervised by Karl-Erik &Aring;rz&eacute;n
     from Department of Automatic Control, Lund Institut of
     Technology, Lund, Sweden.</li>
<li> This library profits also from the experience gained
     in the focused research program (Schwerpunktprogramm)
     "Continuous-Discrete Dynamic Systems" (KONDISK), sponsored by the
     Deutsche Forschungsgemeinschaft under grants OT174/1-2 and EN152/22-2.
     This support is most gratefully acknowledged.
 </li>
<li> The implementation of the basic components of this library by describing
     finite state machines with equations is based on
     (Elmqvist, Mattsson and Otter, 2001),
     which in turn uses ideas from (Mosterman, Otter and Elmqvist, 1998),
     see <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Literature"
>literature</a></li>
</ul>

<p><span class="ModelicaBaseClass">Extends from <a href="Modelica_Icons.html#Modelica.Icons.Contact"
>Modelica.Icons.Contact</a> (Icon for contact information).</span></p>
<address>
<a href="http://www.3ds.com/">Automatically generated</a> Thu Dec 19 17:19:53 2019.
</address>
</body>
</html>
