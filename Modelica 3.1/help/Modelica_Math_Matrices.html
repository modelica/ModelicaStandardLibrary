<HTML>
<HEAD>
<TITLE>Modelica.Math.Matrices</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Library of functions operating on matrices&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal}
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Matrices<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Math.Matrices"></A><A HREF="Modelica_Math.html#Modelica.Math"
>Modelica.Math</A>.Matrices</H2>
<B>Library of functions operating on matrices</B>
<P>
<P><H3>Information</H3>
<PRE></pre>
<h4>Library content</h4>
<p>
This library provides functions operating on matrices:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><i>Function</i></th>
      <th><i>Description</i></th>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.isEqual"
>isEqual</a>(M1, M2)</td>
      <td valign="top">Determines whether two matrices have the same size and elements</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.norm"
>norm</a>(A)</td>
      <td valign="top">1-, 2- and infinity-norm of matrix A</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.sort"
>sort</a>(M)</td>
      <td valign="top">Sort rows or columns of matrix in ascending or descending order</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>solve</a>(A,b)</td>
      <td valign="top">Solve real system of linear equations A*x=b with a b vector</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2"
>solve2</a>(A,B)</td>
      <td valign="top">Solve real system of linear equations A*X=B with a B matrix</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares"
>leastSquares</a>(A,b)</td>
      <td valign="top">Solve overdetermined or underdetermined real system of <br>
          linear equations A*x=b in a least squares sense</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.equalityLeastSquares"
>equalityLeastSquares</a>(A,a,B,b)</td>
      <td valign="top">Solve a linear equality constrained least squares problem:<br>
          min|A*x-a|^2 subject to B*x=b</td>
  </tr>
  <tr><td valign="top">(LU,p,info) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>LU</a>(A)</td>
      <td valign="top">LU decomposition of square or rectangular matrix</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>LU_solve</a>(LU,p,b)</td>
      <td valign="top">Solve real system of linear equations P*L*U*x=b with a<br>
          b vector and an LU decomposition from "LU(..)"</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve2"
>LU_solve2</a>(LU,p,B)</td>
      <td valign="top">Solve real system of linear equations P*L*U*X=B with a<br>
          B matrix and an LU decomposition from "LU(..)"</td>
  </tr>
  <tr><td valign="top">(Q,R,p) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.QR"
>QR</a>(A)</td>
      <td valign="top"> QR decomposition with column pivoting of rectangular matrix (Q*R = A[:,p]) </td>
  </tr>
  <tr><td valign="top">eval = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>eigenValues</a>(A)<br>
          (eval,evec) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>eigenValues</a>(A)</td>
      <td valign="top"> Compute eigenvalues and optionally eigenvectors<br>
           for a real, nonsymmetric matrix </td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix"
>eigenValueMatrix</a>(eigen)</td>
      <td valign="top"> Return real valued block diagonal matrix J of eigenvalues of
            matrix A (A=V*J*Vinv) </td>
  </tr>
  <tr><td valign="top">sigma = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues"
>singularValues</a>(A)<br>
      (sigma,U,VT) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues"
>singularValues</a>(A)</td>
      <td valign="top"> Compute singular values and optionally left and right singular vectors </td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.det"
>det</a>(A)</td>
      <td valign="top"> Determinant of a matrix (do <b>not</b> use; use rank(..))</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.inv"
>inv</a>(A)</td>
      <td valign="top"> Inverse of a matrix </td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank"
>rank</a>(A)</td>
      <td valign="top"> Rank of a matrix </td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.balance"
>balance</a>(A)</td>
      <td valign="top">Balance a square matrix to improve the condition</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.exp"
>exp</a>(A)</td>
      <td valign="top"> Compute the exponential of a matrix by adaptive Taylor series<br>
           expansion with scaling and balancing</td>
  </tr>
  <tr><td valign="top">(P, G) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExp"
>integralExp</a>(A,B)</td>
      <td valign="top"> Compute the exponential of a matrix and its integral</td>
  </tr>
  <tr><td valign="top">(P, G, GT) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExpT"
>integralExpT</a>(A,B)</td>
      <td valign="top"> Compute the exponential of a matrix and two integrals</td>
  </tr>
</table>

<p>
Most functions are solely an interface to the external LAPACK library
(<a href="http://www.netlib.org/lapack">http://www.netlib.org/lapack</a>).
The details of this library are described in:
</p>

<dl>
<dt>Anderson E., Bai Z., Bischof C., Blackford S., Demmel J., Dongarra J.,
    Du Croz J., Greenbaum A., Hammarling S., McKenney A., and Sorensen D.:</dt>
<dd> <b>Lapack Users' Guide</b>.
     Third Edition, SIAM, 1999.</dd>
</dl>

<h4>See also</h4>
<A HREF="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Vectors</a>

<pre>
</PRE><P>
Extends from <A HREF="Modelica_Icons_Library.html#Modelica.Icons.Library"
>Modelica.Icons.Library</A> (Icon for library).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.isEqual" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.isEqual"
>isEqual</A>
</TD><TD>Compare whether two Real matrices are identical</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.norm" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.norm"
>norm</A>
</TD><TD>Returns the norm of a matrix</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.sort" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.sort"
>sort</A>
</TD><TD>Sort rows or columns of matrix in ascending or descending order</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.solve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>solve</A>
</TD><TD>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.solve2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2"
>solve2</A>
</TD><TD>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.leastSquares" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares"
>leastSquares</A>
</TD><TD>Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.equalityLeastSquares" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.equalityLeastSquares"
>equalityLeastSquares</A>
</TD><TD>Solve a linear equality constrained least squares problem</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.LU" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>LU</A>
</TD><TD>LU decomposition of square or rectangular matrix</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.LU_solve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>LU_solve</A>
</TD><TD>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.LU_solve2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve2"
>LU_solve2</A>
</TD><TD>Solve real system of linear equations P*L*U*X=B with a B matrix and an LU decomposition (from LU(..))</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.QR" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.QR"
>QR</A>
</TD><TD>QR decomposition of a square matrix with column pivoting (A(:,p) = Q*R)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.eigenValues" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>eigenValues</A>
</TD><TD>Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.eigenValueMatrix" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix"
>eigenValueMatrix</A>
</TD><TD>Return real valued block diagonal matrix J of eigenvalues of matrix A (A=V*J*Vinv)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.singularValues" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues"
>singularValues</A>
</TD><TD>Compute singular values and left and right singular vectors</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.det" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.det"
>det</A>
</TD><TD>Determinant of a matrix (computed by LU decomposition)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.inv" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.inv"
>inv</A>
</TD><TD>Inverse of a matrix (try to avoid, use function solve(..) instead)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.rank" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank"
>rank</A>
</TD><TD>Rank of a matrix (computed with singular values)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.balance" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.balance"
>balance</A>
</TD><TD>Balancing of matrix A to improve the condition of A</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.exp" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.exp"
>exp</A>
</TD><TD>Compute the exponential of a matrix by adaptive Taylor series expansion with scaling and balancing</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.integralExp" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExp"
>integralExp</A>
</TD><TD>Computation of the transition-matrix phi and its integral gamma</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.integralExpT" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExpT"
>integralExpT</A>
</TD><TD>Computation of the transition-matrix phi and the integral gamma and gamma1</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Matrices.LAPACKS.png" ALT="Modelica.Math.Matrices.LAPACK" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>LAPACK</A>
</TD><TD>Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isEqual<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.isEqual" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.isEqual"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.isEqual</H2>
<B>Compare whether two Real matrices are identical</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>isEqual</b>(M1, M2);
Matrices.<b>isEqual</b>(M1, M2, eps=0);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Matrices.isEqual(M1, M2)</code>" returns <b>true</b>,
if the two Real matrices M1 and M2 have the same dimensions and
the same elements. Otherwise the function
returns <b>false</b>. Two elements e1 and e2 of the two matrices
are checked on equality by the test "abs(e1-e2) &le; eps", where "eps"
can be provided as third argument of the function. Default is "eps = 0".
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A1[2,2] = [1,2; 3,4];
  Real A2[3,2] = [1,2; 3,4; 5,6];
  Real A3[2,2] = [1,2, 3,4.0001];
  Boolean result;
<b>algorithm</b>
  result := Matrices.isEqual(M1,M2);     // = <b>false</b>
  result := Matrices.isEqual(M1,M3);     // = <b>false</b>
  result := Matrices.isEqual(M1,M1);     // = <b>true</b>
  result := Matrices.isEqual(M1,M3,0.1); // = <b>true</b>
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Vectors.html#Modelica.Math.Vectors.isEqual"
>Vectors.isEqual</a>,
<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.isEqual"
>Strings.isEqual</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>M1[:, :]</TD><TD>&nbsp;</TD><TD>First matrix</TD></TR>
<TR><TD>Real</TD><TD>M2[:, :]</TD><TD>&nbsp;</TD><TD>Second matrix (may have different size as M1</TD></TR>
<TR><TD>Real</TD><TD>eps</TD><TD>0</TD><TD>Two elements e1 and e2 of the two matrices are identical if abs(e1-e2) &lt;= eps</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>result</TD><TD>= true, if matrices have the same size and the same elements</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> isEqual <font color="darkgreen">&quot;Compare whether two Real matrices are identical&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real M1[:, :] <font color="darkgreen">&quot;First matrix&quot;</font>;
  <font color="blue">input </font>Real M2[:, :] <font color="darkgreen">&quot;Second matrix (may have different size as M1&quot;</font>;
  <font color="blue">input </font>Real eps(min=0) = 0 <font color="darkgreen">
    &quot;Two elements e1 and e2 of the two matrices are identical if abs(e1-e2) &lt;= eps&quot;</font>;
  <font color="blue">output </font>Boolean result <font color="darkgreen">
    &quot;= true, if matrices have the same size and the same elements&quot;</font>;

<font color="blue">protected </font>
  Integer nrow=<font color="red">size</font>(M1, 1) <font color="darkgreen">&quot;Number of rows of matrix M1&quot;</font>;
  Integer ncol=<font color="red">size</font>(M1, 2) <font color="darkgreen">&quot;Number of columns of matrix M1&quot;</font>;
  Integer i=1;
  Integer j;
<font color="blue">algorithm </font>
  result := false;
  <font color="blue">if </font><font color="red">size</font>(M2, 1) == nrow<font color="blue"> and </font><font color="red">size</font>(M2, 2) == ncol<font color="blue"> then</font>
    result := true;
    <font color="blue">while </font>i &lt;= nrow<font color="blue"> loop</font>
      j := 1;
      <font color="blue">while </font>j &lt;= ncol<font color="blue"> loop</font>
        <font color="blue">if </font><font color="red">abs</font>(M1[i, j] - M2[i, j]) &gt; eps<font color="blue"> then</font>
          result := false;
          i := nrow;
          j := ncol;
        <font color="blue">end if</font>;
        j := j + 1;
      <font color="blue">end while</font>;
      i := i + 1;
    <font color="blue">end while</font>;
  <font color="blue">end if</font>;

<font color="blue">end </font>isEqual;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE norm<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.norm" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.norm"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.norm</H2>
<B>Returns the norm of a matrix</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>norm</b>(A);
Matrices.<b>norm</b>(A, p=2);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Matrices.norm(A)</code>" returns the
2-norm of matrix A, i.e., the largest singular value of A.<br>
The function call "<code>Matrices.norm(A, p)</code>" returns the
p-norm of matrix A. The only allowed values for p are</p>
<ul>
<li> "p=1": the largest column sum of A</li>
<li> "p=2": the largest singular value of A</li>
<li> "p=Modelica.Constants.inf": the largest row sum of A</li>
</ul>
<p>
Note, for any matrices A1, A2 the following inequality holds:
</p>
<blockquote><pre>
Matrices.<b>norm</b>(A1+A2,p) &le; Matrices.<b>norm</b>(A1,p) + Matrices.<b>norm</b>(A2,p)
</pre></blockquote>
<p>
Note, for any matrix A and vector v the following inequality holds:
</p>
<blockquote><pre>
Vectors.<b>norm</b>(A*v,p) &le; Matrices.<b>norm</b>(A,p)*Vectors.<b>norm</b>(A,p)
</pre></blockquote>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Input matrix</TD></TR>
<TR><TD>Real</TD><TD>p</TD><TD>2</TD><TD>Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>result</TD><TD>p-norm of matrix A</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> norm <font color="darkgreen">&quot;Returns the norm of a matrix&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:, :] <font color="darkgreen">&quot;Input matrix&quot;</font>;
  <font color="blue">input </font>Real p(min=1) = 2 <font color="darkgreen">
    &quot;Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)&quot;</font>;
  <font color="blue">output </font>Real result=0.0 <font color="darkgreen">&quot;p-norm of matrix A&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">if </font>p == 1<font color="blue"> then</font>
    <font color="darkgreen">// column sum norm</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A, 2)<font color="blue"> loop</font>
      result :=<font color="red"> max</font>(result,<font color="red"> sum</font>(<font color="red">abs</font>(A[:, i])));
    <font color="blue">end for</font>;
  <font color="blue">elseif </font>p == 2<font color="blue"> then</font>
    <font color="darkgreen">// largest singular value</font>
    result :=<font color="red"> max</font>(<font color="red">singularValues</font>(A));
  <font color="blue">elseif </font>p == Modelica.Constants.inf<font color="blue"> then</font>
    <font color="darkgreen">// row sum norm</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A, 1)<font color="blue"> loop</font>
      result :=<font color="red"> max</font>(result,<font color="red"> sum</font>(<font color="red">abs</font>(A[i, :])));
    <font color="blue">end for</font>;
  <font color="blue">else</font>
    <font color="red">assert</font>(false, &quot;Optional argument \&quot;p\&quot; of function \&quot;norm\&quot; must be
1, 2 or Modelica.Constants.inf&quot;);
  <font color="blue">end if</font>;
<font color="blue">end </font>norm;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sort<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.sort" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.sort"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.sort</H2>
<B>Sort rows or columns of matrix in ascending or descending order</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
           sorted_M = Matrices.<b>sort</b>(M);
(sorted_M, indices) = Matrices.<b>sort</b>(M, sortRows=true, ascending=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>sort</b>(..) sorts the rows of a Real matrix M
in ascending order and returns the result in sorted_M.
If the optional argument "sortRows" is <b>false</b>, the columns
of the matrix are sorted.
If the optional argument "ascending" is <b>false</b>, the rows or
columns are sorted in descending order. In the optional second
output argument, the indices of the sorted rows or columns with respect
to the original matrix are given, such that
</p>
<pre>
   sorted_M = <b>if</b> sortedRow <b>then</b> M[indices,:] <b>else</b> M[:,indices];
</pre>
<h4>Example</h4>
<blockquote><pre>
  (M2, i2) := Matrices.sort([2, 1,  0;
                             2, 0, -1]);
       -> M2 = [2, 0, -1;
                2, 1, 0 ];
          i2 = {2,1};
</pre></blockquote>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>M[:, :]</TD><TD>&nbsp;</TD><TD>Matrix to be sorted</TD></TR>
<TR><TD>Boolean</TD><TD>sortRows</TD><TD>true</TD><TD>= true if rows are sorted, otherwise columns</TD></TR>
<TR><TD>Boolean</TD><TD>ascending</TD><TD>true</TD><TD>= true if ascending order, otherwise descending order</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>sorted_M[size(M, 1), size(M, 2)]</TD><TD>Sorted matrix</TD></TR>
<TR><TD>Integer</TD><TD>indices[if sortRows then size(M, 1) else size(M, 2)]</TD><TD>sorted_M = if sortRows then M[indices,:] else M[:,indices]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> sort <font color="darkgreen">
  &quot;Sort rows or columns of matrix in ascending or descending order&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real M[:,:] <font color="darkgreen">&quot;Matrix to be sorted&quot;</font>;
  <font color="blue">input </font>Boolean sortRows = true <font color="darkgreen">&quot;= true if rows are sorted, otherwise columns&quot;</font>;
  <font color="blue">input </font>Boolean ascending = true <font color="darkgreen">
    &quot;= true if ascending order, otherwise descending order&quot;</font>;
  <font color="blue">output </font>Real sorted_M[<font color="red">size</font>(M,1),<font color="red"> size</font>(M,2)] = M <font color="darkgreen">&quot;Sorted matrix&quot;</font>;
  <font color="blue">output </font>Integer indices[<font color="blue">if </font>sortRows<font color="blue"> then </font><font color="red">size</font>(M,1)<font color="blue"> else </font><font color="red">size</font>(M,2)] <font color="darkgreen">
    &quot;sorted_M = if sortRows then M[indices,:] else M[:,indices]&quot;</font>;

  <font color="darkgreen">/* shellsort algorithm; should be improved later */</font>
<font color="blue">protected </font>
  Integer gap;
  Integer i;
  Integer j;
  Real wM2[<font color="red">size</font>(M,2)];
  Integer wi;
  Integer nM1 =<font color="red"> size</font>(M,1);
  Boolean swap;
  Real sorted_MT[<font color="red">size</font>(M,2),<font color="red"> size</font>(M,1)];

<font color="blue">encapsulated </font><font color="blue">function</font> greater <font color="darkgreen">&quot;Compare whether vector v1 &gt; v2&quot;</font>
    <font color="blue">import </font><A HREF="Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
    <font color="blue">import </font><A HREF="Modelica_Utilities_Types.html#Modelica.Utilities.Types.Compare"
>Modelica.Utilities.Types.Compare</A>;
  <font color="blue">input </font>Real v1[:];
  <font color="blue">input </font>Real v2[<font color="red">size</font>(v1,1)];
  <font color="blue">output </font>Boolean result;
  <font color="blue">protected </font>
  Integer n =<font color="red"> size</font>(v1,1);
  Integer i=1;
<font color="blue">algorithm </font>
  result := false;
  <font color="blue">while </font>i &lt;= n<font color="blue"> loop</font>
     <font color="blue">if </font>v1[i] &gt; v2[i]<font color="blue"> then</font>
        result := true;
        i := n;
     <font color="blue">elseif </font>v1[i] &lt; v2[i]<font color="blue"> then</font>
        i := n;
     <font color="blue">end if</font>;
     i := i+1;
  <font color="blue">end while</font>;
<font color="blue">end </font>greater;

<font color="blue">encapsulated </font><font color="blue">function</font> less <font color="darkgreen">&quot;Compare whether vector v1 &lt; v2&quot;</font>
    <font color="blue">import </font><A HREF="Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
    <font color="blue">import </font><A HREF="Modelica_Utilities_Types.html#Modelica.Utilities.Types.Compare"
>Modelica.Utilities.Types.Compare</A>;
  <font color="blue">input </font>Real v1[:];
  <font color="blue">input </font>Real v2[<font color="red">size</font>(v1,1)];
  <font color="blue">output </font>Boolean result;
  <font color="blue">protected </font>
  Integer n =<font color="red"> size</font>(v1,1);
  Integer i=1;
<font color="blue">algorithm </font>
  result := false;
  <font color="blue">while </font>i &lt;= n<font color="blue"> loop</font>
     <font color="blue">if </font>v1[i] &lt; v2[i]<font color="blue"> then</font>
        result := true;
        i := n;
     <font color="blue">elseif </font>v1[i] &gt; v2[i]<font color="blue"> then</font>
        i := n;
     <font color="blue">end if</font>;
     i := i+1;
  <font color="blue">end while</font>;
<font color="blue">end </font>less;
<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="blue">not </font>sortRows<font color="blue"> then</font>
      (sorted_MT,indices) :=<font color="red"> sort</font>(<font color="red">transpose</font>(M), ascending=ascending);
     sorted_M :=<font color="red">transpose</font>(sorted_MT);
  <font color="blue">else</font>
     indices :=1:<font color="red">size</font>(M, 1);
     gap :=<font color="red"> div</font>(nM1,2);
     <font color="blue">while </font>gap &gt; 0<font color="blue"> loop</font>
        i := gap;
        <font color="blue">while </font>i &lt; nM1<font color="blue"> loop</font>
           j := i-gap;
           <font color="blue">if </font>j&gt;=0<font color="blue"> then</font>
              <font color="blue">if </font>ascending<font color="blue"> then</font>
                 swap :=<font color="red"> greater</font>(sorted_M[j+1,:], sorted_M[j+gap+1,:]);
              <font color="blue">else</font>
                 swap :=<font color="red"> less</font>(sorted_M[j+1,:], sorted_M[j+gap+1,:]);
              <font color="blue">end if</font>;
           <font color="blue">else</font>
              swap := false;
           <font color="blue">end if</font>;

           <font color="blue">while </font>swap<font color="blue"> loop</font>
              wM2 := sorted_M[j+1,:];
              wi := indices[j+1];
              sorted_M[j+1,:] := sorted_M[j+gap+1,:];
              sorted_M[j+gap+1,:] := wM2;
              indices[j+1] := indices[j+gap+1];
              indices[j+gap+1] := wi;
              j := j - gap;
              <font color="blue">if </font>j &gt;= 0<font color="blue"> then</font>
                 <font color="blue">if </font>ascending<font color="blue"> then</font>
                    swap :=<font color="red"> greater</font>(sorted_M[j+1,:], sorted_M[j+gap+1,:]);
                 <font color="blue">else</font>
                    swap :=<font color="red"> less</font>(sorted_M[j+1,:], sorted_M[j+gap+1,:]);
                 <font color="blue">end if</font>;
              <font color="blue">else</font>
                 swap := false;
              <font color="blue">end if</font>;
           <font color="blue">end while</font>;
           i := i + 1;
        <font color="blue">end while</font>;
        gap :=<font color="red"> div</font>(gap,2);
     <font color="blue">end while</font>;
  <font color="blue">end if</font>;
<font color="blue">end </font>sort;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.solve" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.solve"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.solve</H2>
<B>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>solve</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>A</b>*<b>x</b> = <b>b</b>
</p>
</blockquote>
<p>
If a unique solution <b>x</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>
<p>
Note, the solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real b[3] = {10,22,12};
  Real x[3];
<b>algorithm</b>
  x := Matrices.solve(A,b);  // x = {3,2,1}
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>Matrices.LU_solve</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Matrix A of A*x = b</TD></TR>
<TR><TD>Real</TD><TD>b[size(A, 1)]</TD><TD>&nbsp;</TD><TD>Vector b of A*x = b</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[size(b, 1)]</TD><TD>Vector x such that A*x = b</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> solve <font color="darkgreen">
  &quot;Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red"> size</font>(A, 1)] <font color="darkgreen">&quot;Matrix A of A*x = b&quot;</font>;
  <font color="blue">input </font>Real b[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Vector b of A*x = b&quot;</font>;
  <font color="blue">output </font>Real x[<font color="red">size</font>(b, 1)] <font color="darkgreen">&quot;Vector x such that A*x = b&quot;</font>;


<font color="blue">protected </font>
  Integer info;
<font color="blue">algorithm </font>
  (x,info) :=<font color="red"> LAPACK.dgesv_vec</font>(A, b);
  <font color="red">assert</font>(info == 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.solve\&quot; is not possible, because the system has either
no or infinitely many solutions (A is singular).&quot;);
<font color="blue">end </font>solve;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.solve2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.solve2"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.solve2</H2>
<B>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>solve2</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>X</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>A</b>*<b>X</b> = <b>B</b>
</p>
</blockquote>
<p>
If a unique solution <b>X</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>
<p>
Note, the solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real B[3,2] = [10, 20;
                 22, 44;
                 12, 24];
  Real X[3,2];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  X := Matrices.solve2(A, B1);  /* X = [3, 6;
                                        2, 4;
                                        1, 2] */
</pre></blockquote>

<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve2"
>Matrices.LU_solve2</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Matrix A of A*X = B</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>Matrix B of A*X = B</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>X[size(B, 1), size(B, 2)]</TD><TD>Matrix X such that A*X = B</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> solve2 <font color="darkgreen">
  &quot;Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red"> size</font>(A, 1)] <font color="darkgreen">&quot;Matrix A of A*X = B&quot;</font>;
  <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:] <font color="darkgreen">&quot;Matrix B of A*X = B&quot;</font>;
  <font color="blue">output </font>Real X[<font color="red">size</font>(B, 1),<font color="red"> size</font>(B,2)] <font color="darkgreen">&quot;Matrix X such that A*X = B&quot;</font>;


<font color="blue">protected </font>
  Integer info;
<font color="blue">algorithm </font>
  (X,info) :=<font color="red"> LAPACK.dgesv</font>(A, B);
  <font color="red">assert</font>(info == 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.solve2\&quot; is not possible, because the system has either
no or infinitely many solutions (A is singular).&quot;);
<font color="blue">end </font>solve2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE leastSquares<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.leastSquares" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.leastSquares"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.leastSquares</H2>
<B>Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>leastSquares</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
A linear system of equations A*x = b has no solutions or infinitely
many solutions if A is not square. Function "leastSquares" returns
a solution in a least squarse sense:
</p>
<pre>
  size(A,1) &gt; size(A,2):  returns x such that |A*x - b|^2 is a minimum
  size(A,1) = size(A,2):  returns x such that A*x = b
  size(A,1) &lt; size(A,2):  returns x such that |x|^2 is a minimum for all
                          vectors x that fulfill A*x = b
</pre>
<p>
Note, the solution is computed with the LAPACK function "dgelsx",
i.e., QR or LQ factorization of A with column pivoting.
If A does not have full rank,
the solution is not unique and from the infinitely many solutions
the one is selected that minimizes both |x|^2 and |A*x - b|^2.
</p>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Matrix A</TD></TR>
<TR><TD>Real</TD><TD>b[size(A, 1)]</TD><TD>&nbsp;</TD><TD>Vector b</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[size(A, 2)]</TD><TD>Vector x such that min|A*x-b|^2 if size(A,1) &gt;= size(A,2) or min|x|^2 and A*x=b, if size(A,1) &lt; size(A,2)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> leastSquares <font color="darkgreen">
  &quot;Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:, :] <font color="darkgreen">&quot;Matrix A&quot;</font>;
  <font color="blue">input </font>Real b[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Vector b&quot;</font>;
  <font color="blue">output </font>Real x[<font color="red">size</font>(A, 2)] <font color="darkgreen">
    &quot;Vector x such that min|A*x-b|^2 if size(A,1) &gt;= size(A,2) or min|x|^2 and A*x=b, if size(A,1) &lt; size(A,2)&quot;</font>;


<font color="blue">protected </font>
  Integer info;
  Integer rank;
  Real xx[<font color="red">max</font>(<font color="red">size</font>(A,1),<font color="red">size</font>(A,2))];
<font color="blue">algorithm </font>
  (xx,info,rank) :=<font color="red"> LAPACK.dgelsx_vec</font>(A, b, 100*Modelica.Constants.eps);
  x := xx[1:<font color="red">size</font>(A,2)];
  <font color="red">assert</font>(info == 0, &quot;Solving an overdetermined or underdetermined linear system of
equations with function \&quot;Matrices.leastSquares\&quot; failed.&quot;);
<font color="blue">end </font>leastSquares;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE equalityLeastSquares<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.equalityLeastSquares" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.equalityLeastSquares"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.equalityLeastSquares</H2>
<B>Solve a linear equality constrained least squares problem</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>equalityLeastSquares</b>(A,a,B,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the
solution <b>x</b> of the linear equality-constrained least squares problem:
</p>
<blockquote>
<p>
min|<b>A</b>*<b>x</b> - <b>a</b>|^2 over <b>x</b>, subject to <b>B</b>*<b>x</b> = <b>b</b>
</p>
</blockquote>

<p>
It is required that the dimensions of A and B fulfill the following
relationship:
</p>

<blockquote>
size(B,1) &le; size(A,2) &le; size(A,1) + size(B,1)
</blockquote>

<p>
Note, the solution is computed with the LAPACK function "dgglse"
using the generalized RQ factorization under the assumptions that
B has full row rank (= size(B,1)) and the matrix [A;B] has
full column rank (= size(A,2)). In this case, the problem
has a unique solution.
</p>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Minimize |A*x - a|^2</TD></TR>
<TR><TD>Real</TD><TD>a[size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[:, size(A, 2)]</TD><TD>&nbsp;</TD><TD>subject to B*x=b</TD></TR>
<TR><TD>Real</TD><TD>b[size(B, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[size(A, 2)]</TD><TD>solution vector</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> equalityLeastSquares <font color="darkgreen">
  &quot;Solve a linear equality constrained least squares problem&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;Minimize |A*x - a|^2&quot;</font>;
  <font color="blue">input </font>Real a[<font color="red">size</font>(A,1)];
  <font color="blue">input </font>Real B[:,<font color="red">size</font>(A,2)] <font color="darkgreen">&quot;subject to B*x=b&quot;</font>;
  <font color="blue">input </font>Real b[<font color="red">size</font>(B,1)];
  <font color="blue">output </font>Real x[<font color="red">size</font>(A,2)] <font color="darkgreen">&quot;solution vector&quot;</font>;


<font color="blue">protected </font>
  Integer info;
<font color="blue">algorithm </font>
  <font color="red">assert</font>(<font color="red">size</font>(A,2) &gt;=<font color="red"> size</font>(B,1)<font color="blue"> and </font><font color="red">size</font>(A,2) &lt;=<font color="red"> size</font>(A,1) +<font color="red"> size</font>(B,1),
         &quot;It is required that size(B,1) &lt;= size(A,2) &lt;= size(A,1) + size(B,1)\n&quot; +
         &quot;This relationship is not fulfilled, since the matrices are declared as:\n&quot; +
         &quot;  A[&quot; +<font color="red"> String</font>(<font color="red">size</font>(A,1)) + &quot;,&quot; +<font color="red"> String</font>(<font color="red">size</font>(A,2)) + &quot;], B[&quot; +
         <font color="red">String</font>(<font color="red">size</font>(B,1)) + &quot;,&quot; +<font color="red"> String</font>(<font color="red">size</font>(B,2)) + &quot;]\n&quot;);

  (x, info) :=<font color="red"> LAPACK.dgglse_vec</font>(A, a, B, b);

  <font color="red">assert</font>(info == 0, &quot;Solving a linear equality-constrained least squares problem
with function \&quot;Matrices.equalityLeastSquares\&quot; failed.&quot;);
<font color="blue">end </font>equalityLeastSquares;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.LU" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.LU"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.LU</H2>
<B>LU decomposition of square or rectangular matrix</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(LU, pivots)       = Matrices.<b>LU</b>(A);
(LU, pivots, info) = Matrices.<b>LU</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
LU decomposition of a "Real[m,n]" matrix A, i.e.,
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b> = <b>A</b>
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
Matrices <b>L</b> and <b>U</b> are stored in the returned
matrix <code>LU</code> (the diagonal of <b>L</b> is not stored).
With the companion function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>Matrices.LU_solve</a>,
this decomposition can be used to solve
linear systems (<b>P</b>*<b>L</b>*<b>U</b>)*<b>x</b> = <b>b</b> with different right
hand side vectors <b>b</b>. If a linear system of equations with
just one right hand side vector <b>b</b> shall be solved, it is
more convenient to just use the function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>.
</p>
<p>
The optional third (Integer) output argument has the following meaning:
<table border=0 cellspacing=0 cellpadding=2>
  <tr><td valign="top">info = 0:</td
      <td valign="top">successful exit</td></tr>
  <tr><td valign="top">info &gt; 0:</td>
      <td valign="top">if info = i, U[i,i] is exactly zero. The factorization
          has been completed, <br>
          but the factor U is exactly
          singular, and division by zero will occur<br> if it is used
          to solve a system of equations.</td></tr>
</table>
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>Matrices.LU_solve</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>,
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Square or rectangular matrix</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>LU[size(A, 1), size(A, 2)]</TD><TD>L,U factors (used with LU_solve(..))</TD></TR>
<TR><TD>Integer</TD><TD>pivots[min(size(A, 1), size(A, 2))]</TD><TD>pivot indices (used with LU_solve(..))</TD></TR>
<TR><TD>Integer</TD><TD>info</TD><TD>Information</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> LU <font color="darkgreen">&quot;LU decomposition of square or rectangular matrix&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:, :] <font color="darkgreen">&quot;Square or rectangular matrix&quot;</font>;
  <font color="blue">output </font>Real LU[<font color="red">size</font>(A, 1),<font color="red"> size</font>(A,2)] = A <font color="darkgreen">
    &quot;L,U factors (used with LU_solve(..))&quot;</font>;
  <font color="blue">output </font>Integer pivots[<font color="red">min</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A,2))] <font color="darkgreen">
    &quot;pivot indices (used with LU_solve(..))&quot;</font>;
  <font color="blue">output </font>Integer info <font color="darkgreen">&quot;Information&quot;</font>;
  <font color="blue">external </font>&quot;FORTRAN 77&quot; <font color="red">dgetrf</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2), LU,<font color="red"> size</font>(A, 1), pivots, info);

<font color="blue">end </font>LU;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU_solve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.LU_solve" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.LU_solve"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.LU_solve</H2>
<B>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>LU_solve</b>(LU, pivots, b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear systems of equations
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b>*<b>x</b> = <b>b</b>;
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve</code>
it is possible to efficiently solve linear systems
with different right hand side vectors. If a linear system of equations with
just one right hand side vector shall be solved, it is
more convenient to just use the function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>.
</p>
<p>
If a unique solution <b>x</b> does not exist (since the
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>,
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>LU[:, size(LU, 1)]</TD><TD>&nbsp;</TD><TD>L,U factors of Matrices.LU(..) for a square matrix</TD></TR>
<TR><TD>Integer</TD><TD>pivots[size(LU, 1)]</TD><TD>&nbsp;</TD><TD>Pivots indices of Matrices.LU(..)</TD></TR>
<TR><TD>Real</TD><TD>b[size(LU, 1)]</TD><TD>&nbsp;</TD><TD>Right hand side vector of P*L*U*x=b</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[size(b, 1)]</TD><TD>Solution vector such that P*L*U*x = b</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> LU_solve <font color="darkgreen">
  &quot;Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real LU[:,<font color="red"> size</font>(LU,1)] <font color="darkgreen">
    &quot;L,U factors of Matrices.LU(..) for a square matrix&quot;</font>;
  <font color="blue">input </font>Integer pivots[<font color="red">size</font>(LU, 1)] <font color="darkgreen">&quot;Pivots indices of Matrices.LU(..)&quot;</font>;
  <font color="blue">input </font>Real b[<font color="red">size</font>(LU, 1)] <font color="darkgreen">&quot;Right hand side vector of P*L*U*x=b&quot;</font>;
  <font color="blue">output </font>Real x[<font color="red">size</font>(b, 1)] <font color="darkgreen">&quot;Solution vector such that P*L*U*x = b&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(LU,1)<font color="blue"> loop</font>
    <font color="red">   assert</font>(LU[i,i] &lt;&gt; 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.LU_solve\&quot; is not possible, since the LU decomposition
is singular, i.e., no unique solution exists.&quot;);
  <font color="blue">end for</font>;
  x :=<font color="red"> LAPACK.dgetrs_vec</font>(LU, pivots, b);
<font color="blue">end </font>LU_solve;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU_solve2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.LU_solve2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.LU_solve2"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.LU_solve2</H2>
<B>Solve real system of linear equations P*L*U*X=B with a B matrix and an LU decomposition (from LU(..))</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>LU_solve</b>(LU, pivots, B);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>X</b> of the linear systems of equations
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b>*<b>X</b> = <b>B</b>;
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve2</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve2</code>
it is possible to efficiently solve linear systems
with different right hand side <b>matrices</b>. If a linear system of equations with
just one right hand side matrix shall be solved, it is
more convenient to just use the function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2"
>Matrices.solve2</a>.
</p>
<p>
If a unique solution <b>X</b> does not exist (since the
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real B1[3] = [10, 20;
                22, 44;
                12, 24];
  Real B2[3] = [ 7, 14;
                13, 26;
                10, 20];
  Real    LU[3,3];
  Integer pivots[3];
  Real    X1[3,2];
  Real    X2[3,2];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  X1 := Matrices.LU_solve2(LU, pivots, B1);  /* X1 = [3, 6;
                                                      2, 4;
                                                      1, 2] */
  X2 := Matrices.LU_solve2(LU, pivots, B2);  /* X2 = [1, 2;
                                                      0, 0;
                                                      2, 4] */
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2"
>Matrices.solve2</a>,
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>LU[:, size(LU, 1)]</TD><TD>&nbsp;</TD><TD>L,U factors of Matrices.LU(..) for a square matrix</TD></TR>
<TR><TD>Integer</TD><TD>pivots[size(LU, 1)]</TD><TD>&nbsp;</TD><TD>Pivots indices of Matrices.LU(..)</TD></TR>
<TR><TD>Real</TD><TD>B[size(LU, 1), :]</TD><TD>&nbsp;</TD><TD>Right hand side matrix of P*L*U*X=B</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>X[size(B, 1), size(B, 2)]</TD><TD>Solution matrix such that P*L*U*X = B</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> LU_solve2 <font color="darkgreen">
  &quot;Solve real system of linear equations P*L*U*X=B with a B matrix and an LU decomposition (from LU(..))&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real LU[:,<font color="red"> size</font>(LU,1)] <font color="darkgreen">
    &quot;L,U factors of Matrices.LU(..) for a square matrix&quot;</font>;
  <font color="blue">input </font>Integer pivots[<font color="red">size</font>(LU, 1)] <font color="darkgreen">&quot;Pivots indices of Matrices.LU(..)&quot;</font>;
  <font color="blue">input </font>Real B[<font color="red">size</font>(LU, 1),:] <font color="darkgreen">&quot;Right hand side matrix of P*L*U*X=B&quot;</font>;
  <font color="blue">output </font>Real X[<font color="red">size</font>(B, 1),<font color="red"> size</font>(B,2)] <font color="darkgreen">&quot;Solution matrix such that P*L*U*X = B&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(LU,1)<font color="blue"> loop</font>
    <font color="red">   assert</font>(LU[i,i] &lt;&gt; 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.LU_solve\&quot; is not possible, since the LU decomposition
is singular, i.e., no unique solution exists.&quot;);
  <font color="blue">end for</font>;
  X :=<font color="red"> Modelica.Math.Matrices.LAPACK.dgetrs</font>(
    LU,
    pivots,
    B);
<font color="blue">end </font>LU_solve2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE QR<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.QR" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.QR"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.QR</H2>
<B>QR decomposition of a square matrix with column pivoting (A(:,p) = Q*R)</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(Q,R,p) = Matrices.<b>QR</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the QR decomposition of
a rectangular matrix <b>A</b> (the number of columns of <b>A</b>
must be less than or equal to the number of rows):
</p>
<blockquote>
<p>
<b>Q</b>*<b>R</b> = <b>A</b>[:,<b>p</b>]
</p>
</blockquote>
<p>
where <b>Q</b> is a rectangular matrix that has orthonormal columns and
has the same size as A (<b>Q</b><sup>T</sup><b>Q</b>=<b>I</b>),
<b>R</b> is a square, upper triangular matrix and <b>p</b> is a permutation
vector. Matrix <b>R</b> has the following important properties:
</p>
<ul>
<li> The absolute value of a diagonal element of <b>R</b> is the largest
     value in this row, i.e.,
     abs(R[i,i]) &ge; abs(R[i,j]).</li>
<li> The diagonal elements of <b>R</b> are sorted according to size, such that
     the largest absolute value is abs(R[1,1]) and
     abs(R[i,i]) &ge; abs(R[j,j]) with i &lt; j. </li>
</ul>
<p>
This means that if abs(R[i,i]) &le; &epsilon; then abs(R[j,k]) &le; &epsilon;
for j &ge; i, i.e., the i-th row up to the last row of <b>R</b> have
small elements and can be treated as being zero.
This allows to, e.g., estimate the row-rank
of <b>R</b> (which is the same row-rank as <b>A</b>). Furthermore,
<b>R</b> can be partitioned in two parts
</p>
<blockquote>
<pre>
   <b>A</b>[:,<b>p</b>] = <b>Q</b> * [<b>R</b><sub>1</sub>, <b>R</b><sub>2</sub>;
                 <b>0</b>,  <b>0</b>]
</pre>
</blockquote>
<p>
where <b>R</b><sub>1</sub> is a regular, upper triangular matrix.
</p>
<p>
Note, the solution is computed with the LAPACK functions "dgeqpf"
and "dorgqr", i.e., by Housholder transformations with
column pivoting. If <b>Q</b> is not needed, the function may be
called as: <code>(,R,p) = QR(A)</code>.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real R[3,3];
<b>algorithm</b>
  (,R) := Matrices.QR(A);  // R = [-7.07.., -4.24.., -3.67..;
                                    0     , -1.73.., -0.23..;
                                    0     ,  0     ,  0.65..];
</pre></blockquote>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Rectangular matrix with size(A,1) &gt;= size(A,2)</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Rectangular matrix with orthonormal columns such that Q*R=A[:,p]</TD></TR>
<TR><TD>Real</TD><TD>R[size(A, 2), size(A, 2)]</TD><TD>Square upper triangular matrix</TD></TR>
<TR><TD>Integer</TD><TD>p[size(A, 2)]</TD><TD>Column permutation vector</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> QR <font color="darkgreen">
  &quot;QR decomposition of a square matrix with column pivoting (A(:,p) = Q*R)&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:, :] <font color="darkgreen">&quot;Rectangular matrix with size(A,1) &gt;= size(A,2)&quot;</font>;
  <font color="blue">output </font>Real Q[<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2)] <font color="darkgreen">
    &quot;Rectangular matrix with orthonormal columns such that Q*R=A[:,p]&quot;</font>;
  <font color="blue">output </font>Real R[<font color="red">size</font>(A, 2),<font color="red"> size</font>(A, 2)] <font color="darkgreen">&quot;Square upper triangular matrix&quot;</font>;
  <font color="blue">output </font>Integer p[<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;Column permutation vector&quot;</font>;

<font color="blue">protected </font>
  Integer nrow=<font color="red">size</font>(A, 1);
  Integer ncol=<font color="red">size</font>(A, 2);
  Real tau[ncol];
<font color="blue">algorithm </font>
  <font color="red">assert</font>(nrow &gt;= ncol, &quot;\nInput matrix A[&quot; +<font color="red"> String</font>(nrow) + &quot;,&quot; +<font color="red"> String</font>(ncol) + &quot;] has more columns as rows.
This is not allowed when calling Modelica.Matrices.QR(A).&quot;);
  (Q,tau,p) :=<font color="red"> LAPACK.dgeqpf</font>(A);

  <font color="darkgreen">// determine R</font>
  R :=<font color="red"> zeros</font>(ncol,ncol);
  <font color="blue">for </font>i<font color="blue"> in </font>1:ncol<font color="blue"> loop</font>
    <font color="blue">for </font>j<font color="blue"> in </font>i:ncol<font color="blue"> loop</font>
      R[i, j] := Q[i,j];
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// if isPresent(Q) then (not yet supported by Dymola)</font>
  Q :=<font color="red"> LAPACK.dorgqr</font>(Q, tau);
<font color="blue">end </font>QR;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE eigenValues<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.eigenValues" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.eigenValues"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.eigenValues</H2>
<B>Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
                eigenvalues = Matrices.<b>eigenValues</b>(A);
(eigenvalues, eigenvectors) = Matrices.<b>eigenValues</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the eigenvalues and
optionally the (right) eigenvectors of a square matrix
<b>A</b>. The first column of "eigenvalues" contains the real and the
second column contains the imaginary part of the eigenvalues.
If the i-th eigenvalue has no imaginary part, then eigenvectors[:,i] is
the corresponding real eigenvector. If the i-th eigenvalue
has an imaginary part, then eigenvalues[i+1,:] is the conjugate complex
eigenvalue and eigenvectors[:,i] is the real and eigenvectors[:,i+1] is the
imaginary part of the eigenvector of the i-th eigenvalue.
With function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix"
>Matrices.eigenValueMatrix</a>,
a real block diagonal matrix is constructed from the eigenvalues
such that
</p>
<blockquote>
<pre>
A = eigenvectors * eigenValueMatrix(eigenvalues) * inv(eigenvectors)
</pre>
</blockquote>
<p>
provided the eigenvector matrix "eigenvectors" can be inverted
(an inversion is possible, if all eigenvalues are different;
in some cases, an inversion is also possible if some eigenvalues are
the same).
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real eval;
<b>algorithm</b>
  eval := Matrices.eigenValues(A);  // eval = [-0.618, 0;
                                    //          8.0  , 0;
                                    //          1.618, 0];
</pre>
</blockquote>
<p>
i.e., matrix A has the 3 real eigenvalues -0.618, 8, 1.618.
</p>
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix"
>Matrices.eigenValueMatrix</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues"
>Matrices.singularValues</a>
<pre>
</PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Matrix</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>eigenvalues[size(A, 1), 2]</TD><TD>Eigenvalues of matrix A (Re: first column, Im: second column)</TD></TR>
<TR><TD>Real</TD><TD>eigenvectors[size(A, 1), size(A, 2)]</TD><TD>Real-valued eigenvector matrix</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> eigenValues <font color="darkgreen">
  &quot;Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red"> size</font>(A, 1)] <font color="darkgreen">&quot;Matrix&quot;</font>;
  <font color="blue">output </font>Real eigenvalues[<font color="red">size</font>(A, 1), 2] <font color="darkgreen">
    &quot;Eigenvalues of matrix A (Re: first column, Im: second column)&quot;</font>;
  <font color="blue">output </font>Real eigenvectors[<font color="red">size</font>(A,1),<font color="red"> size</font>(A,2)] <font color="darkgreen">
    &quot;Real-valued eigenvector matrix&quot;</font>;


<font color="blue">protected </font>
  Integer info;
  <font color="darkgreen">// replace with &quot;isPresent(..)&quot; if supported by Dymola</font>
  Boolean onlyEigenvalues = false;
<font color="blue">algorithm </font>
<font color="blue">if </font><font color="red">size</font>(A,1) &gt; 0<font color="blue"> then</font>
  <font color="blue">if </font>onlyEigenvalues<font color="blue"> then</font>
     (eigenvalues[:, 1],eigenvalues[:, 2],info) :=<font color="red"> LAPACK.dgeev_eigenValues</font>(A);
     eigenvectors :=<font color="red">zeros</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 1));
  <font color="blue">else</font>
     (eigenvalues[:, 1],eigenvalues[:, 2],eigenvectors, info) :=<font color="red"> LAPACK.dgeev</font>(A);
  <font color="blue">end if</font>;
  <font color="red">assert</font>(info == 0, &quot;Calculating the eigen values with function
\&quot;Matrices.eigenvalues\&quot; is not possible, since the
numerical algorithm does not converge.&quot;);
<font color="blue">end if</font>;
<font color="blue">end </font>eigenValues;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE eigenValueMatrix<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.eigenValueMatrix" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.eigenValueMatrix"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.eigenValueMatrix</H2>
<B>Return real valued block diagonal matrix J of eigenvalues of matrix A (A=V*J*Vinv)</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>eigenValueMatrix</b>(eigenvalues);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call returns a block diagonal matrix <b>J</b>
from the the two-column matrix <code>eigenvalues</code>
(computed by function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>Matrices.eigenValues</a>).
Matrix <code>eigenvalues</code> must have the real part of the
eigenvalues in the first column and the imaginary part in the
second column. If an eigenvalue i has a vanishing imaginary
part, then <b>J</b>[i,i] = eigenvalues[i,1], i.e., the diagonal
element of <b>J</b> is the real eigenvalue.
Otherwise, eigenvalue i and conjugate complex eigenvalue i+1
are used to construct a 2 by 2 diagonal block of <b>J</b>:
</p>
<blockquote>
<pre>
  J[i  , i]   := eigenvalues[i,1];
  J[i  , i+1] := eigenvalues[i,2];
  J[i+1, i]   := eigenvalues[i+1,2];
  J[i+1, i+1] := eigenvalues[i+1,1];
</pre>
</blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>Matrices.eigenValues</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>eigenValues[:, 2]</TD><TD>&nbsp;</TD><TD>Eigen values from function eigenValues(..) (Re: first column, Im: second column)</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>J[size(eigenValues, 1), size(eigenValues, 1)]</TD><TD>Real valued block diagonal matrix with eigen values (Re: 1x1 block, Im: 2x2 block)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> eigenValueMatrix <font color="darkgreen">
  &quot;Return real valued block diagonal matrix J of eigenvalues of matrix A (A=V*J*Vinv)&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real eigenValues[:, 2] <font color="darkgreen">
    &quot;Eigen values from function eigenValues(..) (Re: first column, Im: second column)&quot;</font>;
  <font color="blue">output </font>Real J[<font color="red">size</font>(eigenValues, 1),<font color="red"> size</font>(eigenValues, 1)] <font color="darkgreen">
    &quot;Real valued block diagonal matrix with eigen values (Re: 1x1 block, Im: 2x2 block)&quot;</font>;


<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(eigenValues, 1);
  Integer i;
<font color="blue">algorithm </font>
  J :=<font color="red"> zeros</font>(n, n);
  i := 1;
  <font color="blue">while </font>i &lt;= n<font color="blue"> loop</font>
    <font color="blue">if </font>eigenValues[i, 2] == 0<font color="blue"> then</font>
      J[i, i] := eigenValues[i, 1];
      i := i + 1;
    <font color="blue">else</font>
      J[i, i] := eigenValues[i, 1];
      J[i, i + 1] := eigenValues[i, 2];
      J[i + 1, i] := eigenValues[i + 1, 2];
      J[i + 1, i + 1] := eigenValues[i + 1, 1];
      i := i + 2;
    <font color="blue">end if</font>;
  <font color="blue">end while</font>;
<font color="blue">end </font>eigenValueMatrix;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE singularValues<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.singularValues" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.singularValues"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.singularValues</H2>
<B>Compute singular values and left and right singular vectors</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
         sigma = Matrices.<b>singularValues</b>(A);
(sigma, U, VT) = Matrices.<b>singularValues</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the singular values and optionally the
singular vectors of matrix A. Basically the singular
value decomposition of A is computed, i.e.,
</p>
<blockquote><pre>
<b>A</b> = <b>U</b> <b><font face="Symbol">S</font></b> <b>V</b><sup>T</sup>
  = U*Sigma*VT
</blockquote></pre>
<p>
where <b>U </b>and <b>V</b> are orthogonal matrices (<b>UU</b><sup>T</sup>=<b>I,
</b><b>VV</b><sup>T</sup>=<b>I</b>). <b><font face="Symbol">S
</font></b> = diag(<font face="Symbol">s</font><sub>i</sub>)
has the same size as matrix A with nonnegative diagonal elements
in decreasing order and with all other elements zero
(<font face="Symbol">s</font><sub>1</sub> is the largest element). The function
returns the singular values <font face="Symbol">s</font><sub>i</sub>
in vector <tt>sigma</tt> and the orthogonal matrices in
matrices <tt>U</tt> and <tt>V</tt>.
</p>
<h4>Example</h4>
<blockquote><pre>
  A = [1, 2,  3,  4;
       3, 4,  5, -2;
      -1, 2, -3,  5];
  (sigma, U, VT) = singularValues(A);
  results in:
     sigma = {8.33, 6.94, 2.31};
  i.e.
     Sigma = [8.33,    0,    0, 0;
                 0, 6.94,    0, 0;
                 0,    0, 2.31, 0]
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>Matrices.eigenValues</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Matrix</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>sigma[min(size(A, 1), size(A, 2))]</TD><TD>Singular values</TD></TR>
<TR><TD>Real</TD><TD>U[size(A, 1), size(A, 1)]</TD><TD>Left orthogonal matrix</TD></TR>
<TR><TD>Real</TD><TD>VT[size(A, 2), size(A, 2)]</TD><TD>Transposed right orthogonal matrix </TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> singularValues <font color="darkgreen">
  &quot;Compute singular values and left and right singular vectors&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:, :] <font color="darkgreen">&quot;Matrix&quot;</font>;
  <font color="blue">output </font>Real sigma[<font color="red">min</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2))] <font color="darkgreen">&quot;Singular values&quot;</font>;
  <font color="blue">output </font>Real U[<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 1)]=<font color="red">identity</font>(<font color="red">size</font>(A, 1)) <font color="darkgreen">
    &quot;Left orthogonal matrix&quot;</font>;
  <font color="blue">output </font>Real VT[<font color="red">size</font>(A, 2),<font color="red"> size</font>(A, 2)]=<font color="red">identity</font>(<font color="red">size</font>(A, 2)) <font color="darkgreen">
    &quot;Transposed right orthogonal matrix &quot;</font>;

<font color="blue">protected </font>
  Integer info;
  Integer n=<font color="red">min</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2)) <font color="darkgreen">&quot;Number of singular values&quot;</font>;
<font color="blue">algorithm </font>
<font color="blue">if </font>n&gt;0<font color="blue"> then</font>
  (sigma,U,VT,info) :=<font color="red"> Modelica.Math.Matrices.LAPACK.dgesvd</font>(A);
  <font color="red">assert</font>(info == 0, &quot;The numerical algorithm to compute the
singular value decomposition did not converge&quot;);
<font color="blue">end if</font>;
<font color="blue">end </font>singularValues;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE det<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.det" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.det"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.det</H2>
<B>Determinant of a matrix (computed by LU decomposition)</B><p>
<P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>det</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the determinant of matrix A
computed by a LU decomposition.
Usally, this function should never be used, because
there are nearly always better numerical algorithms
as by computing the determinant. E.g., use function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank"
>Matrices.rank</a>
to compute the rank of a matrix.
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank"
>Matrices.rank</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>result</TD><TD>Determinant of matrix A</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> det <font color="darkgreen">&quot;Determinant of a matrix (computed by LU decomposition)&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red"> size</font>(A, 1)];
  <font color="blue">output </font>Real result <font color="darkgreen">&quot;Determinant of matrix A&quot;</font>;
<font color="blue">protected </font>
  Real LU[<font color="red">size</font>(A,1),<font color="red">size</font>(A,1)];
  Integer pivots[<font color="red">size</font>(A,1)];

<font color="blue">algorithm </font>
  (LU,pivots) :=<font color="red"> Matrices.LU</font>(A);
  result:=<font color="red">product</font>(LU[i,i] <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A,1))*
    <font color="red">product</font>(<font color="blue">if </font>pivots[i]==i<font color="blue"> then </font>1<font color="blue"> else </font>-1 <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(pivots,1));
<font color="blue">end </font>det;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE inv<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.inv" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.inv"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.inv</H2>
<B>Inverse of a matrix (try to avoid, use function solve(..) instead)</B><p>
<P><H3>Information</H3>
<PRE></pre>

<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>invA[size(A, 1), size(A, 2)]</TD><TD>Inverse of matrix A</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> inv <font color="darkgreen">
  &quot;Inverse of a matrix (try to avoid, use function solve(..) instead)&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red"> size</font>(A, 1)];
  <font color="blue">output </font>Real invA[<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2)] <font color="darkgreen">&quot;Inverse of matrix A&quot;</font>;
<font color="blue">protected </font>
  Integer info;
  Integer pivots[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Pivot vector&quot;</font>;
  Real LU[<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2)] <font color="darkgreen">&quot;LU factors of A&quot;</font>;
<font color="blue">algorithm </font>
  (LU,pivots,info) :=<font color="red"> LAPACK.dgetrf</font>(A);

  <font color="red">assert</font>(info == 0, &quot;Calculating an inverse matrix with function
\&quot;Matrices.inv\&quot; is not possible, since matrix A is singular.&quot;);

  invA :=<font color="red"> LAPACK.dgetri</font>(LU, pivots);

<font color="blue">end </font>inv;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rank<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.rank" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.rank"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.rank</H2>
<B>Rank of a matrix (computed with singular values)</B><p>
<P><H3>Information</H3>
<PRE></pre>

<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Matrix</TD></TR>
<TR><TD>Real</TD><TD>eps</TD><TD>0</TD><TD>If eps &gt; 0, the singular values are checked against eps; otherwise eps=max(size(A))*norm(A)*Modelica.Constants.eps is used</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>result</TD><TD>Rank of matrix A</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> rank <font color="darkgreen">&quot;Rank of a matrix (computed with singular values)&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:, :] <font color="darkgreen">&quot;Matrix&quot;</font>;
  <font color="blue">input </font>Real eps=0 <font color="darkgreen">
    &quot;If eps &gt; 0, the singular values are checked against eps; otherwise eps=max(size(A))*norm(A)*Modelica.Constants.eps is used&quot;</font>;
  <font color="blue">output </font>Integer result <font color="darkgreen">&quot;Rank of matrix A&quot;</font>;

<font color="blue">protected </font>
  Integer n=<font color="red">min</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2));
  Integer i=n;
  Real sigma[n];
  Real eps2;
<font color="blue">algorithm </font>
  result := 0;
  <font color="blue">if </font>n &gt; 0<font color="blue"> then</font>
    sigma :=<font color="red"> Modelica.Math.Matrices.singularValues</font>(A);
    eps2 := <font color="blue">if </font>eps &gt; 0<font color="blue"> then </font>eps<font color="blue"> else </font><font color="red">max</font>(<font color="red">size</font>(A))*sigma[1]*Modelica.Constants.eps;
    <font color="blue">while </font>i &gt; 0<font color="blue"> loop</font>
      <font color="blue">if </font>sigma[i] &gt; eps2<font color="blue"> then</font>
        result := i;
        i := 0;
      <font color="blue">end if</font>;
      i := i - 1;
    <font color="blue">end while</font>;
  <font color="blue">end if</font>;
<font color="blue">end </font>rank;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE balance<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.balance" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.balance"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.balance</H2>
<B>Balancing of matrix A to improve the condition of A</B><p>
<P><H3>Information</H3>
<PRE></pre>
<p>
The function transformates the matrix A, so that the norm of the i-th column
is nearby the i-th row. (D,B)=Matrices.balance(A) returns a vector D, such
that B=inv(diagonal(D))*A*diagonal(D) has better condition. The elements of D
are multiples of 2. Balancing attempts to make the norm of each row equal to the
norm of the belonging column. <br>
Balancing is used to minimize roundoff errors inducted
through large matrix calculations like Taylor-series approximation
or computation of eigenvalues.
</p>
<b>Example:</b><br><br>
<pre>       - A = [1, 10,  1000; .01,  0,  10; .005,  .01,  10]
       - Matrices.norm(A, 1);
         = 1020.0
       - (T,B)=Matrices.balance(A)
       - T
         = {256, 16, 0.5}
       - B
         =  [1,     0.625,   1.953125;
             0.16,  0,       0.3125;
             2.56,  0.32,   10.0]
       - Matrices.norm(B, 1);
         = 12.265625
</pre>
<p>
The Algorithm is taken from
<dl>
<dt>H. D. Joos, G. Grbel:
<dd><b>RASP'91 Regulator Analysis and Synthesis Programs</b><br>
    DLR - Control Systems Group 1991
</dl>
which based on the balanc function from EISPACK.
</p>

<pre>
</PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>D[size(A, 1)]</TD><TD>diagonal(D)=T is transformation matrix, such that
          T*A*inv(T) has smaller condition as A</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), size(A, 1)]</TD><TD>Balanced matrix (= diagonal(D)*A*inv(diagonal(D)))</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> balance <font color="darkgreen">
  &quot;Balancing of matrix A to improve the condition of A&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red"> size</font>(A, 1)];
  <font color="blue">output </font>Real D[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;diagonal(D)=T is transformation matrix, such that
          T*A*inv(T) has smaller condition as A&quot;</font>;
  <font color="blue">output </font>Real B[<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 1)] <font color="darkgreen">
    &quot;Balanced matrix (= diagonal(D)*A*inv(diagonal(D)))&quot;</font>;
<font color="blue">protected </font>
  Integer na=<font color="red">size</font>(A, 1);
  Integer radix=2 <font color="darkgreen">&quot;Radix of exponent representation must be &#39;radix&#39;
          or a multiple of &#39;radix&#39;&quot;</font>;
  Integer radix2=radix*radix;
  Boolean noconv=true;
  Integer i=1;
  Integer j=1;
  Real CO;
  Real RO;
  Real G;
  Real F;
  Real S;
  <font color="darkgreen">/*auxiliary variables*/</font>

<font color="blue">algorithm </font>

  <font color="darkgreen">// B = inv(D)*A*D, so that cond(B)&lt;=cond(A)</font>
  D :=<font color="red"> ones</font>(na);
  B := A;
  <font color="blue">while </font>noconv<font color="blue"> loop</font>
    noconv := false;
    <font color="blue">for </font>i<font color="blue"> in </font>1:na<font color="blue"> loop</font>
      CO :=<font color="red"> sum</font>(<font color="red">abs</font>(B[:, i])) -<font color="red"> abs</font>(B[i, i]);
      RO :=<font color="red"> sum</font>(<font color="red">abs</font>(B[i, :])) -<font color="red"> abs</font>(B[i, i]);
      G := RO/radix;
      F := 1;
      S := CO + RO;
      <font color="blue">while </font><font color="blue">not </font>(CO &gt;= G<font color="blue"> or </font>CO == 0)<font color="blue"> loop</font>
        F := F*radix;
        CO := CO*radix2;
      <font color="blue">end while</font>;
      G := RO*radix;
      <font color="blue">while </font><font color="blue">not </font>(CO &lt; G<font color="blue"> or </font>RO == 0)<font color="blue"> loop</font>
        F := F/radix;
        CO := CO/radix2;
      <font color="blue">end while</font>;
      <font color="blue">if </font><font color="blue">not </font>((CO + RO)/F &gt;= 0.95*S)<font color="blue"> then</font>
        G := 1/F;
        D[i] := D[i]*F;
        B[i, :] := B[i, :]*G;
        B[:, i] := B[:, i]*F;
        noconv := true;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
  <font color="blue">end while</font>;
<font color="blue">end </font>balance;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE exp<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.exp" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.exp"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.exp</H2>
<B>Compute the exponential of a matrix by adaptive Taylor series expansion with scaling and balancing</B><p>
<P><H3>Information</H3>
<PRE></pre>
<p>This function computes</p>
<pre>                            (<b>A</b>T)^2   (<b>A</b>T)^3
     <font size=4> <b>&Phi;</b></font> = e^(<b>A</b>T) = <b>I</b> + <b>A</b>T + ------ + ------ + ....
                              2!       3!
</pre>
<p>where e=2.71828..., <b>A</b> is an n x n matrix with real elements and T is a real number,
e.g., the sampling time.
<b>A</b> may be singular. With the exponential of a matrix it is, e.g., possible
to compute the solution of a linear system of differential equations</p>
<pre>    der(<b>x</b>) = <b>A</b>*<b>x</b>   ->   <b>x</b>(t0 + T) = e^(<b>A</b>T)*x(t0)
</pre>
<p>
The function is called as
<pre>     Phi = Matrices.exp(A,T);</pre>
or
<pre>       M = Matrices.exp(A);
</pre>
what calculates M as the exponential of matrix A.
</p>
<p><b>Algorithmic details:</b></p>
<p>The algorithm is taken from </p>
<dl>
<dt>H. D. Joos, G. Gruebel:
<dd><b>RASP'91 Regulator Analysis and Synthesis Programs</b><br>
    DLR - Control Systems Group 1991
</dl>
<p>The following steps are performed to calculate the exponential of A:</p>
<ol>
  <li>Matrix <b>A</b> is balanced <br>
  (= is transformed with a diagonal matrix <b>D</b>, such that inv(<b>D</b>)*<b>A</b>*<b>D</b>
  has a smaller condition as <b>A</b>).</li>
  <li>The scalar T is divided by a multiple of 2 such that norm(
       inv(<b>D</b>)*<b>A</b>*<b>D</b>*T/2^k ) &lt; 0.5. Note, that (1) and (2) are implemented such that no round-off errors
  are introduced.</li>
  <li>The matrix from (2) is approximated by explicitly performing the Taylor
  series expansion with a variable number of terms.
  Truncation occurs if a new term does no longer contribute to the value of <b>&Phi;</b>
  from the previous iteration.</li>
  <li>The resulting matrix is transformed back, by reverting the steps of (2)
  and (1).</li>
</ol>
<p>In several sources it is not recommended to use Taylor series expansion to
calculate the exponential of a matrix, such as in 'C.B. Moler and C.F. Van Loan:
Nineteen dubious ways to compute the exponential of a matrix. SIAM Review 20,
pp. 801-836, 1979' or in the documentation of m-file expm2 in Matlab version 6
(http://www.MathWorks.com) where it is stated that 'As a practical numerical
method, this is often slow and inaccurate'. These statements are valid for a
direct implementation of the Taylor series expansion, but <i>not</i> for the
implementation variant used in this function.
</p>

<pre>
</PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>T</TD><TD>1</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>phi[size(A, 1), size(A, 1)]</TD><TD>= exp(A*T)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> exp <font color="darkgreen">
  &quot;Compute the exponential of a matrix by adaptive Taylor series expansion with scaling and balancing&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red"> size</font>(A, 1)];
  <font color="blue">input </font>Real T=1;
  <font color="blue">output </font>Real phi[<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 1)] <font color="darkgreen">&quot;= exp(A*T)&quot;</font>;


<font color="blue">protected </font>
  <font color="blue">parameter </font>Integer nmax=21;
  <font color="darkgreen">/*max number of iterations*/</font>
  <font color="blue">parameter </font>Integer na=<font color="red">size</font>(A, 1);
  Integer j=1;
  Integer k=0;
  Boolean done=false;
  Real Anorm;
  Real Tscaled=1;
  Real Atransf[na, na];
  Real D[na, na];
  <font color="darkgreen">/*D: dummy variable for psi*/</font>
  Real M[na, na];
  <font color="darkgreen">/*M: dummy matrix*/</font>
  Real Diag[na];
  <font color="darkgreen">/*diagonal transformation matrix for balancing*/</font>

<font color="blue">encapsulated </font><font color="blue">function</font> columnNorm <font color="darkgreen">
    &quot;Returns the column norm of a matrix&quot;</font>
  <font color="blue">input </font>Real A[:, :] <font color="darkgreen">&quot;Input matrix&quot;</font>;
  <font color="blue">output </font>Real result=0.0 <font color="darkgreen">&quot;1-norm of matrix A&quot;</font>;
<font color="blue">algorithm </font>
   <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A, 2)<font color="blue"> loop</font>
      result :=<font color="red"> max</font>(result,<font color="red"> sum</font>(<font color="red">abs</font>(A[:, i])));
   <font color="blue">end for</font>;
<font color="blue">end </font>columnNorm;

<font color="blue">algorithm </font>
  <font color="darkgreen">// balancing of A</font>
  (Diag,Atransf) :=<font color="red"> balance</font>(A);

  <font color="darkgreen">// scaling of T until norm(A)*/(2^k) &lt; 1</font>
  Tscaled := T;
  <font color="darkgreen">/*Anorm: column-norm of matrix A*/</font>
  Anorm :=<font color="red"> columnNorm</font>(Atransf);
  Anorm := Anorm*T;
  <font color="blue">while </font>Anorm &gt;= 0.5<font color="blue"> loop</font>
    Anorm := Anorm/2;
    Tscaled := Tscaled/2;
    k := k + 1;
  <font color="blue">end while</font>;

  <font color="darkgreen">// Computation of psi by Taylor-series approximation</font>
  M :=<font color="red"> identity</font>(na);
  D := M;
  <font color="blue">while </font>j &lt; nmax<font color="blue"> and </font><font color="blue">not </font>done<font color="blue"> loop</font>
    M := Atransf*M*Tscaled/j;
    <font color="darkgreen">//stop if the new element of the series is small</font>
    <font color="blue">if </font><font color="red">columnNorm</font>((D + M) - D) == 0<font color="blue"> then</font>
      done := true;
    <font color="blue">else</font>
      D := M + D;
      j := j + 1;
    <font color="blue">end if</font>;
  <font color="blue">end while</font>;

  <font color="darkgreen">// re-scaling</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:k<font color="blue"> loop</font>
    D := D*D;
  <font color="blue">end for</font>;

  <font color="darkgreen">// re-balancing: psi := diagonal(Diag)*D*inv(diagonal(Diag));</font>
  <font color="blue">for </font>j<font color="blue"> in </font>1:na<font color="blue"> loop</font>
    <font color="blue">for </font>k<font color="blue"> in </font>1:na<font color="blue"> loop</font>
      phi[j, k] := D[j, k]*Diag[j]/Diag[k];
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;
<font color="blue">end </font>exp;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE integralExp<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.integralExp" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.integralExp"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.integralExp</H2>
<B>Computation of the transition-matrix phi and its integral gamma</B><p>
<P><H3>Information</H3>
<PRE></pre>
<p>
The function uses a Taylor series expansion with Balancing and
scaling/squaring to approximate the integral <b>&Psi;</b> of the matrix
exponential <b>&Phi;</b>=e^(AT):
</p>
<pre>                                 AT^2   A^2 * T^3          A^k * T^(k+1)
        <b>&Psi;</b> = int(e^(As))ds = IT + ---- + --------- + ... + --------------
                                  2!        3!                (k+1)!
</pre>
<p>
<b>&Phi;</b> is calculated through <b>&Phi;</b> = I + A*<b>&Psi;</b>, so A may be singular. <b>&Gamma;</b> is
simple <b>&Psi;</b>*B.
</p>
<p>The algorithm runs in the following steps: </p>
<ol>
  <li>Balancing</li>
  <li>Scaling</li>
  <li>Taylor series expansion</li>
  <li>Re-scaling</li>
  <li>Re-Balancing</li>
</ol>
<p>Balancing put the bad condition of a square matrix <i>A</i> into a diagonal
transformation matrix <i>D</i>. This reduce the effort of following calculations.
Afterwards the result have to be re-balanced by transformation D*A<small>transf</small>
 *inv(D).<br>
Scaling halfen T&nbsp; k-times, until the norm of A*T is less than 0.5. This
garantees minumum rounding errors in the following series
expansion. The re-scaling based on the equation&nbsp; exp(A*2T) = exp(AT)^2.
The needed re-scaling formula for psi thus becomes:</p>
<pre>         <b>&Phi;</b> = <b>&Phi;</b>'*<b>&Phi;</b>'
   I + A*<b>&Psi;</b> = I + 2A*<b>&Psi;</b>' + A^2*<b>&Psi;</b>'^2
         <b>&Psi;</b> = A*<b>&Psi;</b>'^2 + 2*<b>&Psi;</b>'
</pre>
<p>
where psi' is the scaled result from the series expansion while psi is the
re-scaled matrix.
</p>
<p>
The function is normally used to discretize a state-space system as the
zero-order-hold equivalent:
</p>
<pre>      x(k+1) = <b>&Phi;</b>*x(k) + <b>&Gamma;</b>*u(k)
        y(k) = C*x(k) + D*u(k)
</pre>
<p>
The zero-order-hold sampling, also known as step-invariant method, gives
exact values of the state variables, under the assumption that the control
signal u is constant between the sampling instants. Zero-order-hold sampling
is discribed in
</p>
<dl>
<dt>K. J. Astroem, B. Wittenmark:
<dd><b>Computer Controlled Systems - Theory and Design</b><br>
    Third Edition, p. 32
</dl>
<pre><b>Syntax:</b>
      (phi,gamma) = Matrices.expIntegral(A,B,T)
                       A,phi: [n,n] square matrices
                     B,gamma: [n,m] input matrix
                           T: scalar, e.g. sampling time
</pre>
<p>
The Algorithm to calculate psi is taken from
<dl>
<dt>H. D. Joos, G. Gruebel:
<dd><b>RASP'91 Regulator Analysis and Synthesis Programs</b><br>
    DLR - Control Systems Group 1991
</dl>
</p>

<pre>
</PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>T</TD><TD>1</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>phi[size(A, 1), size(A, 1)]</TD><TD>= exp(A*T)</TD></TR>
<TR><TD>Real</TD><TD>gamma[size(A, 1), size(B, 2)]</TD><TD>= integral(phi)*B</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> integralExp <font color="darkgreen">
  &quot;Computation of the transition-matrix phi and its integral gamma&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red"> size</font>(A, 1)];
  <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1), :];
  <font color="blue">input </font>Real T=1;
  <font color="blue">output </font>Real phi[<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 1)] <font color="darkgreen">&quot;= exp(A*T)&quot;</font>;
  <font color="blue">output </font>Real gamma[<font color="red">size</font>(A, 1),<font color="red"> size</font>(B, 2)] <font color="darkgreen">&quot;= integral(phi)*B&quot;</font>;
<font color="blue">protected </font>
  <font color="blue">parameter </font>Integer nmax=21;
  <font color="darkgreen">/*max number of iterations*/</font>
  <font color="blue">parameter </font>Integer na=<font color="red">size</font>(A, 1);
  Integer j=2;
  Integer k=0;
  Boolean done=false;
  Real Anorm;
  Real Tscaled=1;
  Real Atransf[na, na];
  Real Psi[na, na];
  <font color="darkgreen">/*Psi: dummy variable for psi*/</font>
  Real M[na, na];
  <font color="darkgreen">/*M: dummy matrix*/</font>
  Real Diag[na];
  <font color="darkgreen">/*diagonal transformation matrix for balancing*/</font>


<font color="blue">encapsulated </font><font color="blue">function</font> columnNorm <font color="darkgreen">
    &quot;Returns the column norm of a matrix&quot;</font>
  <font color="blue">input </font>Real A[:, :] <font color="darkgreen">&quot;Input matrix&quot;</font>;
  <font color="blue">output </font>Real result=0.0 <font color="darkgreen">&quot;1-norm of matrix A&quot;</font>;
<font color="blue">algorithm </font>
   <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A, 2)<font color="blue"> loop</font>
      result :=<font color="red"> max</font>(result,<font color="red"> sum</font>(<font color="red">abs</font>(A[:, i])));
   <font color="blue">end for</font>;
<font color="blue">end </font>columnNorm;
<font color="blue">algorithm </font>
  <font color="darkgreen">// balancing of A</font>
  (Diag,Atransf) :=<font color="red"> balance</font>(A);

  <font color="darkgreen">// scaling of T until norm(A)*/(2^k) &lt; 0.5</font>
  Tscaled := T;
  <font color="darkgreen">/*Anorm: column-norm of matrix A*/</font>
  <font color="darkgreen">// Anorm := norm(Atransf, 1);</font>
  Anorm :=<font color="red"> columnNorm</font>(Atransf);
  Anorm := Anorm*T;
  <font color="blue">while </font>Anorm &gt;= 0.5<font color="blue"> loop</font>
    Anorm := Anorm/2;
    Tscaled := Tscaled/2;
    k := k + 1;
  <font color="blue">end while</font>;

  <font color="darkgreen">// Computation of psi by Taylor-series approximation</font>
  M :=<font color="red"> identity</font>(na)*Tscaled;
  Psi := M;
  <font color="blue">while </font>j &lt; nmax<font color="blue"> and </font><font color="blue">not </font>done<font color="blue"> loop</font>
    M := Atransf*M*Tscaled/j;
    <font color="darkgreen">//stop if the new element of the series is small</font>
    <font color="darkgreen">// if norm((Psi + M) - Psi, 1) == 0 then</font>
    <font color="blue">if </font><font color="red">columnNorm</font>((Psi + M) - Psi) == 0<font color="blue"> then</font>
      done := true;
    <font color="blue">else</font>
      Psi := M + Psi;
      j := j + 1;
    <font color="blue">end if</font>;
  <font color="blue">end while</font>;

  <font color="darkgreen">// re-scaling</font>
  <font color="blue">for </font>j<font color="blue"> in </font>1:k<font color="blue"> loop</font>
    Psi := Atransf*Psi*Psi + 2*Psi;
  <font color="blue">end for</font>;

  <font color="darkgreen">// re-balancing: psi := diagonal(Diag)*D*inv(diagonal(Diag));</font>
  <font color="blue">for </font>j<font color="blue"> in </font>1:na<font color="blue"> loop</font>
    <font color="blue">for </font>k<font color="blue"> in </font>1:na<font color="blue"> loop</font>
      Psi[j, k] := Psi[j, k]*Diag[j]/Diag[k];
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;
  gamma := Psi*B;
  phi := A*Psi +<font color="red"> identity</font>(na);

<font color="blue">end </font>integralExp;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE integralExpT<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.integralExpT" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.integralExpT"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.integralExpT</H2>
<B>Computation of the transition-matrix phi and the integral gamma and gamma1</B><p>
<P><H3>Information</H3>
<PRE></pre>
<p>
The function calculates the matrices phi,gamma,gamma1 through the equation:
</p>
<pre>                                 [ A B 0 ]
[phi gamma gamma1] = [I 0 0]*exp([ 0 0 I ]*T)
                                 [ 0 0 0 ]
</pre>
<pre>
<b>Syntax:</b><br>
      (phi,gamma,gamma1) = Matrices.ExpIntegral2(A,B,T)
                     A,phi: [n,n] square matrices
            B,gamma,gamma1: [n,m] matrices
                         T: scalar, e.g. sampling time
</pre>
<p>
The matrices define the discretized first-order-hold equivalent of
a state-space system:
<pre>      x(k+1) = phi*x(k) + gamma*u(k) + gamma1/T*(u(k+1) - u(k))
</pre>
The first-order-hold sampling, also known as ramp-invariant method, gives
more smooth control signals as the ZOH equivalent. First-order-hold sampling
is discribed in
<dl>
<dt>K. J. Astroem, B. Wittenmark:
<dd><b>Computer Controlled Systems - Theory and Design</b><br>
    Third Edition, p. 256
</dl>
</p>

<pre>
</PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>T</TD><TD>1</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>phi[size(A, 1), size(A, 1)]</TD><TD>= exp(A*T)</TD></TR>
<TR><TD>Real</TD><TD>gamma[size(A, 1), size(B, 2)]</TD><TD>= integral(phi)*B</TD></TR>
<TR><TD>Real</TD><TD>gamma1[size(A, 1), size(B, 2)]</TD><TD>= integral((T-t)*exp(A*t))*B</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> integralExpT <font color="darkgreen">
  &quot;Computation of the transition-matrix phi and the integral gamma and gamma1&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red"> size</font>(A, 1)];
  <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1), :];
  <font color="blue">input </font>Real T=1;
  <font color="blue">output </font>Real phi[<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 1)] <font color="darkgreen">&quot;= exp(A*T)&quot;</font>;
  <font color="blue">output </font>Real gamma[<font color="red">size</font>(A, 1),<font color="red"> size</font>(B, 2)] <font color="darkgreen">&quot;= integral(phi)*B&quot;</font>;
  <font color="blue">output </font>Real gamma1[<font color="red">size</font>(A, 1),<font color="red"> size</font>(B, 2)] <font color="darkgreen">&quot;= integral((T-t)*exp(A*t))*B&quot;</font>;
<font color="blue">protected </font>
  Integer nmax=200;
  <font color="darkgreen">/*max number of iterations*/</font>
  <font color="blue">parameter </font>Integer na=<font color="red">size</font>(A, 1);
  <font color="blue">parameter </font>Integer nb=<font color="red">size</font>(B, 2);
  Integer j=1;
  Boolean done=false;
  Real F[na + 2*nb, na + 2*nb];


<font color="blue">algorithm </font>
  F := [A, B,<font color="red"> zeros</font>(na, nb);<font color="red"> zeros</font>(2*nb, na),<font color="red"> zeros</font>(2*nb, nb), [<font color="red">identity</font>(nb);
     <font color="red">zeros</font>(nb, nb)]];
  F :=<font color="red"> exp</font>(F, T);
  phi := F[1:na, 1:na];
  gamma := F[1:na, na + 1:na + nb];
  gamma1 := F[1:na, na + nb + 1:na + 2*nb];

<font color="blue">end </font>integralExpT;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.Dymola.com/">Dymola</a> Mon Sep  7 10:20:33 2009.
</address></BODY>
</HTML>
