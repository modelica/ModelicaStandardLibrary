
<html>
<head>
  <meta charset="UTF-8">
  <title>Modelica: Math.Matrices.LAPACK.dhseqr</title>
  <link rel=stylesheet type=text/css href="resources/documentation.css">
  <script src="resources/jquery.min.js"></script>
  <script src="resources/scripts.js"></script>
</head>
<body>
<div class="wrapper">
<nav>
  <ul class="cf">
    <li><a href="https://www.wolfram.com/system-modeler/">System Modeler</a></li>
  <li><a href="Modelica.html">Modelica</a></li>
  <li><a href="Modelica.Math.html">Math</a></li>
  <li><a href="Modelica.Math.Matrices.html">Matrices</a></li>
  <li><a href="Modelica.Math.Matrices.LAPACK.html">LAPACK</a></li>
  <li><a href="Modelica.Math.Matrices.LAPACK.dhseqr.html">dhseqr</a></li>
  </ul>
</nav>
<header>
  <table><tr><td>
    <h1>dhseqr</h1>
    <p>Compute eigenvalues of a matrix H using lapack routine DHSEQR for Hessenberg form matrix</p>
  </td><td>
    <div><img width="60" height="60" src="resources/icons/Modelica.Math.Matrices.LAPACK.dhseqr_60x60.png"></div>
  </td></tr></table>
</header>
<section id="information">
<h1>Information</h1>
<div class="hideable">
<p class="aside">This information is part of the Modelica Standard Library maintained by the Modelica Association.</p>
<pre>Lapack documentation
    Purpose
    =======

    DHSEQR computes the eigenvalues of a Hessenberg matrix H
    and, optionally, the matrices T and Z from the Schur decomposition
    H = Z T Z**T, where T is an upper quasi-triangular matrix (the
    Schur form), and Z is the orthogonal matrix of Schur vectors.

    Optionally Z may be postmultiplied into an input orthogonal
    matrix Q so that this routine can give the Schur factorization
    of a matrix A which has been reduced to the Hessenberg form H
    by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.

    Arguments
    =========

    JOB   (input) CHARACTER*1
          = 'E':  compute eigenvalues only;
          = 'S':  compute eigenvalues and the Schur form T.

    COMPZ (input) CHARACTER*1
          = 'N':  no Schur vectors are computed;
          = 'I':  Z is initialized to the unit matrix and the matrix Z
                  of Schur vectors of H is returned;
          = 'V':  Z must contain an orthogonal matrix Q on entry, and
                  the product Q*Z is returned.

    N     (input) INTEGER
          The order of the matrix H.  N >= 0.

    ILO   (input) INTEGER
    IHI   (input) INTEGER
          It is assumed that H is already upper triangular in rows
          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
          set by a previous call to DGEBAL, and then passed to DGEHRD
          when the matrix output by DGEBAL is reduced to Hessenberg
          form. Otherwise ILO and IHI should be set to 1 and N
          respectively.  If N>0, then 1<=ILO<=IHI<=N.
          If N = 0, then ILO = 1 and IHI = 0.

    H     (input/output) DOUBLE PRECISION array, dimension (LDH,N)
          On entry, the upper Hessenberg matrix H.
          On exit, if INFO = 0 and JOB = 'S', then H contains the
          upper quasi-triangular matrix T from the Schur decomposition
          (the Schur form); 2-by-2 diagonal blocks (corresponding to
          complex conjugate pairs of eigenvalues) are returned in
          standard form, with H(i,i) = H(i+1,i+1) and
          H(i+1,i)*H(i,i+1)<0. If INFO = 0 and JOB = 'E', the
          contents of H are unspecified on exit.  (The output value of
          H when INFO>0 is given under the description of INFO
          below.)

          Unlike earlier versions of DHSEQR, this subroutine may
          explicitly H(i,j) = 0 for i>j and j = 1, 2, ... ILO-1
          or j = IHI+1, IHI+2, ... N.

    LDH   (input) INTEGER
          The leading dimension of the array H. LDH >= max(1,N).

    WR    (output) DOUBLE PRECISION array, dimension (N)
    WI    (output) DOUBLE PRECISION array, dimension (N)
          The real and imaginary parts, respectively, of the computed
          eigenvalues. If two eigenvalues are computed as a complex
          conjugate pair, they are stored in consecutive elements of
          WR and WI, say the i-th and (i+1)th, with WI(i) > 0 and
          WI(i+1) < 0. If JOB = 'S', the eigenvalues are stored in
          the same order as on the diagonal of the Schur form returned
          in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
          diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
          WI(i+1) = -WI(i).

    Z     (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
          If COMPZ = 'N', Z is not referenced.
          If COMPZ = 'I', on entry Z need not be set and on exit,
          if INFO = 0, Z contains the orthogonal matrix Z of the Schur
          vectors of H.  If COMPZ = 'V', on entry Z must contain an
          N-by-N matrix Q, which is assumed to be equal to the unit
          matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
          if INFO = 0, Z contains Q*Z.
          Normally Q is the orthogonal matrix generated by DORGHR
          after the call to DGEHRD which formed the Hessenberg matrix
          H. (The output value of Z when INFO>0 is given under
          the description of INFO below.)

    LDZ   (input) INTEGER
          The leading dimension of the array Z.  if COMPZ = 'I' or
          COMPZ = 'V', then LDZ>=MAX(1,N).  Otherwise, LDZ>=1.

    WORK  (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
          On exit, if INFO = 0, WORK(1) returns an estimate of
          the optimal value for LWORK.

    LWORK (input) INTEGER
          The dimension of the array WORK.  LWORK >= max(1,N)
          is sufficient and delivers very good and sometimes
          optimal performance.  However, LWORK as large as 11*N
          may be required for optimal performance.  A workspace
          query is recommended to determine the optimal workspace
          size.

          If LWORK = -1, then DHSEQR does a workspace query.
          In this case, DHSEQR checks the input parameters and
          estimates the optimal workspace size for the given
          values of N, ILO and IHI.  The estimate is returned
          in WORK(1).  No error message related to LWORK is
          issued by XERBLA.  Neither H nor Z are accessed.

    INFO  (output) INTEGER
          = 0: successful exit
          < 0: if INFO = -i, the i-th argument had an illegal
               value
          > 0: if INFO = i, DHSEQR failed to compute all of
               the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
               and WI contain those eigenvalues which have been
               successfully computed.  (Failures are rare.)

               If INFO > 0 and JOB = 'E', then on exit, the
               remaining unconverged eigenvalues are the eigen-
               values of the upper Hessenberg matrix rows and
               columns ILO through INFO of the final, output
               value of H.

               If INFO > 0 and JOB   = 'S', then on exit

          (*)  (initial value of H)*U  = U*(final value of H)

               where U is an orthogonal matrix.  The final
               value of H is upper Hessenberg and quasi-triangular
               in rows and columns INFO+1 through IHI.

               If INFO > 0 and COMPZ = 'V', then on exit

                 (final value of Z)  =  (initial value of Z)*U

               where U is the orthogonal matrix in (*) (regard-
               less of the value of JOB.)

               If INFO > 0 and COMPZ = 'I', then on exit
                     (final value of Z)  = U
               where U is the orthogonal matrix in (*) (regard-
               less of the value of JOB.)

               If INFO > 0 and COMPZ = 'N', then Z is not
               accessed.</pre>
</div>
</section>
<section id="syntax" >
  <h1>Syntax </h1>
  <div class="hideable">(alphaReal, alphaImag, info, Ho, Zo, work) = dhseqr(H, eigenValuesOnly, compz, Z)
  </div>
</section>
<section id="input" >
  <h1>Inputs <span class="count">(4)</span></h1>
  <div class="hideable">
    <table class="shared-styles style-1">
    <colgroup><col class="col-1" /><col class="col-2" /></colgroup>
    <tbody>
    <tr>
      <th>H</th>
      <td>
        <p><span>Type:</span> Real[:,size(H, 1)]</p>
        <p><span>Description:</span> Matrix H with Hessenberg form</p>
      </td>
    </tr>
    <tr>
      <th>eigenValuesOnly</th>
      <td>
        <p><span>Default Value:</span> true</p>
        <p><span>Type:</span> Boolean</p>
        <p><span>Description:</span> = true, if only eigenvalues are computed, otherwise compute the Schur form too</p>
      </td>
    </tr>
    <tr>
      <th>compz</th>
      <td>
        <p><span>Default Value:</span> "N"</p>
        <p><span>Type:</span> String</p>
        <p><span>Description:</span> Specifies the computation of the Schur vectors</p>
      </td>
    </tr>
    <tr>
      <th>Z</th>
      <td>
        <p><span>Default Value:</span> H</p>
        <p><span>Type:</span> Real[:,:]</p>
        <p><span>Description:</span> Matrix Z</p>
      </td>
    </tr>
    </tbody>
    </table>
  </div>
</section>
<section id="output" >
  <h1>Outputs <span class="count">(6)</span></h1>
  <div class="hideable">
    <table class="shared-styles style-1">
    <colgroup><col class="col-1" /><col class="col-2" /></colgroup>
    <tbody>
    <tr>
      <th>alphaReal</th>
      <td>
        <p><span>Type:</span> Real[size(H, 1)]</p>
        <p><span>Description:</span> Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))</p>
      </td>
    </tr>
    <tr>
      <th>alphaImag</th>
      <td>
        <p><span>Type:</span> Real[size(H, 1)]</p>
        <p><span>Description:</span> Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))</p>
      </td>
    </tr>
    <tr>
      <th>info</th>
      <td>
        <p><span>Type:</span> Integer</p>
      </td>
    </tr>
    <tr>
      <th>Ho</th>
      <td>
        <p><span>Default Value:</span> H</p>
        <p><span>Type:</span> Real[:,:]</p>
        <p><span>Description:</span> Schur decomposition (if eigenValuesOnly==false, unspecified else)</p>
      </td>
    </tr>
    <tr>
      <th>Zo</th>
      <td>
        <p><span>Default Value:</span> Z</p>
        <p><span>Type:</span> Real[:,:]</p>
      </td>
    </tr>
    <tr>
      <th>work</th>
      <td>
        <p><span>Type:</span> Real[3 * max(1, size(H, 1))]</p>
      </td>
    </tr>
    </tbody>
    </table>
  </div>
</section>
</div>
</body>
</html>