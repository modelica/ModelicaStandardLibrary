
<html>
<head>
  <meta charset="UTF-8">
  <title>Modelica: StateGraph.UsersGuide.ApplicationExample</title>
  <link rel=stylesheet type=text/css href="resources/documentation.css">
  <script src="resources/jquery.min.js"></script>
  <script src="resources/scripts.js"></script>
</head>
<body>
<div class="wrapper">
<nav>
  <ul class="cf">
    <li><a href="https://www.wolfram.com/system-modeler/">System Modeler</a></li>
  <li><a href="Modelica.html">Modelica</a></li>
  <li><a href="Modelica.StateGraph.html">StateGraph</a></li>
  <li><a href="Modelica.StateGraph.UsersGuide.html">UsersGuide</a></li>
  <li><a href="Modelica.StateGraph.UsersGuide.ApplicationExample.html">ApplicationExample</a></li>
  </ul>
</nav>
<header>
  <table><tr><td>
    <h1>ApplicationExample</h1>
    <p>An application example</p>
  </td><td>
    <div><img width="60" height="60" src="resources/icons/Modelica.StateGraph.UsersGuide.ApplicationExample_60x60.png"></div>
  </td></tr></table>
</header>
<section id="information">
<h1>Information</h1>
<div class="hideable">
<p class="aside">This information is part of the Modelica Standard Library maintained by the Modelica Association.</p>
<p>
In this section a more realistic, still simple, application example
is given, to demonstrate various features of the StateGraph library.
This example shows the control of a two tank system from the master thesis
of Isolde Dressler
(<a href="Modelica.StateGraph.UsersGuide.Literature.html">see literature</a>).
</p>
<p>
In the following figure the top level of the model is shown.
This model is available as StateGraph.Examples.ControlledTanks.
</p>

<p>
<img src="resources/Modelica.StateGraph.UsersGuide.ApplicationExample_info_001.png">
</p>

<p>
In the right part of the figure, two tanks are shown. At the top part,
a large fluid source is present from which fluid can be filled in
<strong>tank1</strong> when <strong>valve1</strong> is open. Tank1 can be emptied via
<strong>valve2</strong> that is located in the bottom of tank2 and
fills a second <strong>tank2</strong> which in turn is emptied via
<strong>valve3</strong>. The actual levels of the tanks are measured
and are provided as signals <strong>level1</strong> and <strong>level2</strong>
to the <strong>tankController</strong>.
</p>
<p>
The <strong>tankController</strong> is controlled by three buttons,
<strong>start</strong>, <strong>stop</strong> and <strong>shut</strong> (for shutdown)
that are mutually exclusive. This means that whenever one button is
pressed (i.e., its state is <strong>true</strong>) then the other two
buttons are not pressed (i.e., their states are <strong>false</strong>).
When button <strong>start</strong> is pressed, the "normal" operation
to fill and to empty the two tanks is processed:
</p>
<ol>
<li> Valve 1 is opened and tank 1 is filled.</li>
<li> When tank 1 reaches its fill level limit,
     valve 1 is closed.</li>
<li> After a waiting time, valve 2 is
     opened and the fluid flows from tank 1 into tank 2.</li>
<li> When tank 1 is empty, valve 2 is closed.</li>
<li> After a waiting time, valve 3 is opened and
     the fluid flows out of tank 2.</li>
<li> When tank 2 is empty, valve 3 is closed.</li>
</ol>
<p>
The above "normal" process can be influenced by the following
buttons:
</p>
<ul>
<li> Button <strong>start</strong> starts the above process.
     When this button is pressed after a "stop" or
     "shut" operation, the process operation continues.
     </li>
<li> Button <strong>stop</strong> stops the above process by
     closing all valves. Then, the controller waits for
     further input (either "start" or "shut" operation).</li>
<li> Button <strong>shut</strong> is used to shutdown the process,
     by emptying at once both tanks. When this is achieved,
     the process goes back to its start configuration.
     Clicking on "start", restarts the process.</li>
</ul>
<p>
The implementation of the <strong>tankController</strong> is shown in
the next figure:
</p>

<p>
<img src="resources/Modelica.StateGraph.UsersGuide.ApplicationExample_info_002.png">
</p>

<p>
When the "<strong>start</strong>" button is pressed, the stateGraph is
within the CompositeStep "<strong>makeProduct</strong>". During normal
operation this CompositeStep is only left, once tank2 is empty.
Afterwards, the CompositeStep is at once re-entered.
</p>
<p>
When the "<strong>stop</strong>" button is pressed, the "makeProduct"
CompositeStep is at once terminated via the "<strong>suspend</strong>" port
and the stateGraph waits in step "<strong>s2</strong>" for further
commands. When the "<strong>start</strong>" button is pressed, the CompositeStep
is re-entered via its <strong>resume</strong> port and the "normal"
operation continues at the state where it was aborted by the
suspend transition. If the "<strong>shut</strong>" button is pressed,
the stateGraph waits in the "<strong>emptyTanks</strong>" step, until
both tanks are empty and then waits at the initial step
"<strong>s1</strong>" for further input.
</p>
<p>
The opening and closing of valves is <strong>not</strong> directly
defined in the stateGraph. Instead via the "<strong>setValveX</strong>"
components, the Boolean state of the valves are computed.
For example, the output y of "setValve2" is computed as:
</p>
<blockquote><pre>
y = makeProduct.fillTank2.active or emptyTanks.active
</pre></blockquote>
<p>
i.e., valve2 is open, when step "makeProduct.fillTank2 or when
step "emptyTanks" is active. Otherwise, valve2 is closed.
</p>
</div>
</section>
</div>
</body>
</html>